(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') {
    module.exports = factory()
  } else if (typeof define === 'function' && define.amd) {
    define([], factory)
  } else if (typeof exports === 'object') {
    exports['DataSet'] = factory()
  } else {
    root['DataSet'] = factory()
  }
})(this, function () {
  return /******/ (function (modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {}
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/
      if (installedModules[moduleId]) {
        /******/
        return installedModules[moduleId].exports
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = installedModules[moduleId] = {
        /******/
        i: moduleId,
        /******/
        l: false,
        /******/
        exports: {}
        /******/
      }
      /******/
      /******/ // Execute the module function
      /******/
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)
      /******/
      /******/ // Flag the module as loaded
      /******/
      module.l = true
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports
      /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function (exports, name, getter) {
      /******/
      if (!__webpack_require__.o(exports, name)) {
        /******/
        Object.defineProperty(exports, name, {
          /******/
          configurable: false,
          /******/
          enumerable: true,
          /******/
          get: getter
          /******/
        })
        /******/
      }
      /******/
    }
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function (module) {
      /******/
      var getter = module && module.__esModule
        /******/
        ? function getDefault() {
          return module['default']
        }
        /******/
        : function getModuleExports() {
          return module
        }
      /******/
      __webpack_require__.d(getter, 'a', getter)
      /******/
      return getter
      /******/
    }
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property)
    }
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = ''
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 268)
    /******/
  })
  /************************************************************************/
  /******/
  ([
    /* 0 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _area = __webpack_require__(145)

      Object.defineProperty(exports, 'geoArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_area).default
        }
      })

      var _bounds = __webpack_require__(289)

      Object.defineProperty(exports, 'geoBounds', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bounds).default
        }
      })

      var _centroid = __webpack_require__(290)

      Object.defineProperty(exports, 'geoCentroid', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_centroid).default
        }
      })

      var _circle = __webpack_require__(146)

      Object.defineProperty(exports, 'geoCircle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_circle).default
        }
      })

      var _extent = __webpack_require__(83)

      Object.defineProperty(exports, 'geoClipExtent', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_extent).default
        }
      })

      var _contains = __webpack_require__(309)

      Object.defineProperty(exports, 'geoContains', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_contains).default
        }
      })

      var _distance = __webpack_require__(164)

      Object.defineProperty(exports, 'geoDistance', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_distance).default
        }
      })

      var _graticule = __webpack_require__(310)

      Object.defineProperty(exports, 'geoGraticule', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_graticule).default
        }
      })
      Object.defineProperty(exports, 'geoGraticule10', {
        enumerable: true,
        get: function get() {
          return _graticule.graticule10
        }
      })

      var _interpolate = __webpack_require__(311)

      Object.defineProperty(exports, 'geoInterpolate', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_interpolate).default
        }
      })

      var _length = __webpack_require__(165)

      Object.defineProperty(exports, 'geoLength', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_length).default
        }
      })

      var _index = __webpack_require__(312)

      Object.defineProperty(exports, 'geoPath', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index).default
        }
      })

      var _albers = __webpack_require__(167)

      Object.defineProperty(exports, 'geoAlbers', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_albers).default
        }
      })

      var _albersUsa = __webpack_require__(322)

      Object.defineProperty(exports, 'geoAlbersUsa', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_albersUsa).default
        }
      })

      var _azimuthalEqualArea = __webpack_require__(323)

      Object.defineProperty(exports, 'geoAzimuthalEqualArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_azimuthalEqualArea).default
        }
      })
      Object.defineProperty(exports, 'geoAzimuthalEqualAreaRaw', {
        enumerable: true,
        get: function get() {
          return _azimuthalEqualArea.azimuthalEqualAreaRaw
        }
      })

      var _azimuthalEquidistant = __webpack_require__(324)

      Object.defineProperty(exports, 'geoAzimuthalEquidistant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_azimuthalEquidistant).default
        }
      })
      Object.defineProperty(exports, 'geoAzimuthalEquidistantRaw', {
        enumerable: true,
        get: function get() {
          return _azimuthalEquidistant.azimuthalEquidistantRaw
        }
      })

      var _conicConformal = __webpack_require__(325)

      Object.defineProperty(exports, 'geoConicConformal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicConformal).default
        }
      })
      Object.defineProperty(exports, 'geoConicConformalRaw', {
        enumerable: true,
        get: function get() {
          return _conicConformal.conicConformalRaw
        }
      })

      var _conicEqualArea = __webpack_require__(86)

      Object.defineProperty(exports, 'geoConicEqualArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicEqualArea).default
        }
      })
      Object.defineProperty(exports, 'geoConicEqualAreaRaw', {
        enumerable: true,
        get: function get() {
          return _conicEqualArea.conicEqualAreaRaw
        }
      })

      var _conicEquidistant = __webpack_require__(326)

      Object.defineProperty(exports, 'geoConicEquidistant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicEquidistant).default
        }
      })
      Object.defineProperty(exports, 'geoConicEquidistantRaw', {
        enumerable: true,
        get: function get() {
          return _conicEquidistant.conicEquidistantRaw
        }
      })

      var _equirectangular = __webpack_require__(169)

      Object.defineProperty(exports, 'geoEquirectangular', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_equirectangular).default
        }
      })
      Object.defineProperty(exports, 'geoEquirectangularRaw', {
        enumerable: true,
        get: function get() {
          return _equirectangular.equirectangularRaw
        }
      })

      var _gnomonic = __webpack_require__(327)

      Object.defineProperty(exports, 'geoGnomonic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gnomonic).default
        }
      })
      Object.defineProperty(exports, 'geoGnomonicRaw', {
        enumerable: true,
        get: function get() {
          return _gnomonic.gnomonicRaw
        }
      })

      var _identity = __webpack_require__(328)

      Object.defineProperty(exports, 'geoIdentity', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_identity).default
        }
      })

      var _index2 = __webpack_require__(16)

      Object.defineProperty(exports, 'geoProjection', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index2).default
        }
      })
      Object.defineProperty(exports, 'geoProjectionMutator', {
        enumerable: true,
        get: function get() {
          return _index2.projectionMutator
        }
      })

      var _mercator = __webpack_require__(89)

      Object.defineProperty(exports, 'geoMercator', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mercator).default
        }
      })
      Object.defineProperty(exports, 'geoMercatorRaw', {
        enumerable: true,
        get: function get() {
          return _mercator.mercatorRaw
        }
      })

      var _orthographic = __webpack_require__(329)

      Object.defineProperty(exports, 'geoOrthographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_orthographic).default
        }
      })
      Object.defineProperty(exports, 'geoOrthographicRaw', {
        enumerable: true,
        get: function get() {
          return _orthographic.orthographicRaw
        }
      })

      var _stereographic = __webpack_require__(330)

      Object.defineProperty(exports, 'geoStereographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stereographic).default
        }
      })
      Object.defineProperty(exports, 'geoStereographicRaw', {
        enumerable: true,
        get: function get() {
          return _stereographic.stereographicRaw
        }
      })

      var _transverseMercator = __webpack_require__(331)

      Object.defineProperty(exports, 'geoTransverseMercator', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transverseMercator).default
        }
      })
      Object.defineProperty(exports, 'geoTransverseMercatorRaw', {
        enumerable: true,
        get: function get() {
          return _transverseMercator.transverseMercatorRaw
        }
      })

      var _rotation = __webpack_require__(57)

      Object.defineProperty(exports, 'geoRotation', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_rotation).default
        }
      })

      var _stream = __webpack_require__(25)

      Object.defineProperty(exports, 'geoStream', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stream).default
        }
      })

      var _transform = __webpack_require__(58)

      Object.defineProperty(exports, 'geoTransform', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transform).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 1 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.sinci = sinci
      exports.asin = asin
      exports.acos = acos
      exports.sqrt = sqrt
      exports.tanh = tanh
      exports.sinh = sinh
      exports.cosh = cosh
      exports.arsinh = arsinh
      exports.arcosh = arcosh
      var abs = exports.abs = Math.abs
      var atan = exports.atan = Math.atan
      var atan2 = exports.atan2 = Math.atan2
      var ceil = exports.ceil = Math.ceil
      var cos = exports.cos = Math.cos
      var exp = exports.exp = Math.exp
      var floor = exports.floor = Math.floor
      var log = exports.log = Math.log
      var max = exports.max = Math.max
      var min = exports.min = Math.min
      var pow = exports.pow = Math.pow
      var round = exports.round = Math.round
      var sign = exports.sign = Math.sign || function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0
      }
      var sin = exports.sin = Math.sin
      var tan = exports.tan = Math.tan

      var epsilon = exports.epsilon = 1e-6
      var epsilon2 = exports.epsilon2 = 1e-12
      var pi = exports.pi = Math.PI
      var halfPi = exports.halfPi = pi / 2
      var quarterPi = exports.quarterPi = pi / 4
      var sqrt1_2 = exports.sqrt1_2 = Math.SQRT1_2
      var sqrt2 = exports.sqrt2 = sqrt(2)
      var sqrtPi = exports.sqrtPi = sqrt(pi)
      var tau = exports.tau = pi * 2
      var degrees = exports.degrees = 180 / pi
      var radians = exports.radians = pi / 180

      function sinci(x) {
        return x ? x / Math.sin(x) : 1
      }

      function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x)
      }

      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x)
      }

      function sqrt(x) {
        return x > 0 ? Math.sqrt(x) : 0
      }

      function tanh(x) {
        x = exp(2 * x)
        return (x - 1) / (x + 1)
      }

      function sinh(x) {
        return (exp(x) - exp(-x)) / 2
      }

      function cosh(x) {
        return (exp(x) + exp(-x)) / 2
      }

      function arsinh(x) {
        return log(x + sqrt(x * x + 1))
      }

      function arcosh(x) {
        return log(x + sqrt(x * x - 1))
      }
      /***/
    },
    /* 2 */
    /***/
    function (module, exports, __webpack_require__) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return call && (typeof call === 'object' || typeof call === 'function') ? call : self
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass)
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
      }

      var assign = __webpack_require__(5)
      var isNil = __webpack_require__(118)
      var isObject = __webpack_require__(12)
      var uniqueId = __webpack_require__(579)
      var EventEmitter = __webpack_require__(180)
      var View = __webpack_require__(42)
      var CONSTANTS = __webpack_require__(580)

      var DataSet = (function (_EventEmitter) {
        _inherits(DataSet, _EventEmitter)

        function DataSet() {
          var initialProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            state: {}
          }

          _classCallCheck(this, DataSet)

          var _this = _possibleConstructorReturn(this, _EventEmitter.call(this))

          var me = _this
          assign(me, {
            _onChangeTimer: null,
            DataSet: DataSet,
            isDataSet: true,
            views: {}
          }, initialProps)
          return _this
        }

        DataSet.prototype._getUniqueViewName = function _getUniqueViewName() {
          var me = this
          var name = uniqueId('view_')
          while (me.views[name]) {
            name = uniqueId('view_')
          }
          return name
        }

        DataSet.prototype.createView = function createView(name) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

          var me = this
          if (isNil(name)) {
            name = me._getUniqueViewName()
          }
          if (isObject(name)) {
            options = name
            name = me._getUniqueViewName()
          }
          if (me.views[name]) {
            throw new Error('data view exists: ' + name)
          }
          var view = new View(me, options)
          me.views[name] = view
          return view
        }

        DataSet.prototype.getView = function getView(name) {
          return this.views[name]
        }

        DataSet.prototype.setView = function setView(name, view) {
          this.views[name] = view
        }

        DataSet.prototype.setState = function setState(name, value) {
          var me = this
          me.state[name] = value
          if (me._onChangeTimer) {
            clearTimeout(me._onChangeTimer)
            me._onChangeTimer = null
          }
          me._onChangeTimer = setTimeout(function () {
            me.emit('statechange', name, value)
          }, 16) // execute after one frame
        }

        return DataSet
      }(EventEmitter))

      assign(DataSet, {
        CONSTANTS: CONSTANTS,
        DataSet: DataSet,
        DataView: View, // alias
        View: View,
        connectors: {},
        transforms: {},

        registerConnector: function registerConnector(name, connector) {
          DataSet.connectors[name] = connector
        },
        getConnector: function getConnector(name) {
          return DataSet.connectors[name] || DataSet.connectors.default
        },
        registerTransform: function registerTransform(name, transform) {
          DataSet.transforms[name] = transform
        },
        getTransform: function getTransform(name) {
          return DataSet.transforms[name] || DataSet.transforms.default
        }
      }, CONSTANTS)

      View.DataSet = DataSet
      assign(DataSet.prototype, {
        view: DataSet.prototype.createView // alias
      })

      module.exports = DataSet
      /***/
    },
    /* 3 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.acos = acos
      exports.asin = asin
      exports.haversin = haversin
      var epsilon = exports.epsilon = 1e-6
      var epsilon2 = exports.epsilon2 = 1e-12
      var pi = exports.pi = Math.PI
      var halfPi = exports.halfPi = pi / 2
      var quarterPi = exports.quarterPi = pi / 4
      var tau = exports.tau = pi * 2

      var degrees = exports.degrees = 180 / pi
      var radians = exports.radians = pi / 180

      var abs = exports.abs = Math.abs
      var atan = exports.atan = Math.atan
      var atan2 = exports.atan2 = Math.atan2
      var cos = exports.cos = Math.cos
      var ceil = exports.ceil = Math.ceil
      var exp = exports.exp = Math.exp
      var floor = exports.floor = Math.floor
      var log = exports.log = Math.log
      var pow = exports.pow = Math.pow
      var sin = exports.sin = Math.sin
      var sign = exports.sign = Math.sign || function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0
      }
      var sqrt = exports.sqrt = Math.sqrt
      var tan = exports.tan = Math.tan

      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x)
      }

      function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x)
      }

      function haversin(x) {
        return (x = sin(x / 2)) * x
      }
      /***/
    },
    /* 4 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.acos = acos
      exports.asin = asin
      exports.haversin = haversin
      var epsilon = exports.epsilon = 1e-6
      var epsilon2 = exports.epsilon2 = 1e-12
      var pi = exports.pi = Math.PI
      var halfPi = exports.halfPi = pi / 2
      var quarterPi = exports.quarterPi = pi / 4
      var tau = exports.tau = pi * 2

      var degrees = exports.degrees = 180 / pi
      var radians = exports.radians = pi / 180

      var abs = exports.abs = Math.abs
      var atan = exports.atan = Math.atan
      var atan2 = exports.atan2 = Math.atan2
      var cos = exports.cos = Math.cos
      var ceil = exports.ceil = Math.ceil
      var exp = exports.exp = Math.exp
      var floor = exports.floor = Math.floor
      var log = exports.log = Math.log
      var pow = exports.pow = Math.pow
      var sin = exports.sin = Math.sin
      var sign = exports.sign = Math.sign || function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0
      }
      var sqrt = exports.sqrt = Math.sqrt
      var tan = exports.tan = Math.tan

      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x)
      }

      function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x)
      }

      function haversin(x) {
        return (x = sin(x / 2)) * x
      }
      /***/
    },
    /* 5 */
    /***/
    function (module, exports, __webpack_require__) {
      var assignValue = __webpack_require__(53),
        copyObject = __webpack_require__(36),
        createAssigner = __webpack_require__(277),
        isArrayLike = __webpack_require__(20),
        isPrototype = __webpack_require__(56),
        keys = __webpack_require__(9)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */
      var assign = createAssigner(function (object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object)
          return
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key])
          }
        }
      })

      module.exports = assign
      /***/
    },
    /* 6 */
    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(7)

      var INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!'
      var INVALID_FIELDS_ERR_MSG = 'Invalid fields: it must be an array!'

      module.exports = {
        getField: function getField(options, defaultField) {
          var field = options.field,
            fields = options.fields

          if (isString(field)) {
            return field
          }
          if (Array.isArray(field)) {
            console.warn(INVALID_FIELD_ERR_MSG)
            return field[0]
          }
          console.warn(INVALID_FIELD_ERR_MSG + ' will try to get fields instead.')
          if (isString(fields)) {
            return fields
          }
          if (Array.isArray(fields) && fields.length) {
            return fields[0]
          }
          if (defaultField) {
            return defaultField
          }
          throw new TypeError(INVALID_FIELD_ERR_MSG)
        },
        getFields: function getFields(options, defaultFields) {
          var field = options.field,
            fields = options.fields

          if (Array.isArray(fields)) {
            return fields
          }
          if (isString(fields)) {
            console.warn(INVALID_FIELDS_ERR_MSG)
            return [fields]
          }
          console.warn(INVALID_FIELDS_ERR_MSG + ' will try to get field instead.')
          if (isString(field)) {
            console.warn(INVALID_FIELDS_ERR_MSG)
            return [field]
          }
          if (Array.isArray(field) && field.length) {
            console.warn(INVALID_FIELDS_ERR_MSG)
            return field
          }
          if (defaultFields) {
            return defaultFields
          }
          throw new TypeError(INVALID_FIELDS_ERR_MSG)
        }
      }
      /***/
    },
    /* 7 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        isArray = __webpack_require__(10),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var stringTag = '[object String]'

      /**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */
      function isString(value) {
        return typeof value === 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
      }

      module.exports = isString
      /***/
    },
    /* 8 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        isObject = __webpack_require__(12)

      /** `Object#toString` result references. */
      var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]'

      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */
      function isFunction(value) {
        if (!isObject(value)) {
          return false
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value)
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
      }

      module.exports = isFunction
      /***/
    },
    /* 9 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayLikeKeys = __webpack_require__(142),
        baseKeys = __webpack_require__(287),
        isArrayLike = __webpack_require__(20)

      /**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
      }

      module.exports = keys
      /***/
    },
    /* 10 */
    /***/
    function (module, exports) {
      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */
      var isArray = Array.isArray

      module.exports = isArray
      /***/
    },
    /* 11 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFor = __webpack_require__(202),
        castFunction = __webpack_require__(485),
        keysIn = __webpack_require__(97)

      /**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */
      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, castFunction(iteratee), keysIn)
      }

      module.exports = forIn
      /***/
    },
    /* 12 */
    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value)
        return value != null && (type == 'object' || type == 'function')
      }

      module.exports = isObject
      /***/
    },
    /* 13 */
    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var freeGlobal = __webpack_require__(137)

      /** Detect free variable `self`. */
      var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')()

      module.exports = root
      /***/
    },
    /* 14 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _bisect = __webpack_require__(151)

      Object.defineProperty(exports, 'bisect', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bisect).default
        }
      })
      Object.defineProperty(exports, 'bisectRight', {
        enumerable: true,
        get: function get() {
          return _bisect.bisectRight
        }
      })
      Object.defineProperty(exports, 'bisectLeft', {
        enumerable: true,
        get: function get() {
          return _bisect.bisectLeft
        }
      })

      var _ascending = __webpack_require__(34)

      Object.defineProperty(exports, 'ascending', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ascending).default
        }
      })

      var _bisector = __webpack_require__(152)

      Object.defineProperty(exports, 'bisector', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bisector).default
        }
      })

      var _cross = __webpack_require__(293)

      Object.defineProperty(exports, 'cross', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cross).default
        }
      })

      var _descending = __webpack_require__(294)

      Object.defineProperty(exports, 'descending', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_descending).default
        }
      })

      var _deviation = __webpack_require__(154)

      Object.defineProperty(exports, 'deviation', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_deviation).default
        }
      })

      var _extent = __webpack_require__(156)

      Object.defineProperty(exports, 'extent', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_extent).default
        }
      })

      var _histogram = __webpack_require__(295)

      Object.defineProperty(exports, 'histogram', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_histogram).default
        }
      })

      var _freedmanDiaconis = __webpack_require__(298)

      Object.defineProperty(exports, 'thresholdFreedmanDiaconis', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_freedmanDiaconis).default
        }
      })

      var _scott = __webpack_require__(299)

      Object.defineProperty(exports, 'thresholdScott', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_scott).default
        }
      })

      var _sturges = __webpack_require__(160)

      Object.defineProperty(exports, 'thresholdSturges', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sturges).default
        }
      })

      var _max = __webpack_require__(300)

      Object.defineProperty(exports, 'max', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_max).default
        }
      })

      var _mean = __webpack_require__(301)

      Object.defineProperty(exports, 'mean', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mean).default
        }
      })

      var _median = __webpack_require__(302)

      Object.defineProperty(exports, 'median', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_median).default
        }
      })

      var _merge = __webpack_require__(303)

      Object.defineProperty(exports, 'merge', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_merge).default
        }
      })

      var _min = __webpack_require__(161)

      Object.defineProperty(exports, 'min', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_min).default
        }
      })

      var _pairs = __webpack_require__(153)

      Object.defineProperty(exports, 'pairs', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_pairs).default
        }
      })

      var _permute = __webpack_require__(304)

      Object.defineProperty(exports, 'permute', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_permute).default
        }
      })

      var _quantile = __webpack_require__(84)

      Object.defineProperty(exports, 'quantile', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_quantile).default
        }
      })

      var _range = __webpack_require__(158)

      Object.defineProperty(exports, 'range', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_range).default
        }
      })

      var _scan = __webpack_require__(305)

      Object.defineProperty(exports, 'scan', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_scan).default
        }
      })

      var _shuffle = __webpack_require__(306)

      Object.defineProperty(exports, 'shuffle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_shuffle).default
        }
      })

      var _sum = __webpack_require__(307)

      Object.defineProperty(exports, 'sum', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sum).default
        }
      })

      var _ticks = __webpack_require__(159)

      Object.defineProperty(exports, 'ticks', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ticks).default
        }
      })
      Object.defineProperty(exports, 'tickIncrement', {
        enumerable: true,
        get: function get() {
          return _ticks.tickIncrement
        }
      })
      Object.defineProperty(exports, 'tickStep', {
        enumerable: true,
        get: function get() {
          return _ticks.tickStep
        }
      })

      var _transpose = __webpack_require__(162)

      Object.defineProperty(exports, 'transpose', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transpose).default
        }
      })

      var _variance = __webpack_require__(155)

      Object.defineProperty(exports, 'variance', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_variance).default
        }
      })

      var _zip = __webpack_require__(308)

      Object.defineProperty(exports, 'zip', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_zip).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 15 */
    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object'
      }

      module.exports = isObjectLike
      /***/
    },
    /* 16 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = projection
      exports.projectionMutator = projectionMutator

      var _antimeridian = __webpack_require__(318)

      var _antimeridian2 = _interopRequireDefault(_antimeridian)

      var _circle = __webpack_require__(319)

      var _circle2 = _interopRequireDefault(_circle)

      var _extent = __webpack_require__(83)

      var _compose = __webpack_require__(147)

      var _compose2 = _interopRequireDefault(_compose)

      var _identity = __webpack_require__(85)

      var _identity2 = _interopRequireDefault(_identity)

      var _math = __webpack_require__(3)

      var _rotation = __webpack_require__(57)

      var _transform = __webpack_require__(58)

      var _fit = __webpack_require__(88)

      var _resample = __webpack_require__(320)

      var _resample2 = _interopRequireDefault(_resample)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var transformRadians = (0, _transform.transformer)({
        point: function point(x, y) {
          this.stream.point(x * _math.radians, y * _math.radians)
        }
      })

      function projection(project) {
        return projectionMutator(function () {
          return project
        })()
      }

      function projectionMutator(projectAt) {
        var project,
          k = 150,
          // scale
          x = 480,
          y = 250,
          // translate
          dx,
          dy,
          lambda = 0,
          phi = 0,
          // center
          deltaLambda = 0,
          deltaPhi = 0,
          deltaGamma = 0,
          rotate,
          projectRotate,
          // rotate
          theta = null,
          preclip = _antimeridian2.default,
          // clip angle
          x0 = null,
          y0,
          x1,
          y1,
          postclip = _identity2.default,
          // clip extent
          delta2 = 0.5,
          projectResample = (0, _resample2.default)(projectTransform, delta2),
          // precision
          cache,
          cacheStream

        function projection(point) {
          point = projectRotate(point[0] * _math.radians, point[1] * _math.radians)
          return [point[0] * k + dx, dy - point[1] * k]
        }

        function invert(point) {
          point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k)
          return point && [point[0] * _math.degrees, point[1] * _math.degrees]
        }

        function projectTransform(x, y) {
          return x = project(x, y), [x[0] * k + dx, dy - x[1] * k]
        }

        projection.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))))
        }

        projection.clipAngle = function (_) {
          return arguments.length ? (preclip = +_ ? (0, _circle2.default)(theta = _ * _math.radians, 6 * _math.radians) : (theta = null, _antimeridian2.default), reset()) : theta * _math.degrees
        }

        projection.clipExtent = function (_) {
          return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity2.default) : (0, _extent.clipExtent)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
            [x0, y0],
            [x1, y1]
          ]
        }

        projection.scale = function (_) {
          return arguments.length ? (k = +_, recenter()) : k
        }

        projection.translate = function (_) {
          return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y]
        }

        projection.center = function (_) {
          return arguments.length ? (lambda = _[0] % 360 * _math.radians, phi = _[1] % 360 * _math.radians, recenter()) : [lambda * _math.degrees, phi * _math.degrees]
        }

        projection.rotate = function (_) {
          return arguments.length ? (deltaLambda = _[0] % 360 * _math.radians, deltaPhi = _[1] % 360 * _math.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math.radians : 0, recenter()) : [deltaLambda * _math.degrees, deltaPhi * _math.degrees, deltaGamma * _math.degrees]
        }

        projection.precision = function (_) {
          return arguments.length ? (projectResample = (0, _resample2.default)(projectTransform, delta2 = _ * _), reset()) : (0, _math.sqrt)(delta2)
        }

        projection.fitExtent = function (extent, object) {
          return (0, _fit.fitExtent)(projection, extent, object)
        }

        projection.fitSize = function (size, object) {
          return (0, _fit.fitSize)(projection, size, object)
        }

        function recenter() {
          projectRotate = (0, _compose2.default)(rotate = (0, _rotation.rotateRadians)(deltaLambda, deltaPhi, deltaGamma), project)
          var center = project(lambda, phi)
          dx = x - center[0] * k
          dy = y + center[1] * k
          return reset()
        }

        function reset() {
          cache = cacheStream = null
          return projection
        }

        return function () {
          project = projectAt.apply(this, arguments)
          projection.invert = project.invert && invert
          return recenter()
        }
      }
      /***/
    },
    /* 17 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = projection
      exports.projectionMutator = projectionMutator

      var _antimeridian = __webpack_require__(507)

      var _antimeridian2 = _interopRequireDefault(_antimeridian)

      var _circle = __webpack_require__(509)

      var _circle2 = _interopRequireDefault(_circle)

      var _extent = __webpack_require__(208)

      var _compose = __webpack_require__(207)

      var _compose2 = _interopRequireDefault(_compose)

      var _identity = __webpack_require__(213)

      var _identity2 = _interopRequireDefault(_identity)

      var _math = __webpack_require__(4)

      var _rotation = __webpack_require__(108)

      var _transform = __webpack_require__(111)

      var _fit = __webpack_require__(217)

      var _resample = __webpack_require__(510)

      var _resample2 = _interopRequireDefault(_resample)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var transformRadians = (0, _transform.transform)({
        point: function point(x, y) {
          this.stream.point(x * _math.radians, y * _math.radians)
        }
      })

      function projection(project) {
        return projectionMutator(function () {
          return project
        })()
      }

      function projectionMutator(projectAt) {
        var project,
          k = 150,
          // scale
          x = 480,
          y = 250,
          // translate
          dx,
          dy,
          lambda = 0,
          phi = 0,
          // center
          deltaLambda = 0,
          deltaPhi = 0,
          deltaGamma = 0,
          rotate,
          projectRotate,
          // rotate
          theta = null,
          preclip = _antimeridian2.default,
          // clip angle
          x0 = null,
          y0,
          x1,
          y1,
          postclip = _identity2.default,
          // clip extent
          delta2 = 0.5,
          projectResample = (0, _resample2.default)(projectTransform, delta2),
          // precision
          cache,
          cacheStream

        function projection(point) {
          point = projectRotate(point[0] * _math.radians, point[1] * _math.radians)
          return [point[0] * k + dx, dy - point[1] * k]
        }

        function invert(point) {
          point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k)
          return point && [point[0] * _math.degrees, point[1] * _math.degrees]
        }

        function projectTransform(x, y) {
          return x = project(x, y), [x[0] * k + dx, dy - x[1] * k]
        }

        projection.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))))
        }

        projection.clipAngle = function (_) {
          return arguments.length ? (preclip = +_ ? (0, _circle2.default)(theta = _ * _math.radians, 6 * _math.radians) : (theta = null, _antimeridian2.default), reset()) : theta * _math.degrees
        }

        projection.clipExtent = function (_) {
          return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity2.default) : (0, _extent.clipExtent)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
            [x0, y0],
            [x1, y1]
          ]
        }

        projection.scale = function (_) {
          return arguments.length ? (k = +_, recenter()) : k
        }

        projection.translate = function (_) {
          return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y]
        }

        projection.center = function (_) {
          return arguments.length ? (lambda = _[0] % 360 * _math.radians, phi = _[1] % 360 * _math.radians, recenter()) : [lambda * _math.degrees, phi * _math.degrees]
        }

        projection.rotate = function (_) {
          return arguments.length ? (deltaLambda = _[0] % 360 * _math.radians, deltaPhi = _[1] % 360 * _math.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math.radians : 0, recenter()) : [deltaLambda * _math.degrees, deltaPhi * _math.degrees, deltaGamma * _math.degrees]
        }

        projection.precision = function (_) {
          return arguments.length ? (projectResample = (0, _resample2.default)(projectTransform, delta2 = _ * _), reset()) : (0, _math.sqrt)(delta2)
        }

        projection.fitExtent = (0, _fit.fitExtent)(projection)

        projection.fitSize = (0, _fit.fitSize)(projection)

        function recenter() {
          projectRotate = (0, _compose2.default)(rotate = (0, _rotation.rotateRadians)(deltaLambda, deltaPhi, deltaGamma), project)
          var center = project(lambda, phi)
          dx = x - center[0] * k
          dy = y + center[1] * k
          return reset()
        }

        function reset() {
          cache = cacheStream = null
          return projection
        }

        return function () {
          project = projectAt.apply(this, arguments)
          projection.invert = project.invert && invert
          return recenter()
        }
      }
      /***/
    },
    /* 18 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8)
      var isString = __webpack_require__(7)
      var groupBy = __webpack_require__(524)
      var simpleSortBy = __webpack_require__(530)

      module.exports = function (rows, group_by) {
        var order_by = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []

        var newRows = rows
        if (order_by && order_by.length) {
          newRows = simpleSortBy(rows, order_by)
        }

        var groupingFn = void 0
        if (isFunction(group_by)) {
          groupingFn = group_by
        } else if (Array.isArray(group_by)) {
          groupingFn = function groupingFn(row) {
            return '_' + group_by.map(function (col) {
              return row[col]
            }).join('-')
          }
          // NOTE: Object.keys({'b': 'b', '2': '2', '1': '1', 'a': 'a'}) => [ '1', '2', 'b', 'a' ]
          // that is why we have to add a prefix
        } else if (isString(group_by)) {
          groupingFn = function groupingFn(row) {
            return '_' + row[group_by]
          }
        }
        var groups = groupBy(newRows, groupingFn)
        return groups
      }
      /***/
    },
    /* 19 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32),
        getRawTag = __webpack_require__(272),
        objectToString = __webpack_require__(273)

      /** `Object#toString` result references. */
      var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]'

      /** Built-in value references. */
      var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)
      }

      module.exports = baseGetTag
      /***/
    },
    /* 20 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8),
        isLength = __webpack_require__(78)

      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value)
      }

      module.exports = isArrayLike
      /***/
    },
    /* 21 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = noop

      function noop() {}
      /***/
    },
    /* 22 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mollweideRaw = undefined
      exports.mollweideBromleyTheta = mollweideBromleyTheta
      exports.mollweideBromleyRaw = mollweideBromleyRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(mollweideRaw).scale(169.529)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function mollweideBromleyTheta(cp, phi) {
        var cpsinPhi = cp * (0, _math.sin)(phi),
          i = 30,
          delta
        do {
          phi -= delta = (phi + (0, _math.sin)(phi) - cpsinPhi) / (1 + (0, _math.cos)(phi))
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        return phi / 2
      }

      function mollweideBromleyRaw(cx, cy, cp) {
        function forward(lambda, phi) {
          return [cx * lambda * (0, _math.cos)(phi = mollweideBromleyTheta(cp, phi)), cy * (0, _math.sin)(phi)]
        }

        forward.invert = function (x, y) {
          return y = (0, _math.asin)(y / cy), [x / (cx * (0, _math.cos)(y)), (0, _math.asin)((2 * y + (0, _math.sin)(2 * y)) / cp)]
        }

        return forward
      }

      var mollweideRaw = exports.mollweideRaw = mollweideBromleyRaw(_math.sqrt2 / _math.halfPi, _math.sqrt2, _math.pi)
      /***/
    },
    /* 23 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sum = __webpack_require__(222)

      /**
       * The mean, _also known as average_,
       * is the sum of all values over the number of values.
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x sample of one or more data points
       * @throws {Error} if the the length of x is less than one
       * @returns {number} mean
       * @example
       * mean([0, 10]); // => 5
       */
      function mean(x /*: Array<number> */ ) /*: number */ {
        // The mean of no numbers is null
        if (x.length === 0) {
          throw new Error('mean requires at least one data point')
        }

        return sum(x) / x.length
      }

      module.exports = mean
      /***/
    },
    /* 24 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsNative = __webpack_require__(270),
        getValue = __webpack_require__(276)

      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */
      function getNative(object, key) {
        var value = getValue(object, key)
        return baseIsNative(value) ? value : undefined
      }

      module.exports = getNative
      /***/
    },
    /* 25 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
          streamObjectType[object.type](object, stream)
        } else {
          streamGeometry(object, stream)
        }
      }

      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream)
        }
      }

      var streamObjectType = {
        Feature: function Feature(object, stream) {
          streamGeometry(object.geometry, stream)
        },
        FeatureCollection: function FeatureCollection(object, stream) {
          var features = object.features,
            i = -1,
            n = features.length
          while (++i < n) {
            streamGeometry(features[i].geometry, stream)
          }
        }
      }

      var streamGeometryType = {
        Sphere: function Sphere(object, stream) {
          stream.sphere()
        },
        Point: function Point(object, stream) {
          object = object.coordinates
          stream.point(object[0], object[1], object[2])
        },
        MultiPoint: function MultiPoint(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            object = coordinates[i], stream.point(object[0], object[1], object[2])
          }
        },
        LineString: function LineString(object, stream) {
          streamLine(object.coordinates, stream, 0)
        },
        MultiLineString: function MultiLineString(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            streamLine(coordinates[i], stream, 0)
          }
        },
        Polygon: function Polygon(object, stream) {
          streamPolygon(object.coordinates, stream)
        },
        MultiPolygon: function MultiPolygon(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            streamPolygon(coordinates[i], stream)
          }
        },
        GeometryCollection: function GeometryCollection(object, stream) {
          var geometries = object.geometries,
            i = -1,
            n = geometries.length
          while (++i < n) {
            streamGeometry(geometries[i], stream)
          }
        }
      }

      function streamLine(coordinates, stream, closed) {
        var i = -1,
          n = coordinates.length - closed,
          coordinate
        stream.lineStart()
        while (++i < n) {
          coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2])
        }
        stream.lineEnd()
      }

      function streamPolygon(coordinates, stream) {
        var i = -1,
          n = coordinates.length
        stream.polygonStart()
        while (++i < n) {
          streamLine(coordinates[i], stream, 1)
        }
        stream.polygonEnd()
      }
      /***/
    },
    /* 26 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (project, lobes) {
        var sphere, bounds

        function forward(lambda, phi) {
          var sign = phi < 0 ? -1 : +1,
            lobe = lobes[+(phi < 0)]
          for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) {}
          var p = project(lambda - lobe[i][1][0], phi)
          p[0] += project(lobe[i][1][0], sign * phi > sign * lobe[i][0][1] ? lobe[i][0][1] : phi)[0]
          return p
        }

        // Assumes mutually exclusive bounding boxes for lobes.
        if (project.invert) {
          forward.invert = function (x, y) {
            var bound = bounds[+(y < 0)],
              lobe = lobes[+(y < 0)]
            for (var i = 0, n = bound.length; i < n; ++i) {
              var b = bound[i]
              if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
                var p = project.invert(x - project(lobe[i][1][0], 0)[0], y)
                p[0] += lobe[i][1][0]
                return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null
              }
            }
          }
        }

        var p = (0, _d3Geo.geoProjection)(forward),
          stream_ = p.stream

        p.stream = function (stream) {
          var rotate = p.rotate(),
            rotateStream = stream_(stream),
            sphereStream = (p.rotate([0, 0]), stream_(stream))
          p.rotate(rotate)
          rotateStream.sphere = function () {
            (0, _d3Geo.geoStream)(sphere, sphereStream)
          }
          return rotateStream
        }

        p.lobes = function (_) {
          if (!arguments.length) {
            return lobes.map(function (lobe) {
              return lobe.map(function (l) {
                return [
                  [l[0][0] * _math.degrees, l[0][1] * _math.degrees],
                  [l[1][0] * _math.degrees, l[1][1] * _math.degrees],
                  [l[2][0] * _math.degrees, l[2][1] * _math.degrees]
                ]
              })
            })
          }

          sphere = interpolateSphere(_)

          lobes = _.map(function (lobe) {
            return lobe.map(function (l) {
              return [
                [l[0][0] * _math.radians, l[0][1] * _math.radians],
                [l[1][0] * _math.radians, l[1][1] * _math.radians],
                [l[2][0] * _math.radians, l[2][1] * _math.radians]
              ]
            })
          })

          bounds = lobes.map(function (lobe) {
            return lobe.map(function (l) {
              var x0 = project(l[0][0], l[0][1])[0],
                x1 = project(l[2][0], l[2][1])[0],
                y0 = project(l[1][0], l[0][1])[1],
                y1 = project(l[1][0], l[1][1])[1],
                t
              if (y0 > y1) t = y0, y0 = y1, y1 = t
              return [
                [x0, y0],
                [x1, y1]
              ]
            })
          })

          return p
        }

        if (lobes != null) p.lobes(lobes)

        return p
      }

      var _d3Array = __webpack_require__(14)

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function pointEqual(a, b) {
        return (0, _math.abs)(a[0] - b[0]) < _math.epsilon && (0, _math.abs)(a[1] - b[1]) < _math.epsilon
      }

      function interpolateLine(coordinates, m) {
        var i = -1,
          n = coordinates.length,
          p0 = coordinates[0],
          p1,
          dx,
          dy,
          resampled = []
        while (++i < n) {
          p1 = coordinates[i]
          dx = (p1[0] - p0[0]) / m
          dy = (p1[1] - p0[1]) / m
          for (var j = 0; j < m; ++j) {
            resampled.push([p0[0] + j * dx, p0[1] + j * dy])
          }
          p0 = p1
        }
        resampled.push(p1)
        return resampled
      }

      function interpolateSphere(lobes) {
        var coordinates = [],
          lobe,
          lambda0,
          phi0,
          phi1,
          lambda2,
          phi2,
          i,
          n = lobes[0].length

        // Northern Hemisphere
        for (i = 0; i < n; ++i) {
          lobe = lobes[0][i]
          lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1]
          lambda2 = lobe[2][0], phi2 = lobe[2][1]
          coordinates.push(interpolateLine([
            [lambda0 + _math.epsilon, phi0 + _math.epsilon],
            [lambda0 + _math.epsilon, phi1 - _math.epsilon],
            [lambda2 - _math.epsilon, phi1 - _math.epsilon],
            [lambda2 - _math.epsilon, phi2 + _math.epsilon]
          ], 30))
        }

        // Southern Hemisphere
        for (i = lobes[1].length - 1; i >= 0; --i) {
          lobe = lobes[1][i]
          lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1]
          lambda2 = lobe[2][0], phi2 = lobe[2][1]
          coordinates.push(interpolateLine([
            [lambda2 - _math.epsilon, phi2 - _math.epsilon],
            [lambda2 - _math.epsilon, phi1 + _math.epsilon],
            [lambda0 + _math.epsilon, phi1 + _math.epsilon],
            [lambda0 + _math.epsilon, phi0 - _math.epsilon]
          ], 30))
        }

        return {
          type: 'Polygon',
          coordinates: [(0, _d3Array.merge)(coordinates)]
        }
      }
      /***/
    },
    /* 27 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = noop

      function noop() {}
      /***/
    },
    /* 28 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
          streamObjectType[object.type](object, stream)
        } else {
          streamGeometry(object, stream)
        }
      }

      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream)
        }
      }

      var streamObjectType = {
        Feature: function Feature(feature, stream) {
          streamGeometry(feature.geometry, stream)
        },
        FeatureCollection: function FeatureCollection(object, stream) {
          var features = object.features,
            i = -1,
            n = features.length
          while (++i < n) {
            streamGeometry(features[i].geometry, stream)
          }
        }
      }

      var streamGeometryType = {
        Sphere: function Sphere(object, stream) {
          stream.sphere()
        },
        Point: function Point(object, stream) {
          object = object.coordinates
          stream.point(object[0], object[1], object[2])
        },
        MultiPoint: function MultiPoint(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            object = coordinates[i], stream.point(object[0], object[1], object[2])
          }
        },
        LineString: function LineString(object, stream) {
          streamLine(object.coordinates, stream, 0)
        },
        MultiLineString: function MultiLineString(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            streamLine(coordinates[i], stream, 0)
          }
        },
        Polygon: function Polygon(object, stream) {
          streamPolygon(object.coordinates, stream)
        },
        MultiPolygon: function MultiPolygon(object, stream) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            streamPolygon(coordinates[i], stream)
          }
        },
        GeometryCollection: function GeometryCollection(object, stream) {
          var geometries = object.geometries,
            i = -1,
            n = geometries.length
          while (++i < n) {
            streamGeometry(geometries[i], stream)
          }
        }
      }

      function streamLine(coordinates, stream, closed) {
        var i = -1,
          n = coordinates.length - closed,
          coordinate
        stream.lineStart()
        while (++i < n) {
          coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2])
        }
        stream.lineEnd()
      }

      function streamPolygon(coordinates, stream) {
        var i = -1,
          n = coordinates.length
        stream.polygonStart()
        while (++i < n) {
          streamLine(coordinates[i], stream, 1)
        }
        stream.polygonEnd()
      }
      /***/
    },
    /* 29 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _path = __webpack_require__(520)

      Object.defineProperty(exports, 'path', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_path).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 30 */
    /***/
    function (module, exports, __webpack_require__) {
      // # simple-statistics
      //
      // A simple, literate statistics system.

      var ss = module.exports = {}

      // Linear Regression
      ss.linearRegression = __webpack_require__(532)
      ss.linearRegressionLine = __webpack_require__(533)
      ss.standardDeviation = __webpack_require__(220)
      ss.rSquared = __webpack_require__(534)
      ss.mode = __webpack_require__(535)
      ss.modeFast = __webpack_require__(536)
      ss.modeSorted = __webpack_require__(224)
      ss.min = __webpack_require__(225)
      ss.max = __webpack_require__(226)
      ss.minSorted = __webpack_require__(537)
      ss.maxSorted = __webpack_require__(538)
      ss.sum = __webpack_require__(222)
      ss.sumSimple = __webpack_require__(539)
      ss.product = __webpack_require__(540)
      ss.quantile = __webpack_require__(115)
      ss.quantileSorted = __webpack_require__(116)
      ss.iqr = ss.interquartileRange = __webpack_require__(542)
      ss.medianAbsoluteDeviation = ss.mad = __webpack_require__(543)
      ss.chunk = __webpack_require__(544)
      ss.sampleWithReplacement = __webpack_require__(545)
      ss.shuffle = __webpack_require__(228)
      ss.shuffleInPlace = __webpack_require__(229)
      ss.sample = __webpack_require__(546)
      ss.ckmeans = __webpack_require__(547)
      ss.uniqueCountSorted = __webpack_require__(230)
      ss.sumNthPowerDeviations = __webpack_require__(114)
      ss.equalIntervalBreaks = __webpack_require__(548)

      // sample statistics
      ss.sampleCovariance = __webpack_require__(231)
      ss.sampleCorrelation = __webpack_require__(549)
      ss.sampleVariance = __webpack_require__(117)
      ss.sampleStandardDeviation = __webpack_require__(232)
      ss.sampleSkewness = __webpack_require__(550)
      ss.sampleKurtosis = __webpack_require__(551)

      // combinatorics
      ss.permutationsHeap = __webpack_require__(552)
      ss.combinations = __webpack_require__(553)
      ss.combinationsReplacement = __webpack_require__(554)

      // measures of centrality
      ss.addToMean = __webpack_require__(555)
      ss.combineMeans = __webpack_require__(233)
      ss.combineVariances = __webpack_require__(556)
      ss.geometricMean = __webpack_require__(557)
      ss.harmonicMean = __webpack_require__(558)
      ss.mean = ss.average = __webpack_require__(23)
      ss.median = __webpack_require__(227)
      ss.medianSorted = __webpack_require__(559)
      ss.subtractFromMean = __webpack_require__(560)

      ss.rootMeanSquare = ss.rms = __webpack_require__(561)
      ss.variance = __webpack_require__(221)
      ss.tTest = __webpack_require__(562)
      ss.tTestTwoSample = __webpack_require__(563)
      // ss.jenks = require('./src/jenks');

      // Classifiers
      ss.bayesian = __webpack_require__(564)
      ss.perceptron = __webpack_require__(565)

      // Distribution-related methods
      ss.epsilon = __webpack_require__(70) // We make  available to the test suite.
      ss.factorial = __webpack_require__(566)
      ss.bernoulliDistribution = __webpack_require__(567)
      ss.binomialDistribution = __webpack_require__(568)
      ss.poissonDistribution = __webpack_require__(569)
      ss.chiSquaredGoodnessOfFit = __webpack_require__(570)

      // Normal distribution
      ss.zScore = __webpack_require__(572)
      ss.cumulativeStdNormalProbability = __webpack_require__(573)
      ss.standardNormalTable = __webpack_require__(234)
      ss.errorFunction = ss.erf = __webpack_require__(574)
      ss.inverseErrorFunction = __webpack_require__(235)
      ss.probit = __webpack_require__(575)

      // Root-finding methods
      ss.bisect = __webpack_require__(576)
      /***/
    },
    /* 31 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return function constant() {
          return x
        }
      }
      /***/
    },
    /* 32 */
    /***/
    function (module, exports, __webpack_require__) {
      var root = __webpack_require__(13)

      /** Built-in value references. */
      var _Symbol = root.Symbol

      module.exports = _Symbol
      /***/
    },
    /* 33 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        return new Adder()
      }

      function Adder() {
        this.reset()
      } // Adds floating point numbers with twice the normal precision.
      // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
      // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
      // 305363 (1997).
      // Code adapted from GeographicLib by Charles F. F. Karney,
      // http://geographiclib.sourceforge.net/

      Adder.prototype = {
        constructor: Adder,
        reset: function reset() {
          this.s = // rounded value
            this.t = 0 // exact error
        },
        add: function add(y) {
          _add(temp, y, this.t)
          _add(this, temp.s, this.s)
          if (this.s) this.t += temp.t;
          else this.s = temp.t
        },
        valueOf: function valueOf() {
          return this.s
        }
      }

      var temp = new Adder()

      function _add(adder, a, b) {
        var x = adder.s = a + b,
          bv = x - a,
          av = x - bv
        adder.t = a - av + (b - bv)
      }
      /***/
    },
    /* 34 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
      }
      /***/
    },
    /* 35 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (projectAt) {
        var phi0 = 0,
          m = (0, _d3Geo.geoProjectionMutator)(projectAt),
          p = m(phi0)

        p.parallel = function (_) {
          return arguments.length ? m(phi0 = _ * _math.radians) : phi0 * _math.degrees
        }

        return p
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)
      /***/
    },
    /* 36 */
    /***/
    function (module, exports, __webpack_require__) {
      var assignValue = __webpack_require__(53),
        baseAssignValue = __webpack_require__(76)

      /**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */
      function copyObject(source, props, object, customizer) {
        var isNew = !object
        object || (object = {})

        var index = -1,
          length = props.length

        while (++index < length) {
          var key = props[index]

          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined

          if (newValue === undefined) {
            newValue = source[key]
          }
          if (isNew) {
            baseAssignValue(object, key, newValue)
          } else {
            assignValue(object, key, newValue)
          }
        }
        return object
      }

      module.exports = copyObject
      /***/
    },
    /* 37 */
    /***/
    function (module, exports) {
      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */
      function identity(value) {
        return value
      }

      module.exports = identity
      /***/
    },
    /* 38 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.spherical = spherical
      exports.cartesian = cartesian
      exports.cartesianDot = cartesianDot
      exports.cartesianCross = cartesianCross
      exports.cartesianAddInPlace = cartesianAddInPlace
      exports.cartesianScale = cartesianScale
      exports.cartesianNormalizeInPlace = cartesianNormalizeInPlace

      var _math = __webpack_require__(3)

      function spherical(cartesian) {
        return [(0, _math.atan2)(cartesian[1], cartesian[0]), (0, _math.asin)(cartesian[2])]
      }

      function cartesian(spherical) {
        var lambda = spherical[0],
          phi = spherical[1],
          cosPhi = (0, _math.cos)(phi)
        return [cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi)]
      }

      function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
      }

      function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
      }

      // TODO return a
      function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2]
      }

      function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k]
      }

      // TODO return d
      function cartesianNormalizeInPlace(d) {
        var l = (0, _math.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])
        d[0] /= l, d[1] /= l, d[2] /= l
      }
      /***/
    },
    /* 39 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return x === null ? NaN : +x
      }
      /***/
    },
    /* 40 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalRaw = azimuthalRaw
      exports.azimuthalInvert = azimuthalInvert

      var _math = __webpack_require__(3)

      function azimuthalRaw(scale) {
        return function (x, y) {
          var cx = (0, _math.cos)(x),
            cy = (0, _math.cos)(y),
            k = scale(cx * cy)
          return [k * cy * (0, _math.sin)(x), k * (0, _math.sin)(y)]
        }
      }

      function azimuthalInvert(angle) {
        return function (x, y) {
          var z = (0, _math.sqrt)(x * x + y * y),
            c = angle(z),
            sc = (0, _math.sin)(c),
            cc = (0, _math.cos)(c)
          return [(0, _math.atan2)(x * sc, z * cc), (0, _math.asin)(z && y * sc / z)]
        }
      }
      /***/
    },
    /* 41 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.sinusoidalRaw = sinusoidalRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(sinusoidalRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function sinusoidalRaw(lambda, phi) {
        return [lambda * (0, _math.cos)(phi), phi]
      }

      sinusoidalRaw.invert = function (x, y) {
        return [x / (0, _math.cos)(y), y]
      }
      /***/
    },
    /* 42 */
    /***/
    function (module, exports, __webpack_require__) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      function _possibleConstructorReturn(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
        }
        return call && (typeof call === 'object' || typeof call === 'function') ? call : self
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass)
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
      }

      var EventEmitter = __webpack_require__(180)
      var assign = __webpack_require__(5)
      var clone = __webpack_require__(181)
      var find = __webpack_require__(461)
      var forIn = __webpack_require__(11)
      var isMatch = __webpack_require__(486)
      var isObject = __webpack_require__(12)
      var isString = __webpack_require__(7)
      var keys = __webpack_require__(9)
      var pick = __webpack_require__(69)
      var cloneItems = __webpack_require__(107)

      var View = (function (_EventEmitter) {
        _inherits(View, _EventEmitter)

        // constructor
        function View(dataSet, options) {
          _classCallCheck(this, View)

          var _this = _possibleConstructorReturn(this, _EventEmitter.call(this))

          var me = _this
          options = options || {}
          dataSet = dataSet || {}
          if (!dataSet.isDataSet) {
            options = dataSet
            dataSet = null
          }
          assign(me, {
            dataSet: dataSet,
            loose: !dataSet,
            dataType: 'table',
            isView: true,
            isDataView: true, // alias
            origin: [],
            rows: [],
            transforms: [],
            watchingStates: null
          }, options)
          if (!me.loose) {
            var watchingStates = me.watchingStates

            dataSet.on('statechange', function (name) {
              if (Array.isArray(watchingStates)) {
                if (watchingStates.indexOf(name) > -1) {
                  me._reExecute()
                }
              } else {
                me._reExecute()
              }
            })
          }
          return _this
        }

        View.prototype._parseStateExpression = function _parseStateExpression(expr) {
          var dataSet = this.dataSet
          var matched = /^\$state\.(\w+)/.exec(expr)
          if (matched) {
            return dataSet.state[matched[1]]
          }
          return expr
        }

        View.prototype._preparseOptions = function _preparseOptions(options) {
          var me = this
          var optionsCloned = clone(options)
          if (me.loose) {
            return optionsCloned
          }
          forIn(optionsCloned, function (value, key) {
            if (isString(value) && /^\$state\./.test(value)) {
              optionsCloned[key] = me._parseStateExpression(value)
            }
          })
          return optionsCloned
        }

        // connectors

        View.prototype.source = function source(_source, options) {
          var me = this
          var DataSet = View.DataSet
          // warning me.origin is protected
          me._source = {
            source: _source,
            options: options
          }
          if (!options) {
            if (_source instanceof View || isString(_source)) {
              me.origin = DataSet.getConnector('default')(_source, me.dataSet)
            } else if (Array.isArray(_source)) {
              // TODO branch: if source is like ['dataview1', 'dataview2']
              me.origin = _source
            } else if (isObject(_source) && _source.type) {
              options = me._preparseOptions(_source) // connector without source
              me.origin = DataSet.getConnector(options.type)(options, me)
            } else {
              throw new TypeError('Invalid source')
            }
          } else {
            options = me._preparseOptions(options)
            me.origin = DataSet.getConnector(options.type)(_source, options, me)
          }
          if (!me.rows || me.rows.length !== me.origin.length) {
            // allow connectors to access 'rows'
            me.rows = cloneItems(me.origin)
          }
          return me
        }

        // transforms

        View.prototype.transform = function transform() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}

          var me = this
          me.transforms.push(options)
          me._executeTransform(options)
          return me
        }

        View.prototype._executeTransform = function _executeTransform(options) {
          var me = this
          options = me._preparseOptions(options)
          var transform = View.DataSet.getTransform(options.type)
          transform(me, options)
        }

        View.prototype._reExecuteTransforms = function _reExecuteTransforms() {
          var me = this
          me.transforms.forEach(function (options) {
            me._executeTransform(options)
          })
        }

        // rows

        View.prototype.addRow = function addRow(row) {
          this.rows.push(row)
        }

        View.prototype.removeRow = function removeRow(index) {
          this.rows.splice(index, 1)
        }

        View.prototype.updateRow = function updateRow(index, newRow) {
          assign(this.rows[index], newRow)
        }

        View.prototype.findRows = function findRows(query) {
          return this.rows.filter(function (row) {
            return isMatch(row, query)
          })
        }

        View.prototype.findRow = function findRow(query) {
          return find(this.rows, query)
        }

        // columns

        View.prototype.getColumnNames = function getColumnNames() {
          var firstRow = this.rows[0]
          if (firstRow) {
            return keys(firstRow)
          }
          return []
        }

        View.prototype.getColumnName = function getColumnName(index) {
          return this.getColumnNames()[index]
        }

        View.prototype.getColumnIndex = function getColumnIndex(columnName) {
          var columnNames = this.getColumnNames()
          return columnNames.indexOf(columnName)
        }

        View.prototype.getColumn = function getColumn(columnName) {
          return this.rows.map(function (row) {
            return row[columnName]
          })
        }

        View.prototype.getColumnData = function getColumnData(columnName) {
          return this.getColumn(columnName)
        }

        // data process

        View.prototype.getSubset = function getSubset(startRowIndex, endRowIndex, columnNames) {
          var subset = []
          for (var i = startRowIndex; i <= endRowIndex; i++) {
            subset.push(pick(this.rows[i], columnNames))
          }
          return subset
        }

        View.prototype.toString = function toString(prettyPrint) {
          var me = this
          if (prettyPrint) {
            return JSON.stringify(me.rows, null, 2)
          }
          return JSON.stringify(me.rows)
        }

        View.prototype._reExecute = function _reExecute() {
          var me = this
          var _me$_source = me._source,
            source = _me$_source.source,
            options = _me$_source.options

          me.source(source, options)
          me._reExecuteTransforms()
          me.trigger('change')
        }

        return View
      }(EventEmitter))

      module.exports = View
      /***/
    },
    /* 43 */
    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var baseGetTag = __webpack_require__(19),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var symbolTag = '[object Symbol]'

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag
      }

      module.exports = isSymbol
      /***/
    },
    /* 44 */
    /***/
    function (module, exports, __webpack_require__) {
      var isSymbol = __webpack_require__(43)

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0

      /**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */
      function toKey(value) {
        if (typeof value === 'string' || isSymbol(value)) {
          return value
        }
        var result = value + ''
        return result == '0' && 1 / value == -INFINITY ? '-0' : result
      }

      module.exports = toKey
      /***/
    },
    /* 45 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        return new Adder()
      }

      function Adder() {
        this.reset()
      } // Adds floating point numbers with twice the normal precision.
      // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
      // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
      // 305363 (1997).
      // Code adapted from GeographicLib by Charles F. F. Karney,
      // http://geographiclib.sourceforge.net/

      Adder.prototype = {
        constructor: Adder,
        reset: function reset() {
          this.s = // rounded value
            this.t = 0 // exact error
        },
        add: function add(y) {
          _add(temp, y, this.t)
          _add(this, temp.s, this.s)
          if (this.s) this.t += temp.t;
          else this.s = temp.t
        },
        valueOf: function valueOf() {
          return this.s
        }
      }

      var temp = new Adder()

      function _add(adder, a, b) {
        var x = adder.s = a + b,
          bv = x - a,
          av = x - bv
        adder.t = a - av + (b - bv)
      }
      /***/
    },
    /* 46 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.spherical = spherical
      exports.cartesian = cartesian
      exports.cartesianDot = cartesianDot
      exports.cartesianCross = cartesianCross
      exports.cartesianAddInPlace = cartesianAddInPlace
      exports.cartesianScale = cartesianScale
      exports.cartesianNormalizeInPlace = cartesianNormalizeInPlace

      var _math = __webpack_require__(4)

      function spherical(cartesian) {
        return [(0, _math.atan2)(cartesian[1], cartesian[0]), (0, _math.asin)(cartesian[2])]
      }

      function cartesian(spherical) {
        var lambda = spherical[0],
          phi = spherical[1],
          cosPhi = (0, _math.cos)(phi)
        return [cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi)]
      }

      function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
      }

      function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
      }

      // TODO return a
      function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2]
      }

      function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k]
      }

      // TODO return d
      function cartesianNormalizeInPlace(d) {
        var l = (0, _math.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])
        d[0] /= l, d[1] /= l, d[2] /= l
      }
      /***/
    },
    /* 47 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalRaw = azimuthalRaw
      exports.azimuthalInvert = azimuthalInvert

      var _math = __webpack_require__(4)

      function azimuthalRaw(scale) {
        return function (x, y) {
          var cx = (0, _math.cos)(x),
            cy = (0, _math.cos)(y),
            k = scale(cx * cy)
          return [k * cy * (0, _math.sin)(x), k * (0, _math.sin)(y)]
        }
      }

      function azimuthalInvert(angle) {
        return function (x, y) {
          var z = (0, _math.sqrt)(x * x + y * y),
            c = angle(z),
            sc = (0, _math.sin)(c),
            cc = (0, _math.cos)(c)
          return [(0, _math.atan2)(x * sc, z * cc), (0, _math.asin)(z && y * sc / z)]
        }
      }
      /***/
    },
    /* 48 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value

        while (++i < n) {
          node = nodes[i], node.y0 = y0, node.y1 = y1
          node.x0 = x0, node.x1 = x0 += node.value * k
        }
      }
      /***/
    },
    /* 49 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.acos = acos
      exports.asin = asin
      var abs = exports.abs = Math.abs
      var atan2 = exports.atan2 = Math.atan2
      var cos = exports.cos = Math.cos
      var max = exports.max = Math.max
      var min = exports.min = Math.min
      var sin = exports.sin = Math.sin
      var sqrt = exports.sqrt = Math.sqrt

      var epsilon = exports.epsilon = 1e-12
      var pi = exports.pi = Math.PI
      var halfPi = exports.halfPi = pi / 2
      var tau = exports.tau = 2 * pi

      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x)
      }

      function asin(x) {
        return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x)
      }
      /***/
    },
    /* 50 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (series, order) {
        if (!((n = series.length) > 1)) return
        for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
          s0 = s1, s1 = series[order[i]]
          for (j = 0; j < m; ++j) {
            s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1]
          }
        }
      }
      /***/
    },
    /* 51 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (series) {
        var n = series.length,
          o = new Array(n)
        while (--n >= 0) {
          o[n] = n
        }
        return o
      }
      /***/
    },
    /* 52 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.edges = exports.circles = exports.cells = exports.beaches = exports.epsilon2 = exports.epsilon = undefined
      exports.default = Diagram

      var _Beach = __webpack_require__(706)

      var _Cell = __webpack_require__(265)

      var _Circle = __webpack_require__(266)

      var _Edge = __webpack_require__(135)

      var _RedBlackTree = __webpack_require__(134)

      var _RedBlackTree2 = _interopRequireDefault(_RedBlackTree)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var epsilon = exports.epsilon = 1e-6
      var epsilon2 = exports.epsilon2 = 1e-12
      var beaches = exports.beaches = undefined
      var cells = exports.cells = undefined
      var circles = exports.circles = undefined
      var edges = exports.edges = undefined

      function triangleArea(a, b, c) {
        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])
      }

      function lexicographic(a, b) {
        return b[1] - a[1] || b[0] - a[0]
      }

      function Diagram(sites, extent) {
        var site = sites.sort(lexicographic).pop(),
          x,
          y,
          circle

        exports.edges = edges = []
        exports.cells = cells = new Array(sites.length)
        exports.beaches = beaches = new _RedBlackTree2.default()
        exports.circles = circles = new _RedBlackTree2.default()

        while (true) {
          circle = _Circle.firstCircle
          if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
            if (site[0] !== x || site[1] !== y) {
              (0, _Beach.addBeach)(site)
              x = site[0], y = site[1]
            }
            site = sites.pop()
          } else if (circle) {
            (0, _Beach.removeBeach)(circle.arc)
          } else {
            break
          }
        }

        (0, _Cell.sortCellHalfedges)()

        if (extent) {
          var x0 = +extent[0][0],
            y0 = +extent[0][1],
            x1 = +extent[1][0],
            y1 = +extent[1][1];
          (0, _Edge.clipEdges)(x0, y0, x1, y1);
          (0, _Cell.clipCells)(x0, y0, x1, y1)
        }

        this.edges = edges
        this.cells = cells

        exports.beaches = beaches = exports.circles = circles = exports.edges = edges = exports.cells = cells = null
      }

      Diagram.prototype = {
        constructor: Diagram,

        polygons: function polygons() {
          var edges = this.edges

          return this.cells.map(function (cell) {
            var polygon = cell.halfedges.map(function (i) {
              return (0, _Cell.cellHalfedgeStart)(cell, edges[i])
            })
            polygon.data = cell.site.data
            return polygon
          })
        },

        triangles: function triangles() {
          var triangles = [],
            edges = this.edges

          this.cells.forEach(function (cell, i) {
            if (!(m = (halfedges = cell.halfedges).length)) return
            var site = cell.site,
              halfedges,
              j = -1,
              m,
              s0,
              e1 = edges[halfedges[m - 1]],
              s1 = e1.left === site ? e1.right : e1.left

            while (++j < m) {
              s0 = s1
              e1 = edges[halfedges[j]]
              s1 = e1.left === site ? e1.right : e1.left
              if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                triangles.push([site.data, s0.data, s1.data])
              }
            }
          })

          return triangles
        },

        links: function links() {
          return this.edges.filter(function (edge) {
            return edge.right
          }).map(function (edge) {
            return {
              source: edge.left.data,
              target: edge.right.data
            }
          })
        },

        find: function find(x, y, radius) {
          var that = this,
            i0,
            i1 = that._found || 0,
            n = that.cells.length,
            cell

          // Use the previously-found cell, or start with an arbitrary one.
          while (!(cell = that.cells[i1])) {
            if (++i1 >= n) return null
          }
          var dx = x - cell.site[0],
            dy = y - cell.site[1],
            d2 = dx * dx + dy * dy

          // Traverse the half-edges to find a closer cell, if any.
          do {
            cell = that.cells[i0 = i1], i1 = null
            cell.halfedges.forEach(function (e) {
              var edge = that.edges[e],
                v = edge.left
              if ((v === cell.site || !v) && !(v = edge.right)) return
              var vx = x - v[0],
                vy = y - v[1],
                v2 = vx * vx + vy * vy
              if (v2 < d2) d2 = v2, i1 = v.index
            })
          } while (i1 !== null)

          that._found = i0

          return radius == null || d2 <= radius * radius ? cell.site : null
        }
      }
      /***/
    },
    /* 53 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseAssignValue = __webpack_require__(76),
        eq = __webpack_require__(54)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */
      function assignValue(object, key, value) {
        var objValue = object[key]
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
          baseAssignValue(object, key, value)
        }
      }

      module.exports = assignValue
      /***/
    },
    /* 54 */
    /***/
    function (module, exports) {
      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */
      function eq(value, other) {
        return value === other || value !== value && other !== other
      }

      module.exports = eq
      /***/
    },
    /* 55 */
    /***/
    function (module, exports) {
      /** Used as references for various `Number` constants. */
      var MAX_SAFE_INTEGER = 9007199254740991

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/

      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length
        return !!length && (typeof value === 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length
      }

      module.exports = isIndex
      /***/
    },
    /* 56 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */
      function isPrototype(value) {
        var Ctor = value && value.constructor,
          proto = typeof Ctor === 'function' && Ctor.prototype || objectProto

        return value === proto
      }

      module.exports = isPrototype
      /***/
    },
    /* 57 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.rotateRadians = rotateRadians

      exports.default = function (rotate) {
        rotate = rotateRadians(rotate[0] * _math.radians, rotate[1] * _math.radians, rotate.length > 2 ? rotate[2] * _math.radians : 0)

        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * _math.radians, coordinates[1] * _math.radians)
          return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates
        }

        forward.invert = function (coordinates) {
          coordinates = rotate.invert(coordinates[0] * _math.radians, coordinates[1] * _math.radians)
          return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates
        }

        return forward
      }

      var _compose = __webpack_require__(147)

      var _compose2 = _interopRequireDefault(_compose)

      var _math = __webpack_require__(3)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function rotationIdentity(lambda, phi) {
        return [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi]
      }

      rotationIdentity.invert = rotationIdentity

      function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= _math.tau) ? deltaPhi || deltaGamma ? (0, _compose2.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity
      }

      function forwardRotationLambda(deltaLambda) {
        return function (lambda, phi) {
          return lambda += deltaLambda, [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi]
        }
      }

      function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda)
        rotation.invert = forwardRotationLambda(-deltaLambda)
        return rotation
      }

      function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = (0, _math.cos)(deltaPhi),
          sinDeltaPhi = (0, _math.sin)(deltaPhi),
          cosDeltaGamma = (0, _math.cos)(deltaGamma),
          sinDeltaGamma = (0, _math.sin)(deltaGamma)

        function rotation(lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            x = (0, _math.cos)(lambda) * cosPhi,
            y = (0, _math.sin)(lambda) * cosPhi,
            z = (0, _math.sin)(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi
          return [(0, _math.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), (0, _math.asin)(k * cosDeltaGamma + y * sinDeltaGamma)]
        }

        rotation.invert = function (lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            x = (0, _math.cos)(lambda) * cosPhi,
            y = (0, _math.sin)(lambda) * cosPhi,
            z = (0, _math.sin)(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma
          return [(0, _math.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), (0, _math.asin)(k * cosDeltaPhi - x * sinDeltaPhi)]
        }

        return rotation
      }
      /***/
    },
    /* 58 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (methods) {
        return {
          stream: transformer(methods)
        }
      }

      exports.transformer = transformer

      function transformer(methods) {
        return function (stream) {
          var s = new TransformStream()
          for (var key in methods) {
            s[key] = methods[key]
          }
          s.stream = stream
          return s
        }
      }

      function TransformStream() {}

      TransformStream.prototype = {
        constructor: TransformStream,
        point: function point(x, y) {
          this.stream.point(x, y)
        },
        sphere: function sphere() {
          this.stream.sphere()
        },
        lineStart: function lineStart() {
          this.stream.lineStart()
        },
        lineEnd: function lineEnd() {
          this.stream.lineEnd()
        },
        polygonStart: function polygonStart() {
          this.stream.polygonStart()
        },
        polygonEnd: function polygonEnd() {
          this.stream.polygonEnd()
        }
      }
      /***/
    },
    /* 59 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b, c, d, e, f, g, h) {
        if (arguments.length < 8) h = 0

        function forward(lambda, phi) {
          if (!phi) return [a * lambda / _math.pi, 0]
          var phi2 = phi * phi,
            xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
            yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
            m = (xB * xB + yB * yB) / (2 * yB),
            alpha = lambda * (0, _math.asin)(xB / m) / _math.pi
          return [m * (0, _math.sin)(alpha), phi * (1 + phi2 * h) + m * (1 - (0, _math.cos)(alpha))]
        }

        forward.invert = function (x, y) {
          var lambda = _math.pi * x / a,
            phi = y,
            deltaLambda,
            deltaPhi,
            i = 50
          do {
            var phi2 = phi * phi,
              xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
              yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
              p = xB * xB + yB * yB,
              q = 2 * yB,
              m = p / q,
              m2 = m * m,
              dAlphadLambda = (0, _math.asin)(xB / m) / _math.pi,
              alpha = lambda * dAlphadLambda,
              xB2 = xB * xB,
              dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi,
              dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g),
              dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)),
              dqdPhi = 2 * (dyBdPhi - 1),
              dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q),
              cosAlpha = (0, _math.cos)(alpha),
              sinAlpha = (0, _math.sin)(alpha),
              mcosAlpha = m * cosAlpha,
              msinAlpha = m * sinAlpha,
              dAlphadPhi = lambda / _math.pi * (1 / (0, _math.sqrt)(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2,
              fx = msinAlpha - x,
              fy = phi * (1 + phi2 * h) + m - mcosAlpha - y,
              deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi,
              deltaxDeltaLambda = mcosAlpha * dAlphadLambda,
              deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi),
              deltayDeltaLambda = msinAlpha * dAlphadLambda,
              denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda
            if (!denominator) break
            lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator
            phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator
          } while (((0, _math.abs)(deltaLambda) > _math.epsilon || (0, _math.abs)(deltaPhi) > _math.epsilon) && --i > 0)
          return [lambda, phi]
        }

        return forward
      }

      var _math = __webpack_require__(1)
      /***/
    },
    /* 60 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (root, face, r) {
        r = r == null ? -_math.pi / 6 : r // TODO automate

        recurse(root, {
          transform: [(0, _math.cos)(r), (0, _math.sin)(r), 0, -(0, _math.sin)(r), (0, _math.cos)(r), 0]
        })

        function recurse(node, parent) {
          node.edges = faceEdges(node.face)
          // Find shared edge.
          if (parent.face) {
            var shared = node.shared = sharedEdge(node.face, parent.face),
              m = (0, _matrix2.default)(shared.map(parent.project), shared.map(node.project))
            node.transform = parent.transform ? (0, _matrix.multiply)(parent.transform, m) : m
            // Replace shared edge in parent edges array.
            var edges = parent.edges
            for (var i = 0, n = edges.length; i < n; ++i) {
              if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = node
              if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = node
            }
            edges = node.edges
            for (i = 0, n = edges.length; i < n; ++i) {
              if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = parent
              if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = parent
            }
          } else {
            node.transform = parent.transform
          }
          if (node.children) {
            node.children.forEach(function (child) {
              recurse(child, node)
            })
          }
          return node
        }

        function forward(lambda, phi) {
          var node = face(lambda, phi),
            point = node.project([lambda * _math.degrees, phi * _math.degrees]),
            t
          if (t = node.transform) {
            return [t[0] * point[0] + t[1] * point[1] + t[2], -(t[3] * point[0] + t[4] * point[1] + t[5])]
          }
          point[1] = -point[1]
          return point
        }

        // Naive inverse!  A faster solution would use bounding boxes, or even a
        // polygonal quadtree.
        if (hasInverse(root)) {
          forward.invert = function (x, y) {
            var coordinates = faceInvert(root, [x, -y])
            return coordinates && (coordinates[0] *= _math.radians, coordinates[1] *= _math.radians, coordinates)
          }
        }

        function faceInvert(node, coordinates) {
          var invert = node.project.invert,
            t = node.transform,
            point = coordinates
          if (t) {
            t = (0, _matrix.inverse)(t)
            point = [t[0] * point[0] + t[1] * point[1] + t[2], t[3] * point[0] + t[4] * point[1] + t[5]]
          }
          if (invert && node === faceDegrees(p = invert(point))) return p
          var p,
            children = node.children
          for (var i = 0, n = children && children.length; i < n; ++i) {
            if (p = faceInvert(children[i], coordinates)) return p
          }
        }

        function faceDegrees(coordinates) {
          return face(coordinates[0] * _math.radians, coordinates[1] * _math.radians)
        }

        var proj = (0, _d3Geo.geoProjection)(forward),
          stream_ = proj.stream

        proj.stream = function (stream) {
          var rotate = proj.rotate(),
            rotateStream = stream_(stream),
            sphereStream = (proj.rotate([0, 0]), stream_(stream))
          proj.rotate(rotate)
          rotateStream.sphere = function () {
            sphereStream.polygonStart()
            sphereStream.lineStart()
            outline(sphereStream, root)
            sphereStream.lineEnd()
            sphereStream.polygonEnd()
          }
          return rotateStream
        }

        return proj
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _matrix = __webpack_require__(386)

      var _matrix2 = _interopRequireDefault(_matrix)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function outline(stream, node, parent) {
        var point,
          edges = node.edges,
          n = edges.length,
          edge,
          multiPoint = {
            type: 'MultiPoint',
            coordinates: node.face
          },
          notPoles = node.face.filter(function (d) {
            return (0, _math.abs)(d[1]) !== 90
          }),
          b = (0, _d3Geo.geoBounds)({
            type: 'MultiPoint',
            coordinates: notPoles
          }),
          inside = false,
          j = -1,
          dx = b[1][0] - b[0][0]
        // TODO
        var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : (0, _d3Geo.geoCentroid)(multiPoint)
        // First find the shared edge
        if (parent) {
          while (++j < n) {
            if (edges[j] === parent) break
          }
        }
        ++j
        for (var i = 0; i < n; ++i) {
          edge = edges[(i + j) % n]
          if (Array.isArray(edge)) {
            if (!inside) {
              stream.point((point = (0, _d3Geo.geoInterpolate)(edge[0], c)(_math.epsilon))[0], point[1])
              inside = true
            }
            stream.point((point = (0, _d3Geo.geoInterpolate)(edge[1], c)(_math.epsilon))[0], point[1])
          } else {
            inside = false
            if (edge !== parent) outline(stream, edge, node)
          }
        }
      }

      // Tests equality of two spherical points.

      // Creates a polyhedral projection.
      //  * root: a spanning tree of polygon faces.  Nodes are automatically
      //    augmented with a transform matrix.
      //  * face: a function that returns the appropriate node for a given {lambda, phi}
      //    point (radians).
      //  * r: rotation angle for final polyhedral net.  Defaults to -pi / 6 (for
      //    butterflies).
      function pointEqual(a, b) {
        return a && b && a[0] === b[0] && a[1] === b[1]
      }

      // Finds a shared edge given two clockwise polygons.
      function sharedEdge(a, b) {
        var x,
          y,
          n = a.length,
          found = null
        for (var i = 0; i < n; ++i) {
          x = a[i]
          for (var j = b.length; --j >= 0;) {
            y = b[j]
            if (x[0] === y[0] && x[1] === y[1]) {
              if (found) return [found, x]
              found = x
            }
          }
        }
      }

      // Converts an array of n face vertices to an array of n + 1 edges.
      function faceEdges(face) {
        var n = face.length,
          edges = []
        for (var a = face[n - 1], i = 0; i < n; ++i) {
          edges.push([a, a = face[i]])
        }
        return edges
      }

      function hasInverse(node) {
        return node.project.invert || node.children && node.children.some(hasInverse)
      }
      /***/
    },
    /* 61 */
    /***/
    function (module, exports, __webpack_require__) {
      var listCacheClear = __webpack_require__(413),
        listCacheDelete = __webpack_require__(414),
        listCacheGet = __webpack_require__(415),
        listCacheHas = __webpack_require__(416),
        listCacheSet = __webpack_require__(417)

      /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function ListCache(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length

        this.clear()
        while (++index < length) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }

      // Add methods to `ListCache`.
      ListCache.prototype.clear = listCacheClear
      ListCache.prototype['delete'] = listCacheDelete
      ListCache.prototype.get = listCacheGet
      ListCache.prototype.has = listCacheHas
      ListCache.prototype.set = listCacheSet

      module.exports = ListCache
      /***/
    },
    /* 62 */
    /***/
    function (module, exports, __webpack_require__) {
      var eq = __webpack_require__(54)

      /**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function assocIndexOf(array, key) {
        var length = array.length
        while (length--) {
          if (eq(array[length][0], key)) {
            return length
          }
        }
        return -1
      }

      module.exports = assocIndexOf
      /***/
    },
    /* 63 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24)

      /* Built-in method references that are verified to be native. */
      var nativeCreate = getNative(Object, 'create')

      module.exports = nativeCreate
      /***/
    },
    /* 64 */
    /***/
    function (module, exports, __webpack_require__) {
      var isKeyable = __webpack_require__(431)

      /**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */
      function getMapData(map, key) {
        var data = map.__data__
        return isKeyable(key) ? data[typeof key === 'string' ? 'string' : 'hash'] : data.map
      }

      module.exports = getMapData
      /***/
    },
    /* 65 */
    /***/
    function (module, exports) {
      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
          result = Array(set.size)

        set.forEach(function (value) {
          result[++index] = value
        })
        return result
      }

      module.exports = setToArray
      /***/
    },
    /* 66 */
    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var baseMatches = __webpack_require__(463),
        baseMatchesProperty = __webpack_require__(470),
        identity = __webpack_require__(37),
        isArray = __webpack_require__(10),
        property = __webpack_require__(477)

      /**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */
      function baseIteratee(value) {
        // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
        // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
        if (typeof value === 'function') {
          return value
        }
        if (value == null) {
          return identity
        }
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value)
        }
        return property(value)
      }

      module.exports = baseIteratee
      /***/
    },
    /* 67 */
    /***/
    function (module, exports, __webpack_require__) {
      var isArray = __webpack_require__(10),
        isKey = __webpack_require__(105),
        stringToPath = __webpack_require__(472),
        toString = __webpack_require__(198)

      /**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */
      function castPath(value, object) {
        if (isArray(value)) {
          return value
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value))
      }

      module.exports = castPath
      /***/
    },
    /* 68 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length)

        while (++index < length) {
          result[index] = iteratee(array[index], index, array)
        }
        return result
      }

      module.exports = arrayMap
      /***/
    },
    /* 69 */
    /***/
    function (module, exports, __webpack_require__) {
      var basePick = __webpack_require__(487),
        flatRest = __webpack_require__(490)

      /**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */
      var pick = flatRest(function (object, paths) {
        return object == null ? {} : basePick(object, paths)
      })

      module.exports = pick
      /***/
    },
    /* 70 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * We use ``, epsilon, as a stopping criterion when we want to iterate
       * until we're "close enough". Epsilon is a very small number: for
       * simple statistics, that number is **0.0001**
       *
       * This is used in calculations like the binomialDistribution, in which
       * the process of finding a value is [iterative](https://en.wikipedia.org/wiki/Iterative_method):
       * it progresses until it is close enough.
       *
       * Below is an example of using epsilon in [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent),
       * where we're trying to find a local minimum of a function's derivative,
       * given by the `fDerivative` method.
       *
       * @example
       * // From calculation, we expect that the local minimum occurs at x=9/4
       * var x_old = 0;
       * // The algorithm starts at x=6
       * var x_new = 6;
       * var stepSize = 0.01;
       *
       * function fDerivative(x) {
       *   return 4 * Math.pow(x, 3) - 9 * Math.pow(x, 2);
       * }
       *
       * // The loop runs until the difference between the previous
       * // value and the current value is smaller than epsilon - a rough
       * // meaure of 'close enough'
       * while (Math.abs(x_new - x_old) > ss.epsilon) {
       *   x_old = x_new;
       *   x_new = x_old - stepSize * fDerivative(x_old);
       * }
       *
       * console.log('Local minimum occurs at', x_new);
       */
      var epsilon = 0.0001

      module.exports = epsilon
      /***/
    },
    /* 71 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value

        while (++i < n) {
          node = nodes[i], node.x0 = x0, node.x1 = x1
          node.y0 = y0, node.y1 = y0 += node.value * k
        }
      }
      /***/
    },
    /* 72 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (context) {
        return new Linear(context)
      }

      function Linear(context) {
        this._context = context
      }

      Linear.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2 // proceed
            default:
              this._context.lineTo(x, y);
              break
          }
        }
      }
      /***/
    },
    /* 73 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {}
      /***/
    },
    /* 74 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.Basis = Basis

      exports.default = function (context) {
        return new Basis(context)
      }

      function _point(that, x, y) {
        that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6)
      }

      exports.point = _point

      function Basis(context) {
        this._context = context
      }

      Basis.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 3:
              _point(this, this._x1, this._y1) // proceed
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3;
              this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6) // proceed
            default:
              _point(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = x
          this._y0 = this._y1, this._y1 = y
        }
      }
      /***/
    },
    /* 75 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.Cardinal = Cardinal

      function _point(that, x, y) {
        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2)
      }

      exports.point = _point

      function Cardinal(context, tension) {
        this._context = context
        this._k = (1 - tension) / 6
      }

      Cardinal.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break
            case 3:
              _point(this, this._x1, this._y1);
              break
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2;
              this._x1 = x, this._y1 = y;
              break
            case 2:
              this._point = 3 // proceed
            default:
              _point(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(tension) {
        function cardinal(context) {
          return new Cardinal(context, tension)
        }

        cardinal.tension = function (tension) {
          return custom(+tension)
        }

        return cardinal
      }(0))
      /***/
    },
    /* 76 */
    /***/
    function (module, exports, __webpack_require__) {
      var defineProperty = __webpack_require__(136)

      /**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */
      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && defineProperty) {
          defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          })
        } else {
          object[key] = value
        }
      }

      module.exports = baseAssignValue
      /***/
    },
    /* 77 */
    /***/
    function (module, exports, __webpack_require__) {
      var identity = __webpack_require__(37),
        overRest = __webpack_require__(139),
        setToString = __webpack_require__(140)

      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '')
      }

      module.exports = baseRest
      /***/
    },
    /* 78 */
    /***/
    function (module, exports) {
      /** Used as references for various `Number` constants. */
      var MAX_SAFE_INTEGER = 9007199254740991

      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */
      function isLength(value) {
        return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
      }

      module.exports = isLength
      /***/
    },
    /* 79 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsArguments = __webpack_require__(283),
        isObjectLike = __webpack_require__(15)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /** Built-in value references. */
      var propertyIsEnumerable = objectProto.propertyIsEnumerable

      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */
      var isArguments = baseIsArguments(function () {
        return arguments
      }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee')
      }

      module.exports = isArguments
      /***/
    },
    /* 80 */
    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (module) {
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
          return typeof obj
        } : function (obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
        }

        var root = __webpack_require__(13),
          stubFalse = __webpack_require__(284)

        /** Detect free variable `exports`. */
        var freeExports = (false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports

        /** Detect free variable `module`. */
        var freeModule = freeExports && (false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports

        /** Built-in value references. */
        var Buffer = moduleExports ? root.Buffer : undefined

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse

        module.exports = isBuffer
        /* WEBPACK VAR INJECTION */
      }.call(exports, __webpack_require__(81)(module)))
      /***/
    },
    /* 81 */
    /***/
    function (module, exports) {
      module.exports = function (module) {
        if (!module.webpackPolyfill) {
          module.deprecate = function () {}
          module.paths = []
          // module.parent = undefined by default
          if (!module.children) module.children = []
          Object.defineProperty(module, 'loaded', {
            enumerable: true,
            get: function get() {
              return module.l
            }
          })
          Object.defineProperty(module, 'id', {
            enumerable: true,
            get: function get() {
              return module.i
            }
          })
          module.webpackPolyfill = 1
        }
        return module
      }
      /***/
    },
    /* 82 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function (value) {
          return func(value)
        }
      }

      module.exports = baseUnary
      /***/
    },
    /* 83 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.clipExtent = clipExtent

      exports.default = function () {
        var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip

        return clip = {
          stream: function stream(_stream) {
            return cache && cacheStream === _stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = _stream)
          },
          extent: function extent(_) {
            return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [
              [x0, y0],
              [x1, y1]
            ]
          }
        }
      }

      var _math = __webpack_require__(3)

      var _buffer = __webpack_require__(148)

      var _buffer2 = _interopRequireDefault(_buffer)

      var _line = __webpack_require__(292)

      var _line2 = _interopRequireDefault(_line)

      var _polygon = __webpack_require__(149)

      var _polygon2 = _interopRequireDefault(_polygon)

      var _d3Array = __webpack_require__(14)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var clipMax = 1e9,
        clipMin = -clipMax

      // TODO Use d3-polygons polygonContains here for the ring check?
      // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

      function clipExtent(x0, y0, x1, y1) {
        function visible(x, y) {
          return x0 <= x && x <= x1 && y0 <= y && y <= y1
        }

        function interpolate(from, to, direction, stream) {
          var a = 0,
            a1 = 0
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
            do {
              stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0)
            } while ((a = (a + direction + 4) % 4) !== a1)
          } else {
            stream.point(to[0], to[1])
          }
        }

        function corner(p, direction) {
          return (0, _math.abs)(p[0] - x0) < _math.epsilon ? direction > 0 ? 0 : 3 : (0, _math.abs)(p[0] - x1) < _math.epsilon ? direction > 0 ? 2 : 1 : (0, _math.abs)(p[1] - y0) < _math.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2 // abs(p[1] - y1) < epsilon
        }

        function compareIntersection(a, b) {
          return comparePoint(a.x, b.x)
        }

        function comparePoint(a, b) {
          var ca = corner(a, 1),
            cb = corner(b, 1)
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0]
        }

        return function (stream) {
          var activeStream = stream,
            bufferStream = (0, _buffer2.default)(),
            segments,
            polygon,
            ring,
            x__,
            y__,
            v__,
            // first point
            x_,
            y_,
            v_,
            // previous point
            first,
            clean

          var clipStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: polygonStart,
            polygonEnd: polygonEnd
          }

          function point(x, y) {
            if (visible(x, y)) activeStream.point(x, y)
          }

          function polygonInside() {
            var winding = 0

            for (var i = 0, n = polygon.length; i < n; ++i) {
              for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
                a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1]
                if (a1 <= y1) {
                  if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding
                } else {
                  if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding
                }
              }
            }

            return winding
          }

          // Buffer geometry within a polygon and then clip it en masse.
          function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean = true
          }

          function polygonEnd() {
            var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = (0, _d3Array.merge)(segments)).length
            if (cleanInside || visible) {
              stream.polygonStart()
              if (cleanInside) {
                stream.lineStart()
                interpolate(null, null, 1, stream)
                stream.lineEnd()
              }
              if (visible) {
                (0, _polygon2.default)(segments, compareIntersection, startInside, interpolate, stream)
              }
              stream.polygonEnd()
            }
            activeStream = stream, segments = polygon = ring = null
          }

          function lineStart() {
            clipStream.point = linePoint
            if (polygon) polygon.push(ring = [])
            first = true
            v_ = false
            x_ = y_ = NaN
          }

          // TODO rather than special-case polygons, simply handle them separately.
          // Ideally, coincident intersection points should be jittered to avoid
          // clipping issues.
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__)
              if (v__ && v_) bufferStream.rejoin()
              segments.push(bufferStream.result())
            }
            clipStream.point = point
            if (v_) activeStream.lineEnd()
          }

          function linePoint(x, y) {
            var v = visible(x, y)
            if (polygon) ring.push([x, y])
            if (first) {
              x__ = x, y__ = y, v__ = v
              first = false
              if (v) {
                activeStream.lineStart()
                activeStream.point(x, y)
              }
            } else {
              if (v && v_) activeStream.point(x, y);
              else {
                var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))]
                if ((0, _line2.default)(a, b, x0, y0, x1, y1)) {
                  if (!v_) {
                    activeStream.lineStart()
                    activeStream.point(a[0], a[1])
                  }
                  activeStream.point(b[0], b[1])
                  if (!v) activeStream.lineEnd()
                  clean = false
                } else if (v) {
                  activeStream.lineStart()
                  activeStream.point(x, y)
                  clean = false
                }
              }
            }
            x_ = x, y_ = y, v_ = v
          }

          return clipStream
        }
      }
      /***/
    },
    /* 84 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, p, valueof) {
        if (valueof == null) valueof = _number2.default
        if (!(n = values.length)) return
        if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values)
        if (p >= 1) return +valueof(values[n - 1], n - 1, values)
        var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values)
        return value0 + (value1 - value0) * (i - i0)
      }

      var _number = __webpack_require__(39)

      var _number2 = _interopRequireDefault(_number)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 85 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return x
      }
      /***/
    },
    /* 86 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicEqualAreaRaw = conicEqualAreaRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicEqualAreaRaw).scale(155.424).center([0, 33.6442])
      }

      var _math = __webpack_require__(3)

      var _conic = __webpack_require__(87)

      var _cylindricalEqualArea = __webpack_require__(321)

      function conicEqualAreaRaw(y0, y1) {
        var sy0 = (0, _math.sin)(y0),
          n = (sy0 + (0, _math.sin)(y1)) / 2

        // Are the parallels symmetrical around the Equator?
        if ((0, _math.abs)(n) < _math.epsilon) return (0, _cylindricalEqualArea.cylindricalEqualAreaRaw)(y0)

        var c = 1 + sy0 * (2 * n - sy0),
          r0 = (0, _math.sqrt)(c) / n

        function project(x, y) {
          var r = (0, _math.sqrt)(c - 2 * n * (0, _math.sin)(y)) / n
          return [r * (0, _math.sin)(x *= n), r0 - r * (0, _math.cos)(x)]
        }

        project.invert = function (x, y) {
          var r0y = r0 - y
          return [(0, _math.atan2)(x, (0, _math.abs)(r0y)) / n * (0, _math.sign)(r0y), (0, _math.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))]
        }

        return project
      }
      /***/
    },
    /* 87 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicProjection = conicProjection

      var _math = __webpack_require__(3)

      var _index = __webpack_require__(16)

      function conicProjection(projectAt) {
        var phi0 = 0,
          phi1 = _math.pi / 3,
          m = (0, _index.projectionMutator)(projectAt),
          p = m(phi0, phi1)

        p.parallels = function (_) {
          return arguments.length ? m(phi0 = _[0] * _math.radians, phi1 = _[1] * _math.radians) : [phi0 * _math.degrees, phi1 * _math.degrees]
        }

        return p
      }
      /***/
    },
    /* 88 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.fitExtent = fitExtent
      exports.fitSize = fitSize

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      var _bounds = __webpack_require__(166)

      var _bounds2 = _interopRequireDefault(_bounds)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function fitExtent(projection, extent, object) {
        var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          clip = projection.clipExtent && projection.clipExtent()

        projection.scale(150).translate([0, 0])

        if (clip != null) projection.clipExtent(null);

        (0, _stream2.default)(object, projection.stream(_bounds2.default))

        var b = _bounds2.default.result(),
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2

        if (clip != null) projection.clipExtent(clip)

        return projection.scale(k * 150).translate([x, y])
      }

      function fitSize(projection, size, object) {
        return fitExtent(projection, [
          [0, 0], size
        ], object)
      }
      /***/
    },
    /* 89 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mercatorRaw = mercatorRaw

      exports.default = function () {
        return mercatorProjection(mercatorRaw).scale(961 / _math.tau)
      }

      exports.mercatorProjection = mercatorProjection

      var _math = __webpack_require__(3)

      var _rotation = __webpack_require__(57)

      var _rotation2 = _interopRequireDefault(_rotation)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function mercatorRaw(lambda, phi) {
        return [lambda, (0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2))]
      }

      mercatorRaw.invert = function (x, y) {
        return [x, 2 * (0, _math.atan)((0, _math.exp)(y)) - _math.halfPi]
      }

      function mercatorProjection(project) {
        var m = (0, _index2.default)(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null,
          y0,
          x1,
          y1 // clip extent

        m.scale = function (_) {
          return arguments.length ? (scale(_), reclip()) : scale()
        }

        m.translate = function (_) {
          return arguments.length ? (translate(_), reclip()) : translate()
        }

        m.center = function (_) {
          return arguments.length ? (center(_), reclip()) : center()
        }

        m.clipExtent = function (_) {
          return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [
            [x0, y0],
            [x1, y1]
          ]
        }

        function reclip() {
          var k = _math.pi * scale(),
            t = m((0, _rotation2.default)(m.rotate()).invert([0, 0]))
          return clipExtent(x0 == null ? [
            [t[0] - k, t[1] - k],
            [t[0] + k, t[1] + k]
          ] : project === mercatorRaw ? [
            [Math.max(t[0] - k, x0), y0],
            [Math.min(t[0] + k, x1), y1]
          ] : [
            [x0, Math.max(t[1] - k, y0)],
            [x1, Math.min(t[1] + k, y1)]
          ])
        }

        return reclip()
      }
      /***/
    },
    /* 90 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.collignonRaw = collignonRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(collignonRaw).scale(95.6464).center([0, 30])
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function collignonRaw(lambda, phi) {
        var alpha = (0, _math.sqrt)(1 - (0, _math.sin)(phi))
        return [2 / _math.sqrtPi * lambda * alpha, _math.sqrtPi * (1 - alpha)]
      }

      collignonRaw.invert = function (x, y) {
        var lambda = (lambda = y / _math.sqrtPi - 1) * lambda
        return [lambda > 0 ? x * (0, _math.sqrt)(_math.pi / lambda) / 2 : 0, (0, _math.asin)(1 - lambda)]
      }
      /***/
    },
    /* 91 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.sinuMollweideY = exports.sinuMollweidePhi = undefined
      exports.sinuMollweideRaw = sinuMollweideRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036])
      }

      var _d3Geo = __webpack_require__(0)

      var _mollweide = __webpack_require__(22)

      var _sinusoidal = __webpack_require__(41)

      var sinuMollweidePhi = exports.sinuMollweidePhi = 0.7109889596207567

      var sinuMollweideY = exports.sinuMollweideY = 0.0528035274542

      function sinuMollweideRaw(lambda, phi) {
        return phi > -sinuMollweidePhi ? (lambda = (0, _mollweide.mollweideRaw)(lambda, phi), lambda[1] += sinuMollweideY, lambda) : (0, _sinusoidal.sinusoidalRaw)(lambda, phi)
      }

      sinuMollweideRaw.invert = function (x, y) {
        return y > -sinuMollweidePhi ? _mollweide.mollweideRaw.invert(x, y - sinuMollweideY) : _sinusoidal.sinusoidalRaw.invert(x, y)
      }
      /***/
    },
    /* 92 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      // TODO generate on-the-fly to avoid external modification.
      var octahedron = [
        [0, 90],
        [-90, 0],
        [0, 0],
        [90, 0],
        [180, 0],
        [0, -90]
      ]

      exports.default = [
        [0, 2, 1],
        [0, 3, 2],
        [5, 1, 2],
        [5, 2, 3],
        [0, 1, 4],
        [0, 4, 3],
        [5, 4, 1],
        [5, 3, 4]
      ].map(function (face) {
        return face.map(function (i) {
          return octahedron[i]
        })
      })
      /***/
    },
    /* 93 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (project) {
        var dx = project(_math.halfPi, 0)[0] - project(-_math.halfPi, 0)[0]

        function projectQuincuncial(lambda, phi) {
          var t = (0, _math.abs)(lambda) < _math.halfPi,
            p = project(t ? lambda : lambda > 0 ? lambda - _math.pi : lambda + _math.pi, phi),
            x = (p[0] - p[1]) * _math.sqrt1_2,
            y = (p[0] + p[1]) * _math.sqrt1_2
          if (t) return [x, y]
          var d = dx * _math.sqrt1_2,
            s = x > 0 ^ y > 0 ? -1 : 1
          return [s * x - (0, _math.sign)(y) * d, s * y - (0, _math.sign)(x) * d]
        }

        if (project.invert) {
          projectQuincuncial.invert = function (x0, y0) {
            var x = (x0 + y0) * _math.sqrt1_2,
              y = (y0 - x0) * _math.sqrt1_2,
              t = (0, _math.abs)(x) < 0.5 * dx && (0, _math.abs)(y) < 0.5 * dx

            if (!t) {
              var d = dx * _math.sqrt1_2,
                s = x > 0 ^ y > 0 ? -1 : 1,
                x1 = -s * x0 + (y > 0 ? 1 : -1) * d,
                y1 = -s * y0 + (x > 0 ? 1 : -1) * d
              x = (-x1 - y1) * _math.sqrt1_2
              y = (x1 - y1) * _math.sqrt1_2
            }

            var p = project.invert(x, y)
            if (!t) p[0] += x > 0 ? _math.pi : -_math.pi
            return p
          }
        }

        return (0, _d3Geo.geoProjection)(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)
      /***/
    },
    /* 94 */
    /***/
    function (module, exports, __webpack_require__) {
      var ListCache = __webpack_require__(61),
        stackClear = __webpack_require__(418),
        stackDelete = __webpack_require__(419),
        stackGet = __webpack_require__(420),
        stackHas = __webpack_require__(421),
        stackSet = __webpack_require__(422)

      /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries)
        this.size = data.size
      }

      // Add methods to `Stack`.
      Stack.prototype.clear = stackClear
      Stack.prototype['delete'] = stackDelete
      Stack.prototype.get = stackGet
      Stack.prototype.has = stackHas
      Stack.prototype.set = stackSet

      module.exports = Stack
      /***/
    },
    /* 95 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24),
        root = __webpack_require__(13)

      /* Built-in method references that are verified to be native. */
      var Map = getNative(root, 'Map')

      module.exports = Map
      /***/
    },
    /* 96 */
    /***/
    function (module, exports, __webpack_require__) {
      var mapCacheClear = __webpack_require__(423),
        mapCacheDelete = __webpack_require__(430),
        mapCacheGet = __webpack_require__(432),
        mapCacheHas = __webpack_require__(433),
        mapCacheSet = __webpack_require__(434)

      /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function MapCache(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length

        this.clear()
        while (++index < length) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }

      // Add methods to `MapCache`.
      MapCache.prototype.clear = mapCacheClear
      MapCache.prototype['delete'] = mapCacheDelete
      MapCache.prototype.get = mapCacheGet
      MapCache.prototype.has = mapCacheHas
      MapCache.prototype.set = mapCacheSet

      module.exports = MapCache
      /***/
    },
    /* 97 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayLikeKeys = __webpack_require__(142),
        baseKeysIn = __webpack_require__(438),
        isArrayLike = __webpack_require__(20)

      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)
      }

      module.exports = keysIn
      /***/
    },
    /* 98 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayFilter = __webpack_require__(443),
        stubArray = __webpack_require__(183)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Built-in value references. */
      var propertyIsEnumerable = objectProto.propertyIsEnumerable

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeGetSymbols = Object.getOwnPropertySymbols

      /**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */
      var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
          return []
        }
        object = Object(object)
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
          return propertyIsEnumerable.call(object, symbol)
        })
      }

      module.exports = getSymbols
      /***/
    },
    /* 99 */
    /***/
    function (module, exports) {
      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
          length = values.length,
          offset = array.length

        while (++index < length) {
          array[offset + index] = values[index]
        }
        return array
      }

      module.exports = arrayPush
      /***/
    },
    /* 100 */
    /***/
    function (module, exports, __webpack_require__) {
      var overArg = __webpack_require__(144)

      /** Built-in value references. */
      var getPrototype = overArg(Object.getPrototypeOf, Object)

      module.exports = getPrototype
      /***/
    },
    /* 101 */
    /***/
    function (module, exports, __webpack_require__) {
      var Uint8Array = __webpack_require__(189)

      /**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength)
        new Uint8Array(result).set(new Uint8Array(arrayBuffer))
        return result
      }

      module.exports = cloneArrayBuffer
      /***/
    },
    /* 102 */
    /***/
    function (module, exports, __webpack_require__) {
      var MapCache = __webpack_require__(96),
        setCacheAdd = __webpack_require__(465),
        setCacheHas = __webpack_require__(466)

      /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */
      function SetCache(values) {
        var index = -1,
          length = values == null ? 0 : values.length

        this.__data__ = new MapCache()
        while (++index < length) {
          this.add(values[index])
        }
      }

      // Add methods to `SetCache`.
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd
      SetCache.prototype.has = setCacheHas

      module.exports = SetCache
      /***/
    },
    /* 103 */
    /***/
    function (module, exports) {
      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key)
      }

      module.exports = cacheHas
      /***/
    },
    /* 104 */
    /***/
    function (module, exports, __webpack_require__) {
      var castPath = __webpack_require__(67),
        toKey = __webpack_require__(44)

      /**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */
      function baseGet(object, path) {
        path = castPath(path, object)

        var index = 0,
          length = path.length

        while (object != null && index < length) {
          object = object[toKey(path[index++])]
        }
        return index && index == length ? object : undefined
      }

      module.exports = baseGet
      /***/
    },
    /* 105 */
    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var isArray = __webpack_require__(10),
        isSymbol = __webpack_require__(43)

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/

      /**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */
      function isKey(value, object) {
        if (isArray(value)) {
          return false
        }
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value)
        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
          return true
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object)
      }

      module.exports = isKey
      /***/
    },
    /* 106 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayPush = __webpack_require__(99),
        isFlattenable = __webpack_require__(492)

      /**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
          length = array.length

        predicate || (predicate = isFlattenable)
        result || (result = [])

        while (++index < length) {
          var value = array[index]
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              // Recursively flatten arrays (susceptible to call stack limits).
              baseFlatten(value, depth - 1, predicate, isStrict, result)
            } else {
              arrayPush(result, value)
            }
          } else if (!isStrict) {
            result[result.length] = value
          }
        }
        return result
      }

      module.exports = baseFlatten
      /***/
    },
    /* 107 */
    /***/
    function (module, exports, __webpack_require__) {
      var clone = __webpack_require__(181)
      var cloneDeep = __webpack_require__(493)

      module.exports = function (data) {
        if (Array.isArray(data)) {
          return data.map(function (item) {
            return clone(item)
          })
        }
        if ({}.toString.call(data) === '[object Object]') {
          var result = {}
          for (var key in data) {
            result[key] = data[key]
          }
          return result
        }
        return cloneDeep(data)
      }
      /***/
    },
    /* 108 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.rotateRadians = rotateRadians

      exports.default = function (rotate) {
        rotate = rotateRadians(rotate[0] * _math.radians, rotate[1] * _math.radians, rotate.length > 2 ? rotate[2] * _math.radians : 0)

        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * _math.radians, coordinates[1] * _math.radians)
          return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates
        }

        forward.invert = function (coordinates) {
          coordinates = rotate.invert(coordinates[0] * _math.radians, coordinates[1] * _math.radians)
          return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates
        }

        return forward
      }

      var _compose = __webpack_require__(207)

      var _compose2 = _interopRequireDefault(_compose)

      var _math = __webpack_require__(4)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function rotationIdentity(lambda, phi) {
        return [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi]
      }

      rotationIdentity.invert = rotationIdentity

      function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= _math.tau) ? deltaPhi || deltaGamma ? (0, _compose2.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity
      }

      function forwardRotationLambda(deltaLambda) {
        return function (lambda, phi) {
          return lambda += deltaLambda, [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi]
        }
      }

      function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda)
        rotation.invert = forwardRotationLambda(-deltaLambda)
        return rotation
      }

      function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = (0, _math.cos)(deltaPhi),
          sinDeltaPhi = (0, _math.sin)(deltaPhi),
          cosDeltaGamma = (0, _math.cos)(deltaGamma),
          sinDeltaGamma = (0, _math.sin)(deltaGamma)

        function rotation(lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            x = (0, _math.cos)(lambda) * cosPhi,
            y = (0, _math.sin)(lambda) * cosPhi,
            z = (0, _math.sin)(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi
          return [(0, _math.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), (0, _math.asin)(k * cosDeltaGamma + y * sinDeltaGamma)]
        }

        rotation.invert = function (lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            x = (0, _math.cos)(lambda) * cosPhi,
            y = (0, _math.sin)(lambda) * cosPhi,
            z = (0, _math.sin)(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma
          return [(0, _math.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), (0, _math.asin)(k * cosDeltaPhi - x * sinDeltaPhi)]
        }

        return rotation
      }
      /***/
    },
    /* 109 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicEqualAreaRaw = conicEqualAreaRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicEqualAreaRaw).scale(155.424).center([0, 33.6442])
      }

      var _math = __webpack_require__(4)

      var _conic = __webpack_require__(110)

      function conicEqualAreaRaw(y0, y1) {
        var sy0 = (0, _math.sin)(y0),
          n = (sy0 + (0, _math.sin)(y1)) / 2,
          c = 1 + sy0 * (2 * n - sy0),
          r0 = (0, _math.sqrt)(c) / n

        function project(x, y) {
          var r = (0, _math.sqrt)(c - 2 * n * (0, _math.sin)(y)) / n
          return [r * (0, _math.sin)(x *= n), r0 - r * (0, _math.cos)(x)]
        }

        project.invert = function (x, y) {
          var r0y = r0 - y
          return [(0, _math.atan2)(x, r0y) / n, (0, _math.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))]
        }

        return project
      }
      /***/
    },
    /* 110 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicProjection = conicProjection

      var _math = __webpack_require__(4)

      var _index = __webpack_require__(17)

      function conicProjection(projectAt) {
        var phi0 = 0,
          phi1 = _math.pi / 3,
          m = (0, _index.projectionMutator)(projectAt),
          p = m(phi0, phi1)

        p.parallels = function (_) {
          return arguments.length ? m(phi0 = _[0] * _math.radians, phi1 = _[1] * _math.radians) : [phi0 * _math.degrees, phi1 * _math.degrees]
        }

        return p
      }
      /***/
    },
    /* 111 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (prototype) {
        return {
          stream: transform(prototype)
        }
      }

      exports.transform = transform

      function transform(prototype) {
        function T() {}
        var p = T.prototype = Object.create(Transform.prototype)
        for (var k in prototype) {
          p[k] = prototype[k]
        }
        return function (stream) {
          var t = new T()
          t.stream = stream
          return t
        }
      }

      function Transform() {}

      Transform.prototype = {
        point: function point(x, y) {
          this.stream.point(x, y)
        },
        sphere: function sphere() {
          this.stream.sphere()
        },
        lineStart: function lineStart() {
          this.stream.lineStart()
        },
        lineEnd: function lineEnd() {
          this.stream.lineEnd()
        },
        polygonStart: function polygonStart() {
          this.stream.polygonStart()
        },
        polygonEnd: function polygonEnd() {
          this.stream.polygonEnd()
        }
      }
      /***/
    },
    /* 112 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mercatorRaw = mercatorRaw

      exports.default = function () {
        return mercatorProjection(mercatorRaw).scale(961 / _math.tau)
      }

      exports.mercatorProjection = mercatorProjection

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      var _math = __webpack_require__(4)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function mercatorRaw(lambda, phi) {
        return [lambda, (0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2))]
      }

      mercatorRaw.invert = function (x, y) {
        return [x, 2 * (0, _math.atan)((0, _math.exp)(y)) - _math.halfPi]
      }

      function mercatorProjection(project) {
        var m = (0, _index2.default)(project),
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          clipAuto

        m.scale = function (_) {
          return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale()
        }

        m.translate = function (_) {
          return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate()
        }

        m.clipExtent = function (_) {
          if (!arguments.length) return clipAuto ? null : clipExtent()
          if (clipAuto = _ == null) {
            var k = _math.pi * scale(),
              t = translate()
            _ = [
              [t[0] - k, t[1] - k],
              [t[0] + k, t[1] + k]
            ]
          }
          clipExtent(_)
          return m
        }

        return m.clipExtent(null)
      }
      /***/
    },
    /* 113 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseValues = __webpack_require__(523),
        keys = __webpack_require__(9)

      /**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object))
      }

      module.exports = values
      /***/
    },
    /* 114 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)

      /**
       * The sum of deviations to the Nth power.
       * When n=2 it's the sum of squared deviations.
       * When n=3 it's the sum of cubed deviations.
       *
       * @param {Array<number>} x
       * @param {number} n power
       * @returns {number} sum of nth power deviations
       * @example
       * var input = [1, 2, 3];
       * // since the variance of a set is the mean squared
       * // deviations, we can calculate that with sumNthPowerDeviations:
       * var variance = sumNthPowerDeviations(input) / input.length;
       */
      function sumNthPowerDeviations(x /*: Array<number> */ , n /*: number */ ) /*: number */ {
        var meanValue = mean(x),
          sum = 0,
          tempValue,
          i

        // This is an optimization: when n is 2 (we're computing a number squared),
        // multiplying the number by itself is significantly faster than using
        // the Math.pow method.
        if (n === 2) {
          for (i = 0; i < x.length; i++) {
            tempValue = x[i] - meanValue
            sum += tempValue * tempValue
          }
        } else {
          for (i = 0; i < x.length; i++) {
            sum += Math.pow(x[i] - meanValue, n)
          }
        }

        return sum
      }

      module.exports = sumNthPowerDeviations
      /***/
    },
    /* 115 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var quantileSorted = __webpack_require__(116)
      var quickselect = __webpack_require__(541)

      /**
       * The [quantile](https://en.wikipedia.org/wiki/Quantile):
       * this is a population quantile, since we assume to know the entire
       * dataset in this library. This is an implementation of the
       * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)
       * algorithm from wikipedia.
       *
       * Sample is a one-dimensional array of numbers,
       * and p is either a decimal number from 0 to 1 or an array of decimal
       * numbers from 0 to 1.
       * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing
       * with decimal values.
       * When p is an array, the result of the function is also an array containing the appropriate
       * quantiles in input order
       *
       * @param {Array<number>} x sample of one or more numbers
       * @param {number} p the desired quantile, as a number between 0 and 1
       * @returns {number} quantile
       * @example
       * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
       */
      function quantile(x /*: Array<number> */ , p /*: Array<number> | number */ ) {
        var copy = x.slice()

        if (Array.isArray(p)) {
          // rearrange elements so that each element corresponding to a requested
          // quantile is on a place it would be if the array was fully sorted
          multiQuantileSelect(copy, p)
          // Initialize the result array
          var results = []
          // For each requested quantile
          for (var i = 0; i < p.length; i++) {
            results[i] = quantileSorted(copy, p[i])
          }
          return results
        } else {
          var idx = quantileIndex(copy.length, p)
          quantileSelect(copy, idx, 0, copy.length - 1)
          return quantileSorted(copy, p)
        }
      }

      function quantileSelect(arr, k, left, right) {
        if (k % 1 === 0) {
          quickselect(arr, k, left, right)
        } else {
          k = Math.floor(k)
          quickselect(arr, k, left, right)
          quickselect(arr, k + 1, k + 1, right)
        }
      }

      function multiQuantileSelect(arr, p) {
        var indices = [0]
        for (var i = 0; i < p.length; i++) {
          indices.push(quantileIndex(arr.length, p[i]))
        }
        indices.push(arr.length - 1)
        indices.sort(compare)

        var stack = [0, indices.length - 1]

        while (stack.length) {
          var r = Math.ceil(stack.pop())
          var l = Math.floor(stack.pop())
          if (r - l <= 1) continue

          var m = Math.floor((l + r) / 2)
          quantileSelect(arr, indices[m], indices[l], indices[r])

          stack.push(l, m, m, r)
        }
      }

      function compare(a, b) {
        return a - b
      }

      function quantileIndex(len /*: number */ , p /*: number */ ) /*: number */ {
        var idx = len * p
        if (p === 1) {
          // If p is 1, directly return the last index
          return len - 1
        } else if (p === 0) {
          // If p is 0, directly return the first index
          return 0
        } else if (idx % 1 !== 0) {
          // If index is not integer, return the next index in array
          return Math.ceil(idx) - 1
        } else if (len % 2 === 0) {
          // If the list has even-length, we'll return the middle of two indices
          // around quantile to indicate that we need an average value of the two
          return idx - 0.5
        } else {
          // Finally, in the simple case of an integer index
          // with an odd-length list, return the index
          return idx
        }
      }

      module.exports = quantile
      /***/
    },
    /* 116 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * This is the internal implementation of quantiles: when you know
       * that the order is sorted, you don't need to re-sort it, and the computations
       * are faster.
       *
       * @param {Array<number>} x sample of one or more data points
       * @param {number} p desired quantile: a number between 0 to 1, inclusive
       * @returns {number} quantile value
       * @throws {Error} if p ix outside of the range from 0 to 1
       * @throws {Error} if x is empty
       * @example
       * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
       */
      function quantileSorted(x /*: Array<number> */ , p /*: number */ ) /*: number */ {
        var idx = x.length * p
        if (x.length === 0) {
          throw new Error('quantile requires at least one data point.')
        } else if (p < 0 || p > 1) {
          throw new Error('quantiles must be between 0 and 1')
        } else if (p === 1) {
          // If p is 1, directly return the last element
          return x[x.length - 1]
        } else if (p === 0) {
          // If p is 0, directly return the first element
          return x[0]
        } else if (idx % 1 !== 0) {
          // If p is not integer, return the next element in array
          return x[Math.ceil(idx) - 1]
        } else if (x.length % 2 === 0) {
          // If the list has even-length, we'll take the average of this number
          // and the next value, if there is one
          return (x[idx - 1] + x[idx]) / 2
        } else {
          // Finally, in the simple case of an integer value
          // with an odd-length list, return the x value at the index.
          return x[idx]
        }
      }

      module.exports = quantileSorted
      /***/
    },
    /* 117 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sumNthPowerDeviations = __webpack_require__(114)

      /**
       * The [sample variance](https://en.wikipedia.org/wiki/Variance#Sample_variance)
       * is the sum of squared deviations from the mean. The sample variance
       * is distinguished from the variance by the usage of [Bessel's Correction](https://en.wikipedia.org/wiki/Bessel's_correction):
       * instead of dividing the sum of squared deviations by the length of the input,
       * it is divided by the length minus one. This corrects the bias in estimating
       * a value from a set that you don't know if full.
       *
       * References:
       * * [Wolfram MathWorld on Sample Variance](http://mathworld.wolfram.com/SampleVariance.html)
       *
       * @param {Array<number>} x a sample of two or more data points
       * @throws {Error} if the length of x is less than 2
       * @return {number} sample variance
       * @example
       * sampleVariance([1, 2, 3, 4, 5]); // => 2.5
       */
      function sampleVariance(x /*: Array<number> */ ) /*: number */ {
        // The variance of no numbers is null
        if (x.length < 2) {
          throw new Error('sampleVariance requires at least two data points')
        }

        var sumSquaredDeviationsValue = sumNthPowerDeviations(x, 2)

        // this is Bessels' Correction: an adjustment made to sample statistics
        // that allows for the reduced degree of freedom entailed in calculating
        // values from samples rather than complete populations.
        var besselsCorrection = x.length - 1

        // Find the mean value of that list
        return sumSquaredDeviationsValue / besselsCorrection
      }

      module.exports = sampleVariance
      /***/
    },
    /* 118 */
    /***/
    function (module, exports) {
      /**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */
      function isNil(value) {
        return value == null
      }

      module.exports = isNil
      /***/
    },
    /* 119 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (delimiter) {
        var reFormat = new RegExp('["' + delimiter + '\n\r]'),
          delimiterCode = delimiter.charCodeAt(0)

        function parse(text, f) {
          var convert,
            columns,
            rows = parseRows(text, function (row, i) {
              if (convert) return convert(row, i - 1)
              columns = row, convert = f ? customConverter(row, f) : objectConverter(row)
            })
          rows.columns = columns
          return rows
        }

        function parseRows(text, f) {
          var EOL = {},
            // sentinel value for end-of-line
            EOF = {},
            // sentinel value for end-of-file
            rows = [],
            // output rows
            N = text.length,
            I = 0,
            // current character index
            n = 0,
            // the current line number
            t,
            // the current token
            eol // is the current token followed by EOL?

          function token() {
            if (I >= N) return EOF // special case: end of file
            if (eol) return eol = false, EOL // special case: end of line

            // special case: quotes
            var j = I,
              c
            if (text.charCodeAt(j) === 34) {
              var i = j
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34) break
                    ++i
                }
              }
              I = i + 2
              c = text.charCodeAt(i + 1)
              if (c === 13) {
                eol = true
                if (text.charCodeAt(i + 2) === 10) ++I
              } else if (c === 10) {
                eol = true
              }
              return text.slice(j + 1, i).replace(/""/g, '"')
            }

            // common case: find next delimiter or newline
            while (I < N) {
              var k = 1
              c = text.charCodeAt(I++)
              if (c === 10) eol = true // \n
              else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10) ++I, ++k
              } // \r|\r\n
              else if (c !== delimiterCode) continue
              return text.slice(j, I - k)
            }

            // special case: last token before EOF
            return text.slice(j)
          }

          while ((t = token()) !== EOF) {
            var a = []
            while (t !== EOL && t !== EOF) {
              a.push(t)
              t = token()
            }
            if (f && (a = f(a, n++)) == null) continue
            rows.push(a)
          }

          return rows
        }

        function format(rows, columns) {
          if (columns == null) columns = inferColumns(rows)
          return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
            return columns.map(function (column) {
              return formatValue(row[column])
            }).join(delimiter)
          })).join('\n')
        }

        function formatRows(rows) {
          return rows.map(formatRow).join('\n')
        }

        function formatRow(row) {
          return row.map(formatValue).join(delimiter)
        }

        function formatValue(text) {
          return text == null ? '' : reFormat.test(text += '') ? '"' + text.replace(/\"/g, '""') + '"' : text
        }

        return {
          parse: parse,
          parseRows: parseRows,
          format: format,
          formatRows: formatRows
        }
      }

      function objectConverter(columns) {
        return new Function('d', 'return {' + columns.map(function (name, i) {
          return JSON.stringify(name) + ': d[' + i + ']'
        }).join(',') + '}')
      }

      function customConverter(columns, f) {
        var object = objectConverter(columns)
        return function (row, i) {
          return f(object(row), i, columns)
        }
      }

      // Compute unique columns in order of discovery.
      function inferColumns(rows) {
        var columnSet = Object.create(null),
          columns = []

        rows.forEach(function (row) {
          for (var column in row) {
            if (!(column in columnSet)) {
              columns.push(columnSet[column] = column)
            }
          }
        })

        return columns
      }
      /***/
    },
    /* 120 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _cluster = __webpack_require__(591)

      Object.defineProperty(exports, 'cluster', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cluster).default
        }
      })

      var _index = __webpack_require__(121)

      Object.defineProperty(exports, 'hierarchy', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index).default
        }
      })

      var _index2 = __webpack_require__(603)

      Object.defineProperty(exports, 'pack', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index2).default
        }
      })

      var _siblings = __webpack_require__(239)

      Object.defineProperty(exports, 'packSiblings', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_siblings).default
        }
      })

      var _enclose = __webpack_require__(240)

      Object.defineProperty(exports, 'packEnclose', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_enclose).default
        }
      })

      var _partition = __webpack_require__(605)

      Object.defineProperty(exports, 'partition', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_partition).default
        }
      })

      var _stratify = __webpack_require__(606)

      Object.defineProperty(exports, 'stratify', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stratify).default
        }
      })

      var _tree = __webpack_require__(607)

      Object.defineProperty(exports, 'tree', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_tree).default
        }
      })

      var _index3 = __webpack_require__(608)

      Object.defineProperty(exports, 'treemap', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index3).default
        }
      })

      var _binary = __webpack_require__(609)

      Object.defineProperty(exports, 'treemapBinary', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_binary).default
        }
      })

      var _dice = __webpack_require__(48)

      Object.defineProperty(exports, 'treemapDice', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_dice).default
        }
      })

      var _slice = __webpack_require__(71)

      Object.defineProperty(exports, 'treemapSlice', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_slice).default
        }
      })

      var _sliceDice = __webpack_require__(610)

      Object.defineProperty(exports, 'treemapSliceDice', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sliceDice).default
        }
      })

      var _squarify = __webpack_require__(123)

      Object.defineProperty(exports, 'treemapSquarify', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_squarify).default
        }
      })

      var _resquarify = __webpack_require__(611)

      Object.defineProperty(exports, 'treemapResquarify', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_resquarify).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 121 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = hierarchy
      exports.computeHeight = computeHeight
      exports.Node = Node

      var _count = __webpack_require__(592)

      var _count2 = _interopRequireDefault(_count)

      var _each = __webpack_require__(593)

      var _each2 = _interopRequireDefault(_each)

      var _eachBefore = __webpack_require__(594)

      var _eachBefore2 = _interopRequireDefault(_eachBefore)

      var _eachAfter = __webpack_require__(595)

      var _eachAfter2 = _interopRequireDefault(_eachAfter)

      var _sum = __webpack_require__(596)

      var _sum2 = _interopRequireDefault(_sum)

      var _sort = __webpack_require__(597)

      var _sort2 = _interopRequireDefault(_sort)

      var _path = __webpack_require__(598)

      var _path2 = _interopRequireDefault(_path)

      var _ancestors = __webpack_require__(599)

      var _ancestors2 = _interopRequireDefault(_ancestors)

      var _descendants = __webpack_require__(600)

      var _descendants2 = _interopRequireDefault(_descendants)

      var _leaves = __webpack_require__(601)

      var _leaves2 = _interopRequireDefault(_leaves)

      var _links = __webpack_require__(602)

      var _links2 = _interopRequireDefault(_links)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function hierarchy(data, children) {
        var root = new Node(data),
          valued = +data.value && (root.value = data.value),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n

        if (children == null) children = defaultChildren

        while (node = nodes.pop()) {
          if (valued) node.value = +node.data.value
          if ((childs = children(node.data)) && (n = childs.length)) {
            node.children = new Array(n)
            for (i = n - 1; i >= 0; --i) {
              nodes.push(child = node.children[i] = new Node(childs[i]))
              child.parent = node
              child.depth = node.depth + 1
            }
          }
        }

        return root.eachBefore(computeHeight)
      }

      function node_copy() {
        return hierarchy(this).eachBefore(copyData)
      }

      function defaultChildren(d) {
        return d.children
      }

      function copyData(node) {
        node.data = node.data.data
      }

      function computeHeight(node) {
        var height = 0
        do {
          node.height = height
        } while ((node = node.parent) && node.height < ++height)
      }

      function Node(data) {
        this.data = data
        this.depth = this.height = 0
        this.parent = null
      }

      Node.prototype = hierarchy.prototype = {
        constructor: Node,
        count: _count2.default,
        each: _each2.default,
        eachAfter: _eachAfter2.default,
        eachBefore: _eachBefore2.default,
        sum: _sum2.default,
        sort: _sort2.default,
        path: _path2.default,
        ancestors: _ancestors2.default,
        descendants: _descendants2.default,
        leaves: _leaves2.default,
        links: _links2.default,
        copy: node_copy
      }
      /***/
    },
    /* 122 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.optional = optional
      exports.required = required

      function optional(f) {
        return f == null ? null : required(f)
      }

      function required(f) {
        if (typeof f !== 'function') throw new Error()
        return f
      }
      /***/
    },
    /* 123 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.phi = undefined
      exports.squarifyRatio = squarifyRatio

      var _dice = __webpack_require__(48)

      var _dice2 = _interopRequireDefault(_dice)

      var _slice = __webpack_require__(71)

      var _slice2 = _interopRequireDefault(_slice)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var phi = exports.phi = (1 + Math.sqrt(5)) / 2

      function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
        var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx,
          dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta

        while (i0 < n) {
          dx = x1 - x0, dy = y1 - y0

          // Find the next non-empty node.
          do {
            sumValue = nodes[i1++].value
          } while (!sumValue && i1 < n)
          minValue = maxValue = sumValue
          alpha = Math.max(dy / dx, dx / dy) / (value * ratio)
          beta = sumValue * sumValue * alpha
          minRatio = Math.max(maxValue / beta, beta / minValue)

          // Keep adding nodes while the aspect ratio maintains or improves.
          for (; i1 < n; ++i1) {
            sumValue += nodeValue = nodes[i1].value
            if (nodeValue < minValue) minValue = nodeValue
            if (nodeValue > maxValue) maxValue = nodeValue
            beta = sumValue * sumValue * alpha
            newRatio = Math.max(maxValue / beta, beta / minValue)
            if (newRatio > minRatio) {
              sumValue -= nodeValue;
              break
            }
            minRatio = newRatio
          }

          // Position and record the row orientation.
          rows.push(row = {
            value: sumValue,
            dice: dx < dy,
            children: nodes.slice(i0, i1)
          })
          if (row.dice)(0, _dice2.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
          else(0, _slice2.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1)
          value -= sumValue, i0 = i1
        }

        return rows
      }

      exports.default = (function custom(ratio) {
        function squarify(parent, x0, y0, x1, y1) {
          squarifyRatio(ratio, parent, x0, y0, x1, y1)
        }

        squarify.ratio = function (x) {
          return custom((x = +x) > 1 ? x : 1)
        }

        return squarify
      }(phi))
      /***/
    },
    /* 124 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (transform) {
        if (transform == null) return _identity2.default
        var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1]
        return function (input, i) {
          if (!i) x0 = y0 = 0
          var j = 2,
            n = input.length,
            output = new Array(n)
          output[0] = (x0 += input[0]) * kx + dx
          output[1] = (y0 += input[1]) * ky + dy
          while (j < n) {
            output[j] = input[j], ++j
          }
          return output
        }
      }

      var _identity = __webpack_require__(244)

      var _identity2 = _interopRequireDefault(_identity)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 125 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (topology, o) {
        return o.type === 'GeometryCollection' ? {
          type: 'FeatureCollection',
          features: o.geometries.map(function (o) {
            return feature(topology, o)
          })
        } : feature(topology, o)
      }

      exports.feature = feature
      exports.object = object

      var _reverse = __webpack_require__(614)

      var _reverse2 = _interopRequireDefault(_reverse)

      var _transform = __webpack_require__(124)

      var _transform2 = _interopRequireDefault(_transform)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function feature(topology, o) {
        var id = o.id,
          bbox = o.bbox,
          properties = o.properties == null ? {} : o.properties,
          geometry = object(topology, o)
        return id == null && bbox == null ? {
          type: 'Feature',
          properties: properties,
          geometry: geometry
        } : bbox == null ? {
          type: 'Feature',
          id: id,
          properties: properties,
          geometry: geometry
        } : {
          type: 'Feature',
          id: id,
          bbox: bbox,
          properties: properties,
          geometry: geometry
        }
      }

      function object(topology, o) {
        var transformPoint = (0, _transform2.default)(topology.transform),
          arcs = topology.arcs

        function arc(i, points) {
          if (points.length) points.pop()
          for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
            points.push(transformPoint(a[k], k))
          }
          if (i < 0)(0, _reverse2.default)(points, n)
        }

        function point(p) {
          return transformPoint(p)
        }

        function line(arcs) {
          var points = []
          for (var i = 0, n = arcs.length; i < n; ++i) {
            arc(arcs[i], points)
          }
          if (points.length < 2) points.push(points[0]) // This should never happen per the specification.
          return points
        }

        function ring(arcs) {
          var points = line(arcs)
          while (points.length < 4) {
            points.push(points[0])
          } // This may happen if an arc has only two points.
          return points
        }

        function polygon(arcs) {
          return arcs.map(ring)
        }

        function geometry(o) {
          var type = o.type,
            coordinates
          switch (type) {
            case 'GeometryCollection':
              return {
                type: type,
                geometries: o.geometries.map(geometry)
              }
            case 'Point':
              coordinates = point(o.coordinates);
              break
            case 'MultiPoint':
              coordinates = o.coordinates.map(point);
              break
            case 'LineString':
              coordinates = line(o.arcs);
              break
            case 'MultiLineString':
              coordinates = o.arcs.map(line);
              break
            case 'Polygon':
              coordinates = polygon(o.arcs);
              break
            case 'MultiPolygon':
              coordinates = o.arcs.map(polygon);
              break
            default:
              return null
          }
          return {
            type: type,
            coordinates: coordinates
          }
        }

        return geometry(o)
      }
      /***/
    },
    /* 126 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var numberTag = '[object Number]'

      /**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */
      function isNumber(value) {
        return typeof value === 'number' || isObjectLike(value) && baseGetTag(value) == numberTag
      }

      module.exports = isNumber
      /***/
    },
    /* 127 */
    /***/
    function (module, exports) {
      module.exports = function (extent) {
        var bandwidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1
        var min = extent[0],
          max = extent[1]

        var values = []
        var tmp = min
        while (tmp < max) {
          values.push(tmp)
          tmp += bandwidth
        }
        values.push(max)
        return values
      }
      /***/
    },
    /* 128 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(30),
        standardDeviation = _require.standardDeviation

      module.exports = {
        silverman: function silverman(arr) {
          var stdev = standardDeviation(arr)
          var num = 4 * Math.pow(stdev, 5)
          var denom = 3 * arr.length
          return Math.pow(num / denom, 0.2)
        }
      }
      /***/
    },
    /* 129 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var prefix = exports.prefix = '$'

      function Map() {}

      Map.prototype = map.prototype = {
        constructor: Map,
        has: function has(key) {
          return prefix + key in this
        },
        get: function get(key) {
          return this[prefix + key]
        },
        set: function set(key, value) {
          this[prefix + key] = value
          return this
        },
        remove: function remove(key) {
          var property = prefix + key
          return property in this && delete this[property]
        },
        clear: function clear() {
          for (var property in this) {
            if (property[0] === prefix) delete this[property]
          }
        },
        keys: function keys() {
          var keys = []
          for (var property in this) {
            if (property[0] === prefix) keys.push(property.slice(1))
          }
          return keys
        },
        values: function values() {
          var values = []
          for (var property in this) {
            if (property[0] === prefix) values.push(this[property])
          }
          return values
        },
        entries: function entries() {
          var entries = []
          for (var property in this) {
            if (property[0] === prefix) entries.push({
              key: property.slice(1),
              value: this[property]
            })
          }
          return entries
        },
        size: function size() {
          var size = 0
          for (var property in this) {
            if (property[0] === prefix) ++size
          }
          return size
        },
        empty: function empty() {
          for (var property in this) {
            if (property[0] === prefix) return false
          }
          return true
        },
        each: function each(f) {
          for (var property in this) {
            if (property[0] === prefix) f(this[property], property.slice(1), this)
          }
        }
      }

      function map(object, f) {
        var map = new Map()

        // Copy constructor.
        if (object instanceof Map) {
          object.each(function (value, key) {
            map.set(key, value)
          })
        }

        // Index array by numeric index or specified key function.
        else if (Array.isArray(object)) {
          var i = -1,
            n = object.length,
            o

          if (f == null) {
            while (++i < n) {
              map.set(i, object[i])
            }
          } else {
            while (++i < n) {
              map.set(f(o = object[i], i, object), o)
            }
          }
        }

        // Convert object to map.
        else if (object) {
          for (var key in object) {
            map.set(key, object[key])
          }
        }
        return map
      }

      exports.default = map
      /***/
    },
    /* 130 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var x = _point.x,
          y = _point.y,
          defined = (0, _constant2.default)(true),
          context = null,
          curve = _linear2.default,
          output = null

        function line(data) {
          var i,
            n = data.length,
            d,
            defined0 = false,
            buffer

          if (context == null) output = curve(buffer = (0, _d3Path.path)())

          for (i = 0; i <= n; ++i) {
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
              if (defined0 = !defined0) output.lineStart();
              else output.lineEnd()
            }
            if (defined0) output.point(+x(d, i, data), +y(d, i, data))
          }

          if (buffer) return output = null, buffer + '' || null
        }

        line.x = function (_) {
          return arguments.length ? (x = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), line) : x
        }

        line.y = function (_) {
          return arguments.length ? (y = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), line) : y
        }

        line.defined = function (_) {
          return arguments.length ? (defined = typeof _ === 'function' ? _ : (0, _constant2.default)(!!_), line) : defined
        }

        line.curve = function (_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve
        }

        line.context = function (_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context
        }

        return line
      }

      var _d3Path = __webpack_require__(29)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _linear = __webpack_require__(72)

      var _linear2 = _interopRequireDefault(_linear)

      var _point = __webpack_require__(131)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 131 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.x = x
      exports.y = y

      function x(p) {
        return p[0]
      }

      function y(p) {
        return p[1]
      }
      /***/
    },
    /* 132 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.point = undefined

      var _math = __webpack_require__(49)

      var _cardinal = __webpack_require__(75)

      function _point(that, x, y) {
        var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2

        if (that._l01_a > _math.epsilon) {
          var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a)
          x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n
          y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n
        }

        if (that._l23_a > _math.epsilon) {
          var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a)
          x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m
          y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m
        }

        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2)
      }

      exports.point = _point

      function CatmullRom(context, alpha) {
        this._context = context
        this._alpha = alpha
      }

      CatmullRom.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break
            case 3:
              this.point(this._x2, this._y2);
              break
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y

          if (this._point) {
            var x23 = this._x2 - x,
              y23 = this._y2 - y
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha))
          }

          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3 // proceed
            default:
              _point(this, x, y);
              break
          }

          this._l01_a = this._l12_a, this._l12_a = this._l23_a
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRom(context, alpha) : new _cardinal.Cardinal(context, 0)
        }

        catmullRom.alpha = function (alpha) {
          return custom(+alpha)
        }

        return catmullRom
      }(0.5))
      /***/
    },
    /* 133 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series) {
        var sums = series.map(sum)
        return (0, _none2.default)(series).sort(function (a, b) {
          return sums[a] - sums[b]
        })
      }

      exports.sum = sum

      var _none = __webpack_require__(51)

      var _none2 = _interopRequireDefault(_none)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function sum(series) {
        var s = 0,
          i = -1,
          n = series.length,
          v
        while (++i < n) {
          if (v = +series[i][1]) s += v
        }
        return s
      }
      /***/
    },
    /* 134 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.RedBlackNode = RedBlackNode

      function RedBlackTree() {
        this._ = null // root node
      }

      function RedBlackNode(node) {
        node.U = // parent node
          node.C = // color - true for red, false for black
          node.L = // left node
          node.R = // right node
          node.P = // previous node
          node.N = null // next node
      }

      RedBlackTree.prototype = {
        constructor: RedBlackTree,

        insert: function insert(after, node) {
          var parent, grandpa, uncle

          if (after) {
            node.P = after
            node.N = after.N
            if (after.N) after.N.P = node
            after.N = node
            if (after.R) {
              after = after.R
              while (after.L) {
                after = after.L
              }
              after.L = node
            } else {
              after.R = node
            }
            parent = after
          } else if (this._) {
            after = RedBlackFirst(this._)
            node.P = null
            node.N = after
            after.P = after.L = node
            parent = after
          } else {
            node.P = node.N = null
            this._ = node
            parent = null
          }
          node.L = node.R = null
          node.U = parent
          node.C = true

          after = node
          while (parent && parent.C) {
            grandpa = parent.U
            if (parent === grandpa.L) {
              uncle = grandpa.R
              if (uncle && uncle.C) {
                parent.C = uncle.C = false
                grandpa.C = true
                after = grandpa
              } else {
                if (after === parent.R) {
                  RedBlackRotateLeft(this, parent)
                  after = parent
                  parent = after.U
                }
                parent.C = false
                grandpa.C = true
                RedBlackRotateRight(this, grandpa)
              }
            } else {
              uncle = grandpa.L
              if (uncle && uncle.C) {
                parent.C = uncle.C = false
                grandpa.C = true
                after = grandpa
              } else {
                if (after === parent.L) {
                  RedBlackRotateRight(this, parent)
                  after = parent
                  parent = after.U
                }
                parent.C = false
                grandpa.C = true
                RedBlackRotateLeft(this, grandpa)
              }
            }
            parent = after.U
          }
          this._.C = false
        },

        remove: function remove(node) {
          if (node.N) node.N.P = node.P
          if (node.P) node.P.N = node.N
          node.N = node.P = null

          var parent = node.U,
            sibling,
            left = node.L,
            right = node.R,
            next,
            red

          if (!left) next = right;
          else if (!right) next = left;
          else next = RedBlackFirst(right)

          if (parent) {
            if (parent.L === node) parent.L = next;
            else parent.R = next
          } else {
            this._ = next
          }

          if (left && right) {
            red = next.C
            next.C = node.C
            next.L = left
            left.U = next
            if (next !== right) {
              parent = next.U
              next.U = node.U
              node = next.R
              parent.L = node
              next.R = right
              right.U = next
            } else {
              next.U = parent
              parent = next
              node = next.R
            }
          } else {
            red = node.C
            node = next
          }

          if (node) node.U = parent
          if (red) return
          if (node && node.C) {
            node.C = false;
            return
          }

          do {
            if (node === this._) break
            if (node === parent.L) {
              sibling = parent.R
              if (sibling.C) {
                sibling.C = false
                parent.C = true
                RedBlackRotateLeft(this, parent)
                sibling = parent.R
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false
                  sibling.C = true
                  RedBlackRotateRight(this, sibling)
                  sibling = parent.R
                }
                sibling.C = parent.C
                parent.C = sibling.R.C = false
                RedBlackRotateLeft(this, parent)
                node = this._
                break
              }
            } else {
              sibling = parent.L
              if (sibling.C) {
                sibling.C = false
                parent.C = true
                RedBlackRotateRight(this, parent)
                sibling = parent.L
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false
                  sibling.C = true
                  RedBlackRotateLeft(this, sibling)
                  sibling = parent.L
                }
                sibling.C = parent.C
                parent.C = sibling.L.C = false
                RedBlackRotateRight(this, parent)
                node = this._
                break
              }
            }
            sibling.C = true
            node = parent
            parent = parent.U
          } while (!node.C)

          if (node) node.C = false
        }
      }

      function RedBlackRotateLeft(tree, node) {
        var p = node,
          q = node.R,
          parent = p.U

        if (parent) {
          if (parent.L === p) parent.L = q;
          else parent.R = q
        } else {
          tree._ = q
        }

        q.U = parent
        p.U = q
        p.R = q.L
        if (p.R) p.R.U = p
        q.L = p
      }

      function RedBlackRotateRight(tree, node) {
        var p = node,
          q = node.L,
          parent = p.U

        if (parent) {
          if (parent.L === p) parent.L = q;
          else parent.R = q
        } else {
          tree._ = q
        }

        q.U = parent
        p.U = q
        p.L = q.R
        if (p.L) p.L.U = p
        q.R = p
      }

      function RedBlackFirst(node) {
        while (node.L) {
          node = node.L
        }
        return node
      }

      exports.default = RedBlackTree
      /***/
    },
    /* 135 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.createEdge = createEdge
      exports.createBorderEdge = createBorderEdge
      exports.setEdgeEnd = setEdgeEnd
      exports.clipEdges = clipEdges

      var _Diagram = __webpack_require__(52)

      function createEdge(left, right, v0, v1) {
        var edge = [null, null],
          index = _Diagram.edges.push(edge) - 1
        edge.left = left
        edge.right = right
        if (v0) setEdgeEnd(edge, left, right, v0)
        if (v1) setEdgeEnd(edge, right, left, v1)
        _Diagram.cells[left.index].halfedges.push(index)
        _Diagram.cells[right.index].halfedges.push(index)
        return edge
      }

      function createBorderEdge(left, v0, v1) {
        var edge = [v0, v1]
        edge.left = left
        return edge
      }

      function setEdgeEnd(edge, left, right, vertex) {
        if (!edge[0] && !edge[1]) {
          edge[0] = vertex
          edge.left = left
          edge.right = right
        } else if (edge.left === right) {
          edge[1] = vertex
        } else {
          edge[0] = vertex
        }
      }

      // LiangBarsky line clipping.
      function clipEdge(edge, x0, y0, x1, y1) {
        var a = edge[0],
          b = edge[1],
          ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r

        r = x0 - ax
        if (!dx && r > 0) return
        r /= dx
        if (dx < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dx > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = x1 - ax
        if (!dx && r < 0) return
        r /= dx
        if (dx < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dx > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        r = y0 - ay
        if (!dy && r > 0) return
        r /= dy
        if (dy < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dy > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = y1 - ay
        if (!dy && r < 0) return
        r /= dy
        if (dy < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dy > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        if (!(t0 > 0) && !(t1 < 1)) return true // TODO Better check?

        if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy]
        if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy]
        return true
      }

      function connectEdge(edge, x0, y0, x1, y1) {
        var v1 = edge[1]
        if (v1) return true

        var v0 = edge[0],
          left = edge.left,
          right = edge.right,
          lx = left[0],
          ly = left[1],
          rx = right[0],
          ry = right[1],
          fx = (lx + rx) / 2,
          fy = (ly + ry) / 2,
          fm,
          fb

        if (ry === ly) {
          if (fx < x0 || fx >= x1) return
          if (lx > rx) {
            if (!v0) v0 = [fx, y0];
            else if (v0[1] >= y1) return
            v1 = [fx, y1]
          } else {
            if (!v0) v0 = [fx, y1];
            else if (v0[1] < y0) return
            v1 = [fx, y0]
          }
        } else {
          fm = (lx - rx) / (ry - ly)
          fb = fy - fm * fx
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!v0) v0 = [(y0 - fb) / fm, y0];
              else if (v0[1] >= y1) return
              v1 = [(y1 - fb) / fm, y1]
            } else {
              if (!v0) v0 = [(y1 - fb) / fm, y1];
              else if (v0[1] < y0) return
              v1 = [(y0 - fb) / fm, y0]
            }
          } else {
            if (ly < ry) {
              if (!v0) v0 = [x0, fm * x0 + fb];
              else if (v0[0] >= x1) return
              v1 = [x1, fm * x1 + fb]
            } else {
              if (!v0) v0 = [x1, fm * x1 + fb];
              else if (v0[0] < x0) return
              v1 = [x0, fm * x0 + fb]
            }
          }
        }

        edge[0] = v0
        edge[1] = v1
        return true
      }

      function clipEdges(x0, y0, x1, y1) {
        var i = _Diagram.edges.length,
          edge

        while (i--) {
          if (!connectEdge(edge = _Diagram.edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > _Diagram.epsilon || Math.abs(edge[0][1] - edge[1][1]) > _Diagram.epsilon)) {
            delete _Diagram.edges[i]
          }
        }
      }
      /***/
    },
    /* 136 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24)

      var defineProperty = (function () {
        try {
          var func = getNative(Object, 'defineProperty')
          func({}, '', {})
          return func
        } catch (e) {}
      }())

      module.exports = defineProperty
      /***/
    },
    /* 137 */
    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global) {
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
          return typeof obj
        } : function (obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
        }

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global

        module.exports = freeGlobal
        /* WEBPACK VAR INJECTION */
      }.call(exports, __webpack_require__(271)))
      /***/
    },
    /* 138 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var funcProto = Function.prototype

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString

      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func)
          } catch (e) {}
          try {
            return func + ''
          } catch (e) {}
        }
        return ''
      }

      module.exports = toSource
      /***/
    },
    /* 139 */
    /***/
    function (module, exports, __webpack_require__) {
      var apply = __webpack_require__(278)

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max

      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */
      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0)
        return function () {
          var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length)

          while (++index < length) {
            array[index] = args[start + index]
          }
          index = -1
          var otherArgs = Array(start + 1)
          while (++index < start) {
            otherArgs[index] = args[index]
          }
          otherArgs[start] = transform(array)
          return apply(func, this, otherArgs)
        }
      }

      module.exports = overRest
      /***/
    },
    /* 140 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseSetToString = __webpack_require__(279),
        shortOut = __webpack_require__(281)

      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var setToString = shortOut(baseSetToString)

      module.exports = setToString
      /***/
    },
    /* 141 */
    /***/
    function (module, exports, __webpack_require__) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var eq = __webpack_require__(54),
        isArrayLike = __webpack_require__(20),
        isIndex = __webpack_require__(55),
        isObject = __webpack_require__(12)

      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false
        }
        var type = typeof index === 'undefined' ? 'undefined' : _typeof(index)
        if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
          return eq(object[index], value)
        }
        return false
      }

      module.exports = isIterateeCall
      /***/
    },
    /* 142 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseTimes = __webpack_require__(282),
        isArguments = __webpack_require__(79),
        isArray = __webpack_require__(10),
        isBuffer = __webpack_require__(80),
        isIndex = __webpack_require__(55),
        isTypedArray = __webpack_require__(143)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
              // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' ||
              // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') ||
              // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
              // Skip index properties.
              isIndex(key, length)))) {
            result.push(key)
          }
        }
        return result
      }

      module.exports = arrayLikeKeys
      /***/
    },
    /* 143 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsTypedArray = __webpack_require__(285),
        baseUnary = __webpack_require__(82),
        nodeUtil = __webpack_require__(286)

      /* Node.js helper references. */
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray

      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray

      module.exports = isTypedArray
      /***/
    },
    /* 144 */
    /***/
    function (module, exports) {
      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg))
        }
      }

      module.exports = overArg
      /***/
    },
    /* 145 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.areaStream = exports.areaRingSum = undefined

      exports.default = function (object) {
        areaSum.reset();
        (0, _stream2.default)(object, areaStream)
        return areaSum * 2
      }

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var areaRingSum = exports.areaRingSum = (0, _adder2.default)()

      var areaSum = (0, _adder2.default)(),
        lambda00,
        phi00,
        lambda0,
        cosPhi0,
        sinPhi0

      var areaStream = exports.areaStream = {
        point: _noop2.default,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: function polygonStart() {
          areaRingSum.reset()
          areaStream.lineStart = areaRingStart
          areaStream.lineEnd = areaRingEnd
        },
        polygonEnd: function polygonEnd() {
          var areaRing = +areaRingSum
          areaSum.add(areaRing < 0 ? _math.tau + areaRing : areaRing)
          this.lineStart = this.lineEnd = this.point = _noop2.default
        },
        sphere: function sphere() {
          areaSum.add(_math.tau)
        }
      }

      function areaRingStart() {
        areaStream.point = areaPointFirst
      }

      function areaRingEnd() {
        areaPoint(lambda00, phi00)
      }

      function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint
        lambda00 = lambda, phi00 = phi
        lambda *= _math.radians, phi *= _math.radians
        lambda0 = lambda, cosPhi0 = (0, _math.cos)(phi = phi / 2 + _math.quarterPi), sinPhi0 = (0, _math.sin)(phi)
      }

      function areaPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        phi = phi / 2 + _math.quarterPi // half the angular distance from south pole

        // Spherical excess E for a spherical triangle with vertices: south pole,
        // previous point, current point.  Uses a formula derived from Cagnolis
        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
        var dLambda = lambda - lambda0,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = (0, _math.cos)(phi),
          sinPhi = (0, _math.sin)(phi),
          k = sinPhi0 * sinPhi,
          u = cosPhi0 * cosPhi + k * (0, _math.cos)(adLambda),
          v = k * sdLambda * (0, _math.sin)(adLambda)
        areaRingSum.add((0, _math.atan2)(v, u))

        // Advance the previous points.
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi
      }
      /***/
    },
    /* 146 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.circleStream = circleStream

      exports.default = function () {
        var center = (0, _constant2.default)([0, 0]),
          radius = (0, _constant2.default)(90),
          precision = (0, _constant2.default)(6),
          ring,
          rotate,
          stream = {
            point: point
          }

        function point(x, y) {
          ring.push(x = rotate(x, y))
          x[0] *= _math.degrees, x[1] *= _math.degrees
        }

        function circle() {
          var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * _math.radians,
            p = precision.apply(this, arguments) * _math.radians
          ring = []
          rotate = (0, _rotation.rotateRadians)(-c[0] * _math.radians, -c[1] * _math.radians, 0).invert
          circleStream(stream, r, p, 1)
          c = {
            type: 'Polygon',
            coordinates: [ring]
          }
          ring = rotate = null
          return c
        }

        circle.center = function (_) {
          return arguments.length ? (center = typeof _ === 'function' ? _ : (0, _constant2.default)([+_[0], +_[1]]), circle) : center
        }

        circle.radius = function (_) {
          return arguments.length ? (radius = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), circle) : radius
        }

        circle.precision = function (_) {
          return arguments.length ? (precision = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), circle) : precision
        }

        return circle
      }

      var _cartesian = __webpack_require__(38)

      var _constant = __webpack_require__(291)

      var _constant2 = _interopRequireDefault(_constant)

      var _math = __webpack_require__(3)

      var _rotation = __webpack_require__(57)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      // Generates a circle centered at [0, 0], with a given radius and precision.
      function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta) return
        var cosRadius = (0, _math.cos)(radius),
          sinRadius = (0, _math.sin)(radius),
          step = direction * delta
        if (t0 == null) {
          t0 = radius + direction * _math.tau
          t1 = radius - step / 2
        } else {
          t0 = circleRadius(cosRadius, t0)
          t1 = circleRadius(cosRadius, t1)
          if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math.tau
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
          point = (0, _cartesian.spherical)([cosRadius, -sinRadius * (0, _math.cos)(t), -sinRadius * (0, _math.sin)(t)])
          stream.point(point[0], point[1])
        }
      }

      // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
      function circleRadius(cosRadius, point) {
        point = (0, _cartesian.cartesian)(point), point[0] -= cosRadius;
        (0, _cartesian.cartesianNormalizeInPlace)(point)
        var radius = (0, _math.acos)(-point[1])
        return ((-point[2] < 0 ? -radius : radius) + _math.tau - _math.epsilon) % _math.tau
      }
      /***/
    },
    /* 147 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1])
        }

        if (a.invert && b.invert) {
          compose.invert = function (x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1])
          }
        }

        return compose
      }
      /***/
    },
    /* 148 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var lines = [],
          line
        return {
          point: function point(x, y) {
            line.push([x, y])
          },
          lineStart: function lineStart() {
            lines.push(line = [])
          },
          lineEnd: _noop2.default,
          rejoin: function rejoin() {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()))
          },
          result: function result() {
            var result = lines
            lines = []
            line = null
            return result
          }
        }
      }

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 149 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (segments, compareIntersection, startInside, interpolate, stream) {
        var subject = [],
          clip = [],
          i,
          n

        segments.forEach(function (segment) {
          if ((n = segment.length - 1) <= 0) return
          var n,
            p0 = segment[0],
            p1 = segment[n],
            x

          // If the first and last points of a segment are coincident, then treat as a
          // closed ring. TODO if all rings are closed, then the winding order of the
          // exterior ring should be checked.
          if ((0, _pointEqual2.default)(p0, p1)) {
            stream.lineStart()
            for (i = 0; i < n; ++i) {
              stream.point((p0 = segment[i])[0], p0[1])
            }
            stream.lineEnd()
            return
          }

          subject.push(x = new Intersection(p0, segment, null, true))
          clip.push(x.o = new Intersection(p0, null, x, false))
          subject.push(x = new Intersection(p1, segment, null, false))
          clip.push(x.o = new Intersection(p1, null, x, true))
        })

        if (!subject.length) return

        clip.sort(compareIntersection)
        link(subject)
        link(clip)

        for (i = 0, n = clip.length; i < n; ++i) {
          clip[i].e = startInside = !startInside
        }

        var start = subject[0],
          points,
          point

        while (1) {
          // Find first unvisited intersection.
          var current = start,
            isSubject = true
          while (current.v) {
            if ((current = current.n) === start) return
          }
          points = current.z
          stream.lineStart()
          do {
            current.v = current.o.v = true
            if (current.e) {
              if (isSubject) {
                for (i = 0, n = points.length; i < n; ++i) {
                  stream.point((point = points[i])[0], point[1])
                }
              } else {
                interpolate(current.x, current.n.x, 1, stream)
              }
              current = current.n
            } else {
              if (isSubject) {
                points = current.p.z
                for (i = points.length - 1; i >= 0; --i) {
                  stream.point((point = points[i])[0], point[1])
                }
              } else {
                interpolate(current.x, current.p.x, -1, stream)
              }
              current = current.p
            }
            current = current.o
            points = current.z
            isSubject = !isSubject
          } while (!current.v)
          stream.lineEnd()
        }
      }

      var _pointEqual = __webpack_require__(150)

      var _pointEqual2 = _interopRequireDefault(_pointEqual)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function Intersection(point, points, other, entry) {
        this.x = point
        this.z = points
        this.o = other // another intersection
        this.e = entry // is an entry?
        this.v = false // visited
        this.n = this.p = null // next & previous
      }

      // A generalized polygon clipping algorithm: given a polygon that has been cut
      // into its visible line segments, and rejoins the segments by interpolating
      // along the clip edge.

      function link(array) {
        if (!(n = array.length)) return
        var n,
          i = 0,
          a = array[0],
          b
        while (++i < n) {
          a.n = b = array[i]
          b.p = a
          a = b
        }
        a.n = b = array[0]
        b.p = a
      }
      /***/
    },
    /* 150 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        return (0, _math.abs)(a[0] - b[0]) < _math.epsilon && (0, _math.abs)(a[1] - b[1]) < _math.epsilon
      }

      var _math = __webpack_require__(3)
      /***/
    },
    /* 151 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.bisectLeft = exports.bisectRight = undefined

      var _ascending = __webpack_require__(34)

      var _ascending2 = _interopRequireDefault(_ascending)

      var _bisector = __webpack_require__(152)

      var _bisector2 = _interopRequireDefault(_bisector)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var ascendingBisect = (0, _bisector2.default)(_ascending2.default)
      var bisectRight = exports.bisectRight = ascendingBisect.right
      var bisectLeft = exports.bisectLeft = ascendingBisect.left
      exports.default = bisectRight
      /***/
    },
    /* 152 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (compare) {
        if (compare.length === 1) compare = ascendingComparator(compare)
        return {
          left: function left(a, x, lo, hi) {
            if (lo == null) lo = 0
            if (hi == null) hi = a.length
            while (lo < hi) {
              var mid = lo + hi >>> 1
              if (compare(a[mid], x) < 0) lo = mid + 1;
              else hi = mid
            }
            return lo
          },
          right: function right(a, x, lo, hi) {
            if (lo == null) lo = 0
            if (hi == null) hi = a.length
            while (lo < hi) {
              var mid = lo + hi >>> 1
              if (compare(a[mid], x) > 0) hi = mid;
              else lo = mid + 1
            }
            return lo
          }
        }
      }

      var _ascending = __webpack_require__(34)

      var _ascending2 = _interopRequireDefault(_ascending)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function ascendingComparator(f) {
        return function (d, x) {
          return (0, _ascending2.default)(f(d), x)
        }
      }
      /***/
    },
    /* 153 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (array, f) {
        if (f == null) f = pair
        var i = 0,
          n = array.length - 1,
          p = array[0],
          pairs = new Array(n < 0 ? 0 : n)
        while (i < n) {
          pairs[i] = f(p, p = array[++i])
        }
        return pairs
      }

      exports.pair = pair

      function pair(a, b) {
        return [a, b]
      }
      /***/
    },
    /* 154 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (array, f) {
        var v = (0, _variance2.default)(array, f)
        return v ? Math.sqrt(v) : v
      }

      var _variance = __webpack_require__(155)

      var _variance2 = _interopRequireDefault(_variance)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 155 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          m = 0,
          i = -1,
          mean = 0,
          value,
          delta,
          sum = 0

        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(values[i]))) {
              delta = value - mean
              mean += delta / ++m
              sum += delta * (value - mean)
            }
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(valueof(values[i], i, values)))) {
              delta = value - mean
              mean += delta / ++m
              sum += delta * (value - mean)
            }
          }
        }

        if (m > 1) return sum / (m - 1)
      }

      var _number = __webpack_require__(39)

      var _number2 = _interopRequireDefault(_number)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 156 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          i = -1,
          value,
          min,
          max

        if (valueof == null) {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = values[i]) != null && value >= value) {
              min = max = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = values[i]) != null) {
                  if (min > value) min = value
                  if (max < value) max = value
                }
              }
            }
          }
        } else {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              min = max = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = valueof(values[i], i, values)) != null) {
                  if (min > value) min = value
                  if (max < value) max = value
                }
              }
            }
          }
        }

        return [min, max]
      }
      /***/
    },
    /* 157 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var array = Array.prototype

      var slice = exports.slice = array.slice
      var map = exports.map = array.map
      /***/
    },
    /* 158 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step

        var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n)

        while (++i < n) {
          range[i] = start + i * step
        }

        return range
      }
      /***/
    },
    /* 159 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (start, stop, count) {
        var reverse = stop < start,
          i = -1,
          n,
          ticks,
          step

        if (reverse) n = start, start = stop, stop = n

        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return []

        if (step > 0) {
          start = Math.ceil(start / step)
          stop = Math.floor(stop / step)
          ticks = new Array(n = Math.ceil(stop - start + 1))
          while (++i < n) {
            ticks[i] = (start + i) * step
          }
        } else {
          start = Math.floor(start * step)
          stop = Math.ceil(stop * step)
          ticks = new Array(n = Math.ceil(start - stop + 1))
          while (++i < n) {
            ticks[i] = (start - i) / step
          }
        }

        if (reverse) ticks.reverse()

        return ticks
      }

      exports.tickIncrement = tickIncrement
      exports.tickStep = tickStep
      var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2)

      function tickIncrement(start, stop, count) {
        var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power)
        return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1)
      }

      function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1
        if (error >= e10) step1 *= 10;
        else if (error >= e5) step1 *= 5;
        else if (error >= e2) step1 *= 2
        return stop < start ? -step1 : step1
      }
      /***/
    },
    /* 160 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (values) {
        return Math.ceil(Math.log(values.length) / Math.LN2) + 1
      }
      /***/
    },
    /* 161 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          i = -1,
          value,
          min

        if (valueof == null) {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = values[i]) != null && value >= value) {
              min = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = values[i]) != null && min > value) {
                  min = value
                }
              }
            }
          }
        } else {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              min = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = valueof(values[i], i, values)) != null && min > value) {
                  min = value
                }
              }
            }
          }
        }

        return min
      }
      /***/
    },
    /* 162 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (matrix) {
        if (!(n = matrix.length)) return []
        for (var i = -1, m = (0, _min2.default)(matrix, length), transpose = new Array(m); ++i < m;) {
          for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
            row[j] = matrix[j][i]
          }
        }
        return transpose
      }

      var _min = __webpack_require__(161)

      var _min2 = _interopRequireDefault(_min)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function length(d) {
        return d.length
      }
      /***/
    },
    /* 163 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (polygon, point) {
        var lambda = point[0],
          phi = point[1],
          normal = [(0, _math.sin)(lambda), -(0, _math.cos)(lambda), 0],
          angle = 0,
          winding = 0

        sum.reset()

        for (var i = 0, n = polygon.length; i < n; ++i) {
          if (!(m = (ring = polygon[i]).length)) continue
          var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = point0[0],
            phi0 = point0[1] / 2 + _math.quarterPi,
            sinPhi0 = (0, _math.sin)(phi0),
            cosPhi0 = (0, _math.cos)(phi0)

          for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
            var point1 = ring[j],
              lambda1 = point1[0],
              phi1 = point1[1] / 2 + _math.quarterPi,
              sinPhi1 = (0, _math.sin)(phi1),
              cosPhi1 = (0, _math.cos)(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > _math.pi,
              k = sinPhi0 * sinPhi1

            sum.add((0, _math.atan2)(k * sign * (0, _math.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0, _math.cos)(absDelta)))
            angle += antimeridian ? delta + sign * _math.tau : delta

            // Are the longitudes either side of the points meridian (lambda),
            // and are the latitudes smaller than the parallel (phi)?
            if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
              var arc = (0, _cartesian.cartesianCross)((0, _cartesian.cartesian)(point0), (0, _cartesian.cartesian)(point1));
              (0, _cartesian.cartesianNormalizeInPlace)(arc)
              var intersection = (0, _cartesian.cartesianCross)(normal, arc);
              (0, _cartesian.cartesianNormalizeInPlace)(intersection)
              var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0, _math.asin)(intersection[2])
              if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                winding += antimeridian ^ delta >= 0 ? 1 : -1
              }
            }
          }
        }

        // First, determine whether the South pole is inside or outside:
        //
        // It is inside if:
        // * the polygon winds around it in a clockwise direction.
        // * the polygon does not (cumulatively) wind around it, but has a negative
        //   (counter-clockwise) area.
        //
        // Second, count the (signed) number of times a segment crosses a lambda
        // from the point to the South pole.  If it is zero, then the point is the
        // same side as the South pole.

        return (angle < -_math.epsilon || angle < _math.epsilon && sum < -_math.epsilon) ^ winding & 1
      }

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _cartesian = __webpack_require__(38)

      var _math = __webpack_require__(3)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var sum = (0, _adder2.default)()
      /***/
    },
    /* 164 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        coordinates[0] = a
        coordinates[1] = b
        return (0, _length2.default)(object)
      }

      var _length = __webpack_require__(165)

      var _length2 = _interopRequireDefault(_length)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var coordinates = [null, null],
        object = {
          type: 'LineString',
          coordinates: coordinates
        }
      /***/
    },
    /* 165 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object) {
        lengthSum.reset();
        (0, _stream2.default)(object, lengthStream)
        return +lengthSum
      }

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lengthSum = (0, _adder2.default)(),
        lambda0,
        sinPhi0,
        cosPhi0

      var lengthStream = {
        sphere: _noop2.default,
        point: _noop2.default,
        lineStart: lengthLineStart,
        lineEnd: _noop2.default,
        polygonStart: _noop2.default,
        polygonEnd: _noop2.default
      }

      function lengthLineStart() {
        lengthStream.point = lengthPointFirst
        lengthStream.lineEnd = lengthLineEnd
      }

      function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = _noop2.default
      }

      function lengthPointFirst(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        lambda0 = lambda, sinPhi0 = (0, _math.sin)(phi), cosPhi0 = (0, _math.cos)(phi)
        lengthStream.point = lengthPoint
      }

      function lengthPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var sinPhi = (0, _math.sin)(phi),
          cosPhi = (0, _math.cos)(phi),
          delta = (0, _math.abs)(lambda - lambda0),
          cosDelta = (0, _math.cos)(delta),
          sinDelta = (0, _math.sin)(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta
        lengthSum.add((0, _math.atan2)((0, _math.sqrt)(x * x + y * y), z))
        lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi
      }
      /***/
    },
    /* 166 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var x0 = Infinity,
        y0 = x0,
        x1 = -x0,
        y1 = x1

      var boundsStream = {
        point: boundsPoint,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: _noop2.default,
        polygonEnd: _noop2.default,
        result: function result() {
          var bounds = [
            [x0, y0],
            [x1, y1]
          ]
          x1 = y1 = -(y0 = x0 = Infinity)
          return bounds
        }
      }

      function boundsPoint(x, y) {
        if (x < x0) x0 = x
        if (x > x1) x1 = x
        if (y < y0) y0 = y
        if (y > y1) y1 = y
      }

      exports.default = boundsStream
      /***/
    },
    /* 167 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _conicEqualArea2.default)().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7])
      }

      var _conicEqualArea = __webpack_require__(86)

      var _conicEqualArea2 = _interopRequireDefault(_conicEqualArea)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 168 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (pointVisible, clipLine, interpolate, start) {
        return function (rotate, sink) {
          var line = clipLine(sink),
            rotatedStart = rotate.invert(start[0], start[1]),
            ringBuffer = (0, _buffer2.default)(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring

          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function polygonStart() {
              clip.point = pointRing
              clip.lineStart = ringStart
              clip.lineEnd = ringEnd
              segments = []
              polygon = []
            },
            polygonEnd: function polygonEnd() {
              clip.point = point
              clip.lineStart = lineStart
              clip.lineEnd = lineEnd
              segments = (0, _d3Array.merge)(segments)
              var startInside = (0, _polygonContains2.default)(polygon, rotatedStart)
              if (segments.length) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                (0, _polygon2.default)(segments, compareIntersection, startInside, interpolate, sink)
              } else if (startInside) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true
                sink.lineStart()
                interpolate(null, null, 1, sink)
                sink.lineEnd()
              }
              if (polygonStarted) sink.polygonEnd(), polygonStarted = false
              segments = polygon = null
            },
            sphere: function sphere() {
              sink.polygonStart()
              sink.lineStart()
              interpolate(null, null, 1, sink)
              sink.lineEnd()
              sink.polygonEnd()
            }
          }

          function point(lambda, phi) {
            var point = rotate(lambda, phi)
            if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi)
          }

          function pointLine(lambda, phi) {
            var point = rotate(lambda, phi)
            line.point(point[0], point[1])
          }

          function lineStart() {
            clip.point = pointLine
            line.lineStart()
          }

          function lineEnd() {
            clip.point = point
            line.lineEnd()
          }

          function pointRing(lambda, phi) {
            ring.push([lambda, phi])
            var point = rotate(lambda, phi)
            ringSink.point(point[0], point[1])
          }

          function ringStart() {
            ringSink.lineStart()
            ring = []
          }

          function ringEnd() {
            pointRing(ring[0][0], ring[0][1])
            ringSink.lineEnd()

            var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i,
              n = ringSegments.length,
              m,
              segment,
              point

            ring.pop()
            polygon.push(ring)
            ring = null

            if (!n) return

            // No intersections.
            if (clean & 1) {
              segment = ringSegments[0]
              if ((m = segment.length - 1) > 0) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true
                sink.lineStart()
                for (i = 0; i < m; ++i) {
                  sink.point((point = segment[i])[0], point[1])
                }
                sink.lineEnd()
              }
              return
            }

            // Rejoin connected segments.
            // TODO reuse ringBuffer.rejoin()?
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()))

            segments.push(ringSegments.filter(validSegment))
          }

          return clip
        }
      }

      var _buffer = __webpack_require__(148)

      var _buffer2 = _interopRequireDefault(_buffer)

      var _polygon = __webpack_require__(149)

      var _polygon2 = _interopRequireDefault(_polygon)

      var _math = __webpack_require__(3)

      var _polygonContains = __webpack_require__(163)

      var _polygonContains2 = _interopRequireDefault(_polygonContains)

      var _d3Array = __webpack_require__(14)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function validSegment(segment) {
        return segment.length > 1
      }

      // Intersections are sorted along the clip edge. For both antimeridian cutting
      // and circle clipping, the same comparison is used.
      function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - _math.halfPi - _math.epsilon : _math.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math.halfPi - _math.epsilon : _math.halfPi - b[1])
      }
      /***/
    },
    /* 169 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.equirectangularRaw = equirectangularRaw

      exports.default = function () {
        return (0, _index2.default)(equirectangularRaw).scale(152.63)
      }

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function equirectangularRaw(lambda, phi) {
        return [lambda, phi]
      }

      equirectangularRaw.invert = equirectangularRaw
      /***/
    },
    /* 170 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _airy = __webpack_require__(332)

      Object.defineProperty(exports, 'geoAiry', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_airy).default
        }
      })
      Object.defineProperty(exports, 'geoAiryRaw', {
        enumerable: true,
        get: function get() {
          return _airy.airyRaw
        }
      })

      var _aitoff = __webpack_require__(171)

      Object.defineProperty(exports, 'geoAitoff', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_aitoff).default
        }
      })
      Object.defineProperty(exports, 'geoAitoffRaw', {
        enumerable: true,
        get: function get() {
          return _aitoff.aitoffRaw
        }
      })

      var _armadillo = __webpack_require__(333)

      Object.defineProperty(exports, 'geoArmadillo', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_armadillo).default
        }
      })
      Object.defineProperty(exports, 'geoArmadilloRaw', {
        enumerable: true,
        get: function get() {
          return _armadillo.armadilloRaw
        }
      })

      var _august = __webpack_require__(172)

      Object.defineProperty(exports, 'geoAugust', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_august).default
        }
      })
      Object.defineProperty(exports, 'geoAugustRaw', {
        enumerable: true,
        get: function get() {
          return _august.augustRaw
        }
      })

      var _baker = __webpack_require__(334)

      Object.defineProperty(exports, 'geoBaker', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_baker).default
        }
      })
      Object.defineProperty(exports, 'geoBakerRaw', {
        enumerable: true,
        get: function get() {
          return _baker.bakerRaw
        }
      })

      var _berghaus = __webpack_require__(335)

      Object.defineProperty(exports, 'geoBerghaus', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_berghaus).default
        }
      })
      Object.defineProperty(exports, 'geoBerghausRaw', {
        enumerable: true,
        get: function get() {
          return _berghaus.berghausRaw
        }
      })

      var _boggs = __webpack_require__(173)

      Object.defineProperty(exports, 'geoBoggs', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_boggs).default
        }
      })
      Object.defineProperty(exports, 'geoBoggsRaw', {
        enumerable: true,
        get: function get() {
          return _boggs.boggsRaw
        }
      })

      var _bonne = __webpack_require__(336)

      Object.defineProperty(exports, 'geoBonne', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bonne).default
        }
      })
      Object.defineProperty(exports, 'geoBonneRaw', {
        enumerable: true,
        get: function get() {
          return _bonne.bonneRaw
        }
      })

      var _bottomley = __webpack_require__(337)

      Object.defineProperty(exports, 'geoBottomley', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bottomley).default
        }
      })
      Object.defineProperty(exports, 'geoBottomleyRaw', {
        enumerable: true,
        get: function get() {
          return _bottomley.bottomleyRaw
        }
      })

      var _bromley = __webpack_require__(338)

      Object.defineProperty(exports, 'geoBromley', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bromley).default
        }
      })
      Object.defineProperty(exports, 'geoBromleyRaw', {
        enumerable: true,
        get: function get() {
          return _bromley.bromleyRaw
        }
      })

      var _chamberlin = __webpack_require__(339)

      Object.defineProperty(exports, 'geoChamberlin', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_chamberlin).default
        }
      })
      Object.defineProperty(exports, 'geoChamberlinRaw', {
        enumerable: true,
        get: function get() {
          return _chamberlin.chamberlinRaw
        }
      })
      Object.defineProperty(exports, 'geoChamberlinAfrica', {
        enumerable: true,
        get: function get() {
          return _chamberlin.chamberlinAfrica
        }
      })

      var _collignon = __webpack_require__(90)

      Object.defineProperty(exports, 'geoCollignon', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_collignon).default
        }
      })
      Object.defineProperty(exports, 'geoCollignonRaw', {
        enumerable: true,
        get: function get() {
          return _collignon.collignonRaw
        }
      })

      var _craig = __webpack_require__(340)

      Object.defineProperty(exports, 'geoCraig', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_craig).default
        }
      })
      Object.defineProperty(exports, 'geoCraigRaw', {
        enumerable: true,
        get: function get() {
          return _craig.craigRaw
        }
      })

      var _craster = __webpack_require__(341)

      Object.defineProperty(exports, 'geoCraster', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_craster).default
        }
      })
      Object.defineProperty(exports, 'geoCrasterRaw', {
        enumerable: true,
        get: function get() {
          return _craster.crasterRaw
        }
      })

      var _cylindricalEqualArea = __webpack_require__(174)

      Object.defineProperty(exports, 'geoCylindricalEqualArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cylindricalEqualArea).default
        }
      })
      Object.defineProperty(exports, 'geoCylindricalEqualAreaRaw', {
        enumerable: true,
        get: function get() {
          return _cylindricalEqualArea.cylindricalEqualAreaRaw
        }
      })

      var _cylindricalStereographic = __webpack_require__(342)

      Object.defineProperty(exports, 'geoCylindricalStereographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cylindricalStereographic).default
        }
      })
      Object.defineProperty(exports, 'geoCylindricalStereographicRaw', {
        enumerable: true,
        get: function get() {
          return _cylindricalStereographic.cylindricalStereographicRaw
        }
      })

      var _eckert = __webpack_require__(343)

      Object.defineProperty(exports, 'geoEckert1', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert).default
        }
      })
      Object.defineProperty(exports, 'geoEckert1Raw', {
        enumerable: true,
        get: function get() {
          return _eckert.eckert1Raw
        }
      })

      var _eckert2 = __webpack_require__(344)

      Object.defineProperty(exports, 'geoEckert2', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert2).default
        }
      })
      Object.defineProperty(exports, 'geoEckert2Raw', {
        enumerable: true,
        get: function get() {
          return _eckert2.eckert2Raw
        }
      })

      var _eckert3 = __webpack_require__(345)

      Object.defineProperty(exports, 'geoEckert3', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert3).default
        }
      })
      Object.defineProperty(exports, 'geoEckert3Raw', {
        enumerable: true,
        get: function get() {
          return _eckert3.eckert3Raw
        }
      })

      var _eckert4 = __webpack_require__(346)

      Object.defineProperty(exports, 'geoEckert4', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert4).default
        }
      })
      Object.defineProperty(exports, 'geoEckert4Raw', {
        enumerable: true,
        get: function get() {
          return _eckert4.eckert4Raw
        }
      })

      var _eckert5 = __webpack_require__(347)

      Object.defineProperty(exports, 'geoEckert5', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert5).default
        }
      })
      Object.defineProperty(exports, 'geoEckert5Raw', {
        enumerable: true,
        get: function get() {
          return _eckert5.eckert5Raw
        }
      })

      var _eckert6 = __webpack_require__(348)

      Object.defineProperty(exports, 'geoEckert6', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eckert6).default
        }
      })
      Object.defineProperty(exports, 'geoEckert6Raw', {
        enumerable: true,
        get: function get() {
          return _eckert6.eckert6Raw
        }
      })

      var _eisenlohr = __webpack_require__(349)

      Object.defineProperty(exports, 'geoEisenlohr', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_eisenlohr).default
        }
      })
      Object.defineProperty(exports, 'geoEisenlohrRaw', {
        enumerable: true,
        get: function get() {
          return _eisenlohr.eisenlohrRaw
        }
      })

      var _fahey = __webpack_require__(350)

      Object.defineProperty(exports, 'geoFahey', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_fahey).default
        }
      })
      Object.defineProperty(exports, 'geoFaheyRaw', {
        enumerable: true,
        get: function get() {
          return _fahey.faheyRaw
        }
      })

      var _foucaut = __webpack_require__(351)

      Object.defineProperty(exports, 'geoFoucaut', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_foucaut).default
        }
      })
      Object.defineProperty(exports, 'geoFoucautRaw', {
        enumerable: true,
        get: function get() {
          return _foucaut.foucautRaw
        }
      })

      var _gilbert = __webpack_require__(352)

      Object.defineProperty(exports, 'geoGilbert', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gilbert).default
        }
      })

      var _gingery = __webpack_require__(353)

      Object.defineProperty(exports, 'geoGingery', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gingery).default
        }
      })
      Object.defineProperty(exports, 'geoGingeryRaw', {
        enumerable: true,
        get: function get() {
          return _gingery.gingeryRaw
        }
      })

      var _ginzburg = __webpack_require__(354)

      Object.defineProperty(exports, 'geoGinzburg4', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ginzburg).default
        }
      })
      Object.defineProperty(exports, 'geoGinzburg4Raw', {
        enumerable: true,
        get: function get() {
          return _ginzburg.ginzburg4Raw
        }
      })

      var _ginzburg2 = __webpack_require__(355)

      Object.defineProperty(exports, 'geoGinzburg5', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ginzburg2).default
        }
      })
      Object.defineProperty(exports, 'geoGinzburg5Raw', {
        enumerable: true,
        get: function get() {
          return _ginzburg2.ginzburg5Raw
        }
      })

      var _ginzburg3 = __webpack_require__(356)

      Object.defineProperty(exports, 'geoGinzburg6', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ginzburg3).default
        }
      })
      Object.defineProperty(exports, 'geoGinzburg6Raw', {
        enumerable: true,
        get: function get() {
          return _ginzburg3.ginzburg6Raw
        }
      })

      var _ginzburg4 = __webpack_require__(357)

      Object.defineProperty(exports, 'geoGinzburg8', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ginzburg4).default
        }
      })
      Object.defineProperty(exports, 'geoGinzburg8Raw', {
        enumerable: true,
        get: function get() {
          return _ginzburg4.ginzburg8Raw
        }
      })

      var _ginzburg5 = __webpack_require__(358)

      Object.defineProperty(exports, 'geoGinzburg9', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ginzburg5).default
        }
      })
      Object.defineProperty(exports, 'geoGinzburg9Raw', {
        enumerable: true,
        get: function get() {
          return _ginzburg5.ginzburg9Raw
        }
      })

      var _gringorten = __webpack_require__(175)

      Object.defineProperty(exports, 'geoGringorten', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gringorten).default
        }
      })
      Object.defineProperty(exports, 'geoGringortenRaw', {
        enumerable: true,
        get: function get() {
          return _gringorten.gringortenRaw
        }
      })

      var _guyou = __webpack_require__(177)

      Object.defineProperty(exports, 'geoGuyou', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_guyou).default
        }
      })
      Object.defineProperty(exports, 'geoGuyouRaw', {
        enumerable: true,
        get: function get() {
          return _guyou.guyouRaw
        }
      })

      var _hammer = __webpack_require__(360)

      Object.defineProperty(exports, 'geoHammer', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_hammer).default
        }
      })
      Object.defineProperty(exports, 'geoHammerRaw', {
        enumerable: true,
        get: function get() {
          return _hammer.hammerRaw
        }
      })

      var _hammerRetroazimuthal = __webpack_require__(361)

      Object.defineProperty(exports, 'geoHammerRetroazimuthal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_hammerRetroazimuthal).default
        }
      })
      Object.defineProperty(exports, 'geoHammerRetroazimuthalRaw', {
        enumerable: true,
        get: function get() {
          return _hammerRetroazimuthal.hammerRetroazimuthalRaw
        }
      })

      var _healpix = __webpack_require__(362)

      Object.defineProperty(exports, 'geoHealpix', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_healpix).default
        }
      })
      Object.defineProperty(exports, 'geoHealpixRaw', {
        enumerable: true,
        get: function get() {
          return _healpix.healpixRaw
        }
      })

      var _hill = __webpack_require__(363)

      Object.defineProperty(exports, 'geoHill', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_hill).default
        }
      })
      Object.defineProperty(exports, 'geoHillRaw', {
        enumerable: true,
        get: function get() {
          return _hill.hillRaw
        }
      })

      var _homolosine = __webpack_require__(178)

      Object.defineProperty(exports, 'geoHomolosine', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_homolosine).default
        }
      })
      Object.defineProperty(exports, 'geoHomolosineRaw', {
        enumerable: true,
        get: function get() {
          return _homolosine.homolosineRaw
        }
      })

      var _index = __webpack_require__(26)

      Object.defineProperty(exports, 'geoInterrupt', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index).default
        }
      })

      var _boggs2 = __webpack_require__(364)

      Object.defineProperty(exports, 'geoInterruptedBoggs', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_boggs2).default
        }
      })

      var _homolosine2 = __webpack_require__(365)

      Object.defineProperty(exports, 'geoInterruptedHomolosine', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_homolosine2).default
        }
      })

      var _mollweide = __webpack_require__(366)

      Object.defineProperty(exports, 'geoInterruptedMollweide', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mollweide).default
        }
      })

      var _mollweideHemispheres = __webpack_require__(367)

      Object.defineProperty(exports, 'geoInterruptedMollweideHemispheres', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mollweideHemispheres).default
        }
      })

      var _sinuMollweide = __webpack_require__(368)

      Object.defineProperty(exports, 'geoInterruptedSinuMollweide', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sinuMollweide).default
        }
      })

      var _sinusoidal = __webpack_require__(369)

      Object.defineProperty(exports, 'geoInterruptedSinusoidal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sinusoidal).default
        }
      })

      var _kavrayskiy = __webpack_require__(370)

      Object.defineProperty(exports, 'geoKavrayskiy7', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_kavrayskiy).default
        }
      })
      Object.defineProperty(exports, 'geoKavrayskiy7Raw', {
        enumerable: true,
        get: function get() {
          return _kavrayskiy.kavrayskiy7Raw
        }
      })

      var _lagrange = __webpack_require__(371)

      Object.defineProperty(exports, 'geoLagrange', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_lagrange).default
        }
      })
      Object.defineProperty(exports, 'geoLagrangeRaw', {
        enumerable: true,
        get: function get() {
          return _lagrange.lagrangeRaw
        }
      })

      var _larrivee = __webpack_require__(372)

      Object.defineProperty(exports, 'geoLarrivee', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_larrivee).default
        }
      })
      Object.defineProperty(exports, 'geoLarriveeRaw', {
        enumerable: true,
        get: function get() {
          return _larrivee.larriveeRaw
        }
      })

      var _laskowski = __webpack_require__(373)

      Object.defineProperty(exports, 'geoLaskowski', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_laskowski).default
        }
      })
      Object.defineProperty(exports, 'geoLaskowskiRaw', {
        enumerable: true,
        get: function get() {
          return _laskowski.laskowskiRaw
        }
      })

      var _littrow = __webpack_require__(374)

      Object.defineProperty(exports, 'geoLittrow', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_littrow).default
        }
      })
      Object.defineProperty(exports, 'geoLittrowRaw', {
        enumerable: true,
        get: function get() {
          return _littrow.littrowRaw
        }
      })

      var _loximuthal = __webpack_require__(375)

      Object.defineProperty(exports, 'geoLoximuthal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_loximuthal).default
        }
      })
      Object.defineProperty(exports, 'geoLoximuthalRaw', {
        enumerable: true,
        get: function get() {
          return _loximuthal.loximuthalRaw
        }
      })

      var _miller = __webpack_require__(376)

      Object.defineProperty(exports, 'geoMiller', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_miller).default
        }
      })
      Object.defineProperty(exports, 'geoMillerRaw', {
        enumerable: true,
        get: function get() {
          return _miller.millerRaw
        }
      })

      var _modifiedStereographic = __webpack_require__(377)

      Object.defineProperty(exports, 'geoModifiedStereographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_modifiedStereographic).default
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicRaw', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicRaw
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicAlaska', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicAlaska
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicGs48', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicGs48
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicGs50', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicGs50
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicMiller', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicMiller
        }
      })
      Object.defineProperty(exports, 'geoModifiedStereographicLee', {
        enumerable: true,
        get: function get() {
          return _modifiedStereographic.modifiedStereographicLee
        }
      })

      var _mollweide2 = __webpack_require__(22)

      Object.defineProperty(exports, 'geoMollweide', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mollweide2).default
        }
      })
      Object.defineProperty(exports, 'geoMollweideRaw', {
        enumerable: true,
        get: function get() {
          return _mollweide2.mollweideRaw
        }
      })

      var _mtFlatPolarParabolic = __webpack_require__(378)

      Object.defineProperty(exports, 'geoMtFlatPolarParabolic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mtFlatPolarParabolic).default
        }
      })
      Object.defineProperty(exports, 'geoMtFlatPolarParabolicRaw', {
        enumerable: true,
        get: function get() {
          return _mtFlatPolarParabolic.mtFlatPolarParabolicRaw
        }
      })

      var _mtFlatPolarQuartic = __webpack_require__(379)

      Object.defineProperty(exports, 'geoMtFlatPolarQuartic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mtFlatPolarQuartic).default
        }
      })
      Object.defineProperty(exports, 'geoMtFlatPolarQuarticRaw', {
        enumerable: true,
        get: function get() {
          return _mtFlatPolarQuartic.mtFlatPolarQuarticRaw
        }
      })

      var _mtFlatPolarSinusoidal = __webpack_require__(380)

      Object.defineProperty(exports, 'geoMtFlatPolarSinusoidal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mtFlatPolarSinusoidal).default
        }
      })
      Object.defineProperty(exports, 'geoMtFlatPolarSinusoidalRaw', {
        enumerable: true,
        get: function get() {
          return _mtFlatPolarSinusoidal.mtFlatPolarSinusoidalRaw
        }
      })

      var _naturalEarth = __webpack_require__(381)

      Object.defineProperty(exports, 'geoNaturalEarth', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_naturalEarth).default
        }
      })
      Object.defineProperty(exports, 'geoNaturalEarthRaw', {
        enumerable: true,
        get: function get() {
          return _naturalEarth.naturalEarthRaw
        }
      })

      var _naturalEarth2 = __webpack_require__(382)

      Object.defineProperty(exports, 'geoNaturalEarth2', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_naturalEarth2).default
        }
      })
      Object.defineProperty(exports, 'geoNaturalEarth2Raw', {
        enumerable: true,
        get: function get() {
          return _naturalEarth2.naturalEarth2Raw
        }
      })

      var _nellHammer = __webpack_require__(383)

      Object.defineProperty(exports, 'geoNellHammer', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_nellHammer).default
        }
      })
      Object.defineProperty(exports, 'geoNellHammerRaw', {
        enumerable: true,
        get: function get() {
          return _nellHammer.nellHammerRaw
        }
      })

      var _patterson = __webpack_require__(384)

      Object.defineProperty(exports, 'geoPatterson', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_patterson).default
        }
      })
      Object.defineProperty(exports, 'geoPattersonRaw', {
        enumerable: true,
        get: function get() {
          return _patterson.pattersonRaw
        }
      })

      var _polyconic = __webpack_require__(385)

      Object.defineProperty(exports, 'geoPolyconic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_polyconic).default
        }
      })
      Object.defineProperty(exports, 'geoPolyconicRaw', {
        enumerable: true,
        get: function get() {
          return _polyconic.polyconicRaw
        }
      })

      var _index2 = __webpack_require__(60)

      Object.defineProperty(exports, 'geoPolyhedral', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index2).default
        }
      })

      var _butterfly = __webpack_require__(387)

      Object.defineProperty(exports, 'geoPolyhedralButterfly', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_butterfly).default
        }
      })

      var _collignon2 = __webpack_require__(388)

      Object.defineProperty(exports, 'geoPolyhedralCollignon', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_collignon2).default
        }
      })

      var _waterman = __webpack_require__(389)

      Object.defineProperty(exports, 'geoPolyhedralWaterman', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_waterman).default
        }
      })

      var _index3 = __webpack_require__(390)

      Object.defineProperty(exports, 'geoProject', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index3).default
        }
      })

      var _gringorten2 = __webpack_require__(394)

      Object.defineProperty(exports, 'geoGringortenQuincuncial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gringorten2).default
        }
      })

      var _peirce = __webpack_require__(395)

      Object.defineProperty(exports, 'geoPeirceQuincuncial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_peirce).default
        }
      })
      Object.defineProperty(exports, 'geoPierceQuincuncial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_peirce).default
        }
      })

      var _quantize = __webpack_require__(396)

      Object.defineProperty(exports, 'geoQuantize', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_quantize).default
        }
      })

      var _index4 = __webpack_require__(93)

      Object.defineProperty(exports, 'geoQuincuncial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index4).default
        }
      })

      var _rectangularPolyconic = __webpack_require__(397)

      Object.defineProperty(exports, 'geoRectangularPolyconic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_rectangularPolyconic).default
        }
      })
      Object.defineProperty(exports, 'geoRectangularPolyconicRaw', {
        enumerable: true,
        get: function get() {
          return _rectangularPolyconic.rectangularPolyconicRaw
        }
      })

      var _robinson = __webpack_require__(398)

      Object.defineProperty(exports, 'geoRobinson', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_robinson).default
        }
      })
      Object.defineProperty(exports, 'geoRobinsonRaw', {
        enumerable: true,
        get: function get() {
          return _robinson.robinsonRaw
        }
      })

      var _satellite = __webpack_require__(399)

      Object.defineProperty(exports, 'geoSatellite', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_satellite).default
        }
      })
      Object.defineProperty(exports, 'geoSatelliteRaw', {
        enumerable: true,
        get: function get() {
          return _satellite.satelliteRaw
        }
      })

      var _sinuMollweide2 = __webpack_require__(91)

      Object.defineProperty(exports, 'geoSinuMollweide', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sinuMollweide2).default
        }
      })
      Object.defineProperty(exports, 'geoSinuMollweideRaw', {
        enumerable: true,
        get: function get() {
          return _sinuMollweide2.sinuMollweideRaw
        }
      })

      var _sinusoidal2 = __webpack_require__(41)

      Object.defineProperty(exports, 'geoSinusoidal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sinusoidal2).default
        }
      })
      Object.defineProperty(exports, 'geoSinusoidalRaw', {
        enumerable: true,
        get: function get() {
          return _sinusoidal2.sinusoidalRaw
        }
      })

      var _stitch = __webpack_require__(400)

      Object.defineProperty(exports, 'geoStitch', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stitch).default
        }
      })

      var _times = __webpack_require__(401)

      Object.defineProperty(exports, 'geoTimes', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_times).default
        }
      })
      Object.defineProperty(exports, 'geoTimesRaw', {
        enumerable: true,
        get: function get() {
          return _times.timesRaw
        }
      })

      var _twoPointAzimuthal = __webpack_require__(402)

      Object.defineProperty(exports, 'geoTwoPointAzimuthal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_twoPointAzimuthal).default
        }
      })
      Object.defineProperty(exports, 'geoTwoPointAzimuthalRaw', {
        enumerable: true,
        get: function get() {
          return _twoPointAzimuthal.twoPointAzimuthalRaw
        }
      })
      Object.defineProperty(exports, 'geoTwoPointAzimuthalUsa', {
        enumerable: true,
        get: function get() {
          return _twoPointAzimuthal.twoPointAzimuthalUsa
        }
      })

      var _twoPointEquidistant = __webpack_require__(403)

      Object.defineProperty(exports, 'geoTwoPointEquidistant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_twoPointEquidistant).default
        }
      })
      Object.defineProperty(exports, 'geoTwoPointEquidistantRaw', {
        enumerable: true,
        get: function get() {
          return _twoPointEquidistant.twoPointEquidistantRaw
        }
      })
      Object.defineProperty(exports, 'geoTwoPointEquidistantUsa', {
        enumerable: true,
        get: function get() {
          return _twoPointEquidistant.twoPointEquidistantUsa
        }
      })

      var _vanDerGrinten = __webpack_require__(404)

      Object.defineProperty(exports, 'geoVanDerGrinten', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_vanDerGrinten).default
        }
      })
      Object.defineProperty(exports, 'geoVanDerGrintenRaw', {
        enumerable: true,
        get: function get() {
          return _vanDerGrinten.vanDerGrintenRaw
        }
      })

      var _vanDerGrinten2 = __webpack_require__(405)

      Object.defineProperty(exports, 'geoVanDerGrinten2', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_vanDerGrinten2).default
        }
      })
      Object.defineProperty(exports, 'geoVanDerGrinten2Raw', {
        enumerable: true,
        get: function get() {
          return _vanDerGrinten2.vanDerGrinten2Raw
        }
      })

      var _vanDerGrinten3 = __webpack_require__(406)

      Object.defineProperty(exports, 'geoVanDerGrinten3', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_vanDerGrinten3).default
        }
      })
      Object.defineProperty(exports, 'geoVanDerGrinten3Raw', {
        enumerable: true,
        get: function get() {
          return _vanDerGrinten3.vanDerGrinten3Raw
        }
      })

      var _vanDerGrinten4 = __webpack_require__(407)

      Object.defineProperty(exports, 'geoVanDerGrinten4', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_vanDerGrinten4).default
        }
      })
      Object.defineProperty(exports, 'geoVanDerGrinten4Raw', {
        enumerable: true,
        get: function get() {
          return _vanDerGrinten4.vanDerGrinten4Raw
        }
      })

      var _wagner = __webpack_require__(408)

      Object.defineProperty(exports, 'geoWagner4', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wagner).default
        }
      })
      Object.defineProperty(exports, 'geoWagner4Raw', {
        enumerable: true,
        get: function get() {
          return _wagner.wagner4Raw
        }
      })

      var _wagner2 = __webpack_require__(409)

      Object.defineProperty(exports, 'geoWagner6', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wagner2).default
        }
      })
      Object.defineProperty(exports, 'geoWagner6Raw', {
        enumerable: true,
        get: function get() {
          return _wagner2.wagner6Raw
        }
      })

      var _wagner3 = __webpack_require__(410)

      Object.defineProperty(exports, 'geoWagner7', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wagner3).default
        }
      })
      Object.defineProperty(exports, 'geoWagner7Raw', {
        enumerable: true,
        get: function get() {
          return _wagner3.wagner7Raw
        }
      })

      var _wiechel = __webpack_require__(411)

      Object.defineProperty(exports, 'geoWiechel', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wiechel).default
        }
      })
      Object.defineProperty(exports, 'geoWiechelRaw', {
        enumerable: true,
        get: function get() {
          return _wiechel.wiechelRaw
        }
      })

      var _winkel = __webpack_require__(412)

      Object.defineProperty(exports, 'geoWinkel3', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_winkel).default
        }
      })
      Object.defineProperty(exports, 'geoWinkel3Raw', {
        enumerable: true,
        get: function get() {
          return _winkel.winkel3Raw
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 171 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.aitoffRaw = aitoffRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(aitoffRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function aitoffRaw(x, y) {
        var cosy = (0, _math.cos)(y),
          sincia = (0, _math.sinci)((0, _math.acos)(cosy * (0, _math.cos)(x /= 2)))
        return [2 * cosy * (0, _math.sin)(x) * sincia, (0, _math.sin)(y) * sincia]
      }

      // Abort if [x, y] is not within an ellipse centered at [0, 0] with
      // semi-major axis pi and semi-minor axis pi/2.
      aitoffRaw.invert = function (x, y) {
        if (x * x + 4 * y * y > _math.pi * _math.pi + _math.epsilon) return
        var x1 = x,
          y1 = y,
          i = 25
        do {
          var sinx = (0, _math.sin)(x1),
            sinx_2 = (0, _math.sin)(x1 / 2),
            cosx_2 = (0, _math.cos)(x1 / 2),
            siny = (0, _math.sin)(y1),
            cosy = (0, _math.cos)(y1),
            sin_2y = (0, _math.sin)(2 * y1),
            sin2y = siny * siny,
            cos2y = cosy * cosy,
            sin2x_2 = sinx_2 * sinx_2,
            c = 1 - cos2y * cosx_2 * cosx_2,
            e = c ? (0, _math.acos)(cosy * cosx_2) * (0, _math.sqrt)(f = 1 / c) : f = 0,
            f,
            fx = 2 * e * cosy * sinx_2 - x,
            fy = e * siny - y,
            dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y),
            dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2),
            dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx),
            dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy),
            z = dxdy * dydx - dydy * dxdx
          if (!z) break
          var dx = (fy * dxdy - fx * dydy) / z,
            dy = (fx * dydx - fy * dxdx) / z
          x1 -= dx, y1 -= dy
        } while (((0, _math.abs)(dx) > _math.epsilon || (0, _math.abs)(dy) > _math.epsilon) && --i > 0)
        return [x1, y1]
      }
      /***/
    },
    /* 172 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.augustRaw = augustRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(augustRaw).scale(66.1603)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function augustRaw(lambda, phi) {
        var tanPhi = (0, _math.tan)(phi / 2),
          k = (0, _math.sqrt)(1 - tanPhi * tanPhi),
          c = 1 + k * (0, _math.cos)(lambda /= 2),
          x = (0, _math.sin)(lambda) * k / c,
          y = tanPhi / c,
          x2 = x * x,
          y2 = y * y
        return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)]
      }

      augustRaw.invert = function (x, y) {
        x *= 3 / 8, y *= 3 / 8
        if (!x && (0, _math.abs)(y) > 1) return null
        var x2 = x * x,
          y2 = y * y,
          s = 1 + x2 + y2,
          sin3Eta = (0, _math.sqrt)((s - (0, _math.sqrt)(s * s - 4 * y * y)) / 2),
          eta = (0, _math.asin)(sin3Eta) / 3,
          xi = sin3Eta ? (0, _math.arcosh)((0, _math.abs)(y / sin3Eta)) / 3 : (0, _math.arsinh)((0, _math.abs)(x)) / 3,
          cosEta = (0, _math.cos)(eta),
          coshXi = (0, _math.cosh)(xi),
          d = coshXi * coshXi - cosEta * cosEta
        return [(0, _math.sign)(x) * 2 * (0, _math.atan2)((0, _math.sinh)(xi) * cosEta, 0.25 - d), (0, _math.sign)(y) * 2 * (0, _math.atan2)(coshXi * (0, _math.sin)(eta), 0.25 + d)]
      }
      /***/
    },
    /* 173 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.boggsRaw = boggsRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(boggsRaw).scale(160.857)
      }

      var _d3Geo = __webpack_require__(0)

      var _mollweide = __webpack_require__(22)

      var _math = __webpack_require__(1)

      var k = 2.00276,
        w = 1.11072

      function boggsRaw(lambda, phi) {
        var theta = (0, _mollweide.mollweideBromleyTheta)(_math.pi, phi)
        return [k * lambda / (1 / (0, _math.cos)(phi) + w / (0, _math.cos)(theta)), (phi + _math.sqrt2 * (0, _math.sin)(theta)) / k]
      }

      boggsRaw.invert = function (x, y) {
        var ky = k * y,
          theta = y < 0 ? -_math.quarterPi : _math.quarterPi,
          i = 25,
          delta,
          phi
        do {
          phi = ky - _math.sqrt2 * (0, _math.sin)(theta)
          theta -= delta = ((0, _math.sin)(2 * theta) + 2 * theta - _math.pi * (0, _math.sin)(phi)) / (2 * (0, _math.cos)(2 * theta) + 2 + _math.pi * (0, _math.cos)(phi) * _math.sqrt2 * (0, _math.cos)(theta))
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        phi = ky - _math.sqrt2 * (0, _math.sin)(theta)
        return [x * (1 / (0, _math.cos)(phi) + w / (0, _math.cos)(theta)) / k, phi]
      }
      /***/
    },
    /* 174 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.cylindricalEqualAreaRaw = cylindricalEqualAreaRaw

      exports.default = function () {
        return (0, _parallel2.default)(cylindricalEqualAreaRaw).parallel(38.58) // acos(sqrt(width / height / pi)) * radians
          .scale(195.044) // width / (sqrt(width / height / pi) * 2 * pi)
      }

      var _math = __webpack_require__(1)

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function cylindricalEqualAreaRaw(phi0) {
        var cosPhi0 = (0, _math.cos)(phi0)

        function forward(lambda, phi) {
          return [lambda * cosPhi0, (0, _math.sin)(phi) / cosPhi0]
        }

        forward.invert = function (x, y) {
          return [x / cosPhi0, (0, _math.asin)(y * cosPhi0)]
        }

        return forward
      }
      /***/
    },
    /* 175 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.gringortenRaw = gringortenRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)((0, _square2.default)(gringortenRaw)).scale(239.75)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _square = __webpack_require__(176)

      var _square2 = _interopRequireDefault(_square)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function gringortenRaw(lambda, phi) {
        var sLambda = (0, _math.sign)(lambda),
          sPhi = (0, _math.sign)(phi),
          cosPhi = (0, _math.cos)(phi),
          x = (0, _math.cos)(lambda) * cosPhi,
          y = (0, _math.sin)(lambda) * cosPhi,
          z = (0, _math.sin)(sPhi * phi)
        lambda = (0, _math.abs)((0, _math.atan2)(y, z))
        phi = (0, _math.asin)(x)
        if ((0, _math.abs)(lambda - _math.halfPi) > _math.epsilon) lambda %= _math.halfPi
        var point = gringortenHexadecant(lambda > _math.pi / 4 ? _math.halfPi - lambda : lambda, phi)
        if (lambda > _math.pi / 4) z = point[0], point[0] = -point[1], point[1] = -z
        return point[0] *= sLambda, point[1] *= -sPhi, point
      }

      gringortenRaw.invert = function (x, y) {
        if ((0, _math.abs)(x) > 1) x = (0, _math.sign)(x) * 2 - x
        if ((0, _math.abs)(y) > 1) y = (0, _math.sign)(y) * 2 - y
        var sx = (0, _math.sign)(x),
          sy = (0, _math.sign)(y),
          x0 = -sx * x,
          y0 = -sy * y,
          t = y0 / x0 < 1,
          p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0),
          lambda = p[0],
          phi = p[1],
          cosPhi = (0, _math.cos)(phi)
        if (t) lambda = -_math.halfPi - lambda
        return [sx * ((0, _math.atan2)((0, _math.sin)(lambda) * cosPhi, -(0, _math.sin)(phi)) + _math.pi), sy * (0, _math.asin)((0, _math.cos)(lambda) * cosPhi)]
      }

      function gringortenHexadecant(lambda, phi) {
        if (phi === _math.halfPi) return [0, 0]

        var sinPhi = (0, _math.sin)(phi),
          r = sinPhi * sinPhi,
          r2 = r * r,
          j = 1 + r2,
          k = 1 + 3 * r2,
          q = 1 - r2,
          z = (0, _math.asin)(1 / (0, _math.sqrt)(j)),
          v = q + r * j * z,
          p2 = (1 - sinPhi) / v,
          p = (0, _math.sqrt)(p2),
          a2 = p2 * j,
          a = (0, _math.sqrt)(a2),
          h = p * q,
          x,
          i

        if (lambda === 0) return [0, -(h + r * a)]

        var cosPhi = (0, _math.cos)(phi),
          secPhi = 1 / cosPhi,
          drdPhi = 2 * sinPhi * cosPhi,
          dvdPhi = (-3 * r + z * k) * drdPhi,
          dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
          dpdPhi = 0.5 * dp2dPhi / p,
          dhdPhi = q * dpdPhi - 2 * r * p * drdPhi,
          dra2dPhi = r * j * dp2dPhi + p2 * k * drdPhi,
          mu = -secPhi * drdPhi,
          nu = -secPhi * dra2dPhi,
          zeta = -2 * secPhi * dhdPhi,
          lambda1 = 4 * lambda / _math.pi,
          delta

        // Slower but accurate bisection method.
        if (lambda > 0.222 * _math.pi || phi < _math.pi / 4 && lambda > 0.175 * _math.pi) {
          x = (h + r * (0, _math.sqrt)(a2 * (1 + r2) - h * h)) / (1 + r2)
          if (lambda > _math.pi / 4) return [x, x]
          var x1 = x,
            x0 = 0.5 * x
          x = 0.5 * (x0 + x1), i = 50
          do {
            var g = (0, _math.sqrt)(a2 - x * x),
              f = x * (zeta + mu * g) + nu * (0, _math.asin)(x / a) - lambda1
            if (!f) break
            if (f < 0) x0 = x;
            else x1 = x
            x = 0.5 * (x0 + x1)
          } while ((0, _math.abs)(x1 - x0) > _math.epsilon && --i > 0)
        }

        // Newton-Raphson.
        else {
          x = _math.epsilon, i = 25
          do {
            var x2 = x * x,
              g2 = (0, _math.sqrt)(a2 - x2),
              zetaMug = zeta + mu * g2,
              f2 = x * zetaMug + nu * (0, _math.asin)(x / a) - lambda1,
              df = zetaMug + (nu - mu * x2) / g2
            x -= delta = g2 ? f2 / df : 0
          } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        }

        return [x, -h - r * (0, _math.sqrt)(a2 - x * x)]
      }

      function gringortenHexadecantInvert(x, y) {
        var x0 = 0,
          x1 = 1,
          r = 0.5,
          i = 50

        while (true) {
          var r2 = r * r,
            sinPhi = (0, _math.sqrt)(r),
            z = (0, _math.asin)(1 / (0, _math.sqrt)(1 + r2)),
            v = 1 - r2 + r * (1 + r2) * z,
            p2 = (1 - sinPhi) / v,
            p = (0, _math.sqrt)(p2),
            a2 = p2 * (1 + r2),
            h = p * (1 - r2),
            g2 = a2 - x * x,
            g = (0, _math.sqrt)(g2),
            y0 = y + h + r * g
          if ((0, _math.abs)(x1 - x0) < _math.epsilon2 || --i === 0 || y0 === 0) break
          if (y0 > 0) x0 = r;
          else x1 = r
          r = 0.5 * (x0 + x1)
        }

        if (!i) return null

        var phi = (0, _math.asin)(sinPhi),
          cosPhi = (0, _math.cos)(phi),
          secPhi = 1 / cosPhi,
          drdPhi = 2 * sinPhi * cosPhi,
          dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi,
          dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
          dpdPhi = 0.5 * dp2dPhi / p,
          dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi,
          zeta = -2 * secPhi * dhdPhi,
          mu = -secPhi * drdPhi,
          nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi)

        return [_math.pi / 4 * (x * (zeta + mu * g) + nu * (0, _math.asin)(x / (0, _math.sqrt)(a2))), phi]
      }
      /***/
    },
    /* 176 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (project) {
        var dx = project(_math.halfPi, 0)[0] - project(-_math.halfPi, 0)[0]

        function projectSquare(lambda, phi) {
          var s = lambda > 0 ? -0.5 : 0.5,
            point = project(lambda + s * _math.pi, phi)
          point[0] -= s * dx
          return point
        }

        if (project.invert) {
          projectSquare.invert = function (x, y) {
            var s = x > 0 ? -0.5 : 0.5,
              location = project.invert(x + s * dx, y),
              lambda = location[0] - s * _math.pi
            if (lambda < -_math.pi) lambda += 2 * _math.pi;
            else if (lambda > _math.pi) lambda -= 2 * _math.pi
            location[0] = lambda
            return location
          }
        }

        return projectSquare
      }

      var _math = __webpack_require__(1)
      /***/
    },
    /* 177 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.guyouRaw = guyouRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)((0, _square2.default)(guyouRaw)).scale(151.496)
      }

      var _d3Geo = __webpack_require__(0)

      var _elliptic = __webpack_require__(359)

      var _math = __webpack_require__(1)

      var _square = __webpack_require__(176)

      var _square2 = _interopRequireDefault(_square)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function guyouRaw(lambda, phi) {
        var k_ = (_math.sqrt2 - 1) / (_math.sqrt2 + 1),
          k = (0, _math.sqrt)(1 - k_ * k_),
          K = (0, _elliptic.ellipticF)(_math.halfPi, k * k),
          f = -1,
          psi = (0, _math.log)((0, _math.tan)(_math.pi / 4 + (0, _math.abs)(phi) / 2)),
          r = (0, _math.exp)(f * psi) / (0, _math.sqrt)(k_),
          at = guyouComplexAtan(r * (0, _math.cos)(f * lambda), r * (0, _math.sin)(f * lambda)),
          t = (0, _elliptic.ellipticFi)(at[0], at[1], k * k)
        return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K - t[0])]
      }

      function guyouComplexAtan(x, y) {
        var x2 = x * x,
          y_1 = y + 1,
          t = 1 - x2 - y * y
        return [0.5 * ((x >= 0 ? _math.halfPi : -_math.halfPi) - (0, _math.atan2)(t, 2 * x)), -0.25 * (0, _math.log)(t * t + 4 * x2) + 0.5 * (0, _math.log)(y_1 * y_1 + x2)]
      }

      function guyouComplexDivide(a, b) {
        var denominator = b[0] * b[0] + b[1] * b[1]
        return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator]
      }

      guyouRaw.invert = function (x, y) {
        var k_ = (_math.sqrt2 - 1) / (_math.sqrt2 + 1),
          k = (0, _math.sqrt)(1 - k_ * k_),
          K = (0, _elliptic.ellipticF)(_math.halfPi, k * k),
          f = -1,
          j = (0, _elliptic.ellipticJi)(0.5 * K - y, -x, k * k),
          tn = guyouComplexDivide(j[0], j[1]),
          lambda = (0, _math.atan2)(tn[1], tn[0]) / f
        return [lambda, 2 * (0, _math.atan)((0, _math.exp)(0.5 / f * (0, _math.log)(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - _math.halfPi]
      }
      /***/
    },
    /* 178 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.homolosineRaw = homolosineRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(homolosineRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _mollweide = __webpack_require__(22)

      var _sinusoidal = __webpack_require__(41)

      var _sinuMollweide = __webpack_require__(91)

      function homolosineRaw(lambda, phi) {
        return (0, _math.abs)(phi) > _sinuMollweide.sinuMollweidePhi ? (lambda = (0, _mollweide.mollweideRaw)(lambda, phi), lambda[1] -= phi > 0 ? _sinuMollweide.sinuMollweideY : -_sinuMollweide.sinuMollweideY, lambda) : (0, _sinusoidal.sinusoidalRaw)(lambda, phi)
      }

      homolosineRaw.invert = function (x, y) {
        return (0, _math.abs)(y) > _sinuMollweide.sinuMollweidePhi ? _mollweide.mollweideRaw.invert(x, y + (y > 0 ? _sinuMollweide.sinuMollweideY : -_sinuMollweide.sinuMollweideY)) : _sinusoidal.sinusoidalRaw.invert(x, y)
      }
      /***/
    },
    /* 179 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (raw, p0, p1) {
        var i = (0, _d3Geo.geoInterpolate)(p0, p1),
          o = i(0.5),
          a = (0, _d3Geo.geoRotation)([-o[0], -o[1]])(p0),
          b = i.distance / 2,
          y = -(0, _math.asin)((0, _math.sin)(a[1] * _math.radians) / (0, _math.sin)(b)),
          R = [-o[0], -o[1], -(a[0] > 0 ? _math.pi - y : y) * _math.degrees],
          p = (0, _d3Geo.geoProjection)(raw(b)).rotate(R),
          r = (0, _d3Geo.geoRotation)(R),
          center = p.center

        delete p.rotate

        p.center = function (_) {
          return arguments.length ? center(r(_)) : r.invert(center())
        }

        return p.clipAngle(90)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)
      /***/
    },
    /* 180 */
    /***/
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      /*!
       * EventEmitter v5.2.2 - git.io/ee
       * Unlicense - http://unlicense.org/
       * Oliver Caldwell - http://oli.me.uk/
       * @preserve
       */

      ;
      (function (exports) {
        'use strict'

        /**
         * Class for managing events.
         * Can be extended to provide event functionality in other classes.
         *
         * @class EventEmitter Manages event registering and emitting.
         */

        function EventEmitter() {}

        // Shortcuts to improve speed and size
        var proto = EventEmitter.prototype
        var originalGlobalValue = exports.EventEmitter

        /**
         * Finds the index of the listener for the event in its storage array.
         *
         * @param {Function[]} listeners Array of listeners to search through.
         * @param {Function} listener Method to look for.
         * @return {Number} Index of the specified listener, -1 if not found
         * @api private
         */
        function indexOfListener(listeners, listener) {
          var i = listeners.length
          while (i--) {
            if (listeners[i].listener === listener) {
              return i
            }
          }

          return -1
        }

        /**
         * Alias a method while keeping the context correct, to allow for overwriting of target method.
         *
         * @param {String} name The name of the target method.
         * @return {Function} The aliased method
         * @api private
         */
        function alias(name) {
          return function aliasClosure() {
            return this[name].apply(this, arguments)
          }
        }

        /**
         * Returns the listener array for the specified event.
         * Will initialise the event object and listener arrays if required.
         * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
         * Each property in the object response is an array of listener functions.
         *
         * @param {String|RegExp} evt Name of the event to return the listeners from.
         * @return {Function[]|Object} All listener functions for the event.
         */
        proto.getListeners = function getListeners(evt) {
          var events = this._getEvents()
          var response
          var key

          // Return a concatenated array of all matching events if
          // the selector is a regular expression.
          if (evt instanceof RegExp) {
            response = {}
            for (key in events) {
              if (events.hasOwnProperty(key) && evt.test(key)) {
                response[key] = events[key]
              }
            }
          } else {
            response = events[evt] || (events[evt] = [])
          }

          return response
        }

        /**
         * Takes a list of listener objects and flattens it into a list of listener functions.
         *
         * @param {Object[]} listeners Raw listener objects.
         * @return {Function[]} Just the listener functions.
         */
        proto.flattenListeners = function flattenListeners(listeners) {
          var flatListeners = []
          var i

          for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener)
          }

          return flatListeners
        }

        /**
         * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
         *
         * @param {String|RegExp} evt Name of the event to return the listeners from.
         * @return {Object} All listener functions for an event in an object.
         */
        proto.getListenersAsObject = function getListenersAsObject(evt) {
          var listeners = this.getListeners(evt)
          var response

          if (listeners instanceof Array) {
            response = {}
            response[evt] = listeners
          }

          return response || listeners
        }

        function isValidListener(listener) {
          if (typeof listener === 'function' || listener instanceof RegExp) {
            return true
          } else if (listener && (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object') {
            return isValidListener(listener.listener)
          } else {
            return false
          }
        }

        /**
         * Adds a listener function to the specified event.
         * The listener will not be added if it is a duplicate.
         * If the listener returns true then it will be removed after it is called.
         * If you pass a regular expression as the event name then the listener will be added to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to attach the listener to.
         * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.addListener = function addListener(evt, listener) {
          if (!isValidListener(listener)) {
            throw new TypeError('listener must be a function')
          }

          var listeners = this.getListenersAsObject(evt)
          var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object'
          var key

          for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
              listeners[key].push(listenerIsWrapped ? listener : {
                listener: listener,
                once: false
              })
            }
          }

          return this
        }

        /**
         * Alias of addListener
         */
        proto.on = alias('addListener')

        /**
         * Semi-alias of addListener. It will add a listener that will be
         * automatically removed after its first execution.
         *
         * @param {String|RegExp} evt Name of the event to attach the listener to.
         * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.addOnceListener = function addOnceListener(evt, listener) {
          return this.addListener(evt, {
            listener: listener,
            once: true
          })
        }

        /**
         * Alias of addOnceListener.
         */
        proto.once = alias('addOnceListener')

        /**
         * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
         * You need to tell it what event names should be matched by a regex.
         *
         * @param {String} evt Name of the event to create.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.defineEvent = function defineEvent(evt) {
          this.getListeners(evt)
          return this
        }

        /**
         * Uses defineEvent to define multiple events.
         *
         * @param {String[]} evts An array of event names to define.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.defineEvents = function defineEvents(evts) {
          for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i])
          }
          return this
        }

        /**
         * Removes a listener function from the specified event.
         * When passed a regular expression as the event name, it will remove the listener from all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to remove the listener from.
         * @param {Function} listener Method to remove from the event.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.removeListener = function removeListener(evt, listener) {
          var listeners = this.getListenersAsObject(evt)
          var index
          var key

          for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
              index = indexOfListener(listeners[key], listener)

              if (index !== -1) {
                listeners[key].splice(index, 1)
              }
            }
          }

          return this
        }

        /**
         * Alias of removeListener
         */
        proto.off = alias('removeListener')

        /**
         * Adds listeners in bulk using the manipulateListeners method.
         * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
         * You can also pass it a regular expression to add the array of listeners to all events that match it.
         * Yeah, this function does quite a bit. That's probably a bad thing.
         *
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to add.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.addListeners = function addListeners(evt, listeners) {
          // Pass through to manipulateListeners
          return this.manipulateListeners(false, evt, listeners)
        }

        /**
         * Removes listeners in bulk using the manipulateListeners method.
         * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
         * You can also pass it an event name and an array of listeners to be removed.
         * You can also pass it a regular expression to remove the listeners from all events that match it.
         *
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to remove.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.removeListeners = function removeListeners(evt, listeners) {
          // Pass through to manipulateListeners
          return this.manipulateListeners(true, evt, listeners)
        }

        /**
         * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
         * The first argument will determine if the listeners are removed (true) or added (false).
         * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
         * You can also pass it an event name and an array of listeners to be added/removed.
         * You can also pass it a regular expression to manipulate the listeners of all events that match it.
         *
         * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
         * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
         * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
          var i
          var value
          var single = remove ? this.removeListener : this.addListener
          var multiple = remove ? this.removeListeners : this.addListeners

          // If evt is an object then pass each of its properties to this method
          if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
              if (evt.hasOwnProperty(i) && (value = evt[i])) {
                // Pass the single listener straight through to the singular method
                if (typeof value === 'function') {
                  single.call(this, i, value)
                } else {
                  // Otherwise pass back to the multiple function
                  multiple.call(this, i, value)
                }
              }
            }
          } else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length
            while (i--) {
              single.call(this, evt, listeners[i])
            }
          }

          return this
        }

        /**
         * Removes all listeners from a specified event.
         * If you do not specify an event then all listeners will be removed.
         * That means every event will be emptied.
         * You can also pass a regex to remove all events that match it.
         *
         * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.removeEvent = function removeEvent(evt) {
          var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt)
          var events = this._getEvents()
          var key

          // Remove different things depending on the state of evt
          if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt]
          } else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
              if (events.hasOwnProperty(key) && evt.test(key)) {
                delete events[key]
              }
            }
          } else {
            // Remove all listeners in all events
            delete this._events
          }

          return this
        }

        /**
         * Alias of removeEvent.
         *
         * Added to mirror the node API.
         */
        proto.removeAllListeners = alias('removeEvent')

        /**
         * Emits an event of your choice.
         * When emitted, every listener attached to that event will be executed.
         * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
         * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
         * So they will not arrive within the array on the other side, they will be separate.
         * You can also pass a regular expression to emit to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
         * @param {Array} [args] Optional array of arguments to be passed to each listener.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.emitEvent = function emitEvent(evt, args) {
          var listenersMap = this.getListenersAsObject(evt)
          var listeners
          var listener
          var i
          var key
          var response

          for (key in listenersMap) {
            if (listenersMap.hasOwnProperty(key)) {
              listeners = listenersMap[key].slice(0)

              for (i = 0; i < listeners.length; i++) {
                // If the listener returns true then it shall be removed from the event
                // The function is executed either with a basic call or an apply if there is an args array
                listener = listeners[i]

                if (listener.once === true) {
                  this.removeListener(evt, listener.listener)
                }

                response = listener.listener.apply(this, args || [])

                if (response === this._getOnceReturnValue()) {
                  this.removeListener(evt, listener.listener)
                }
              }
            }
          }

          return this
        }

        /**
         * Alias of emitEvent
         */
        proto.trigger = alias('emitEvent')

        /**
         * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
         * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
         *
         * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
         * @param {...*} Optional additional arguments to be passed to each listener.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.emit = function emit(evt) {
          var args = Array.prototype.slice.call(arguments, 1)
          return this.emitEvent(evt, args)
        }

        /**
         * Sets the current value to check against when executing listeners. If a
         * listeners return value matches the one set here then it will be removed
         * after execution. This value defaults to true.
         *
         * @param {*} value The new value to check for when executing listeners.
         * @return {Object} Current instance of EventEmitter for chaining.
         */
        proto.setOnceReturnValue = function setOnceReturnValue(value) {
          this._onceReturnValue = value
          return this
        }

        /**
         * Fetches the current value to check against when executing listeners. If
         * the listeners return value matches this one then it should be removed
         * automatically. It will return true by default.
         *
         * @return {*|Boolean} The current value to check for or the default, true.
         * @api private
         */
        proto._getOnceReturnValue = function _getOnceReturnValue() {
          if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue
          } else {
            return true
          }
        }

        /**
         * Fetches the events object and creates one if required.
         *
         * @return {Object} The events storage object.
         * @api private
         */
        proto._getEvents = function _getEvents() {
          return this._events || (this._events = {})
        }

        /**
         * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
         *
         * @return {Function} Non conflicting EventEmitter class.
         */
        EventEmitter.noConflict = function noConflict() {
          exports.EventEmitter = originalGlobalValue
          return EventEmitter
        }

        // Expose the class either via AMD, CommonJS or the global object
        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
              return EventEmitter
            }.call(exports, __webpack_require__, exports, module)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {
          module.exports = EventEmitter
        } else {
          exports.EventEmitter = EventEmitter
        }
      })(undefined || {})
      /***/
    },
    /* 181 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseClone = __webpack_require__(182)

      /** Used to compose bitmasks for cloning. */
      var CLONE_SYMBOLS_FLAG = 4

      /**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG)
      }

      module.exports = clone
      /***/
    },
    /* 182 */
    /***/
    function (module, exports, __webpack_require__) {
      var Stack = __webpack_require__(94),
        arrayEach = __webpack_require__(435),
        assignValue = __webpack_require__(53),
        baseAssign = __webpack_require__(436),
        baseAssignIn = __webpack_require__(437),
        cloneBuffer = __webpack_require__(440),
        copyArray = __webpack_require__(441),
        copySymbols = __webpack_require__(442),
        copySymbolsIn = __webpack_require__(444),
        getAllKeys = __webpack_require__(185),
        getAllKeysIn = __webpack_require__(445),
        getTag = __webpack_require__(187),
        initCloneArray = __webpack_require__(449),
        initCloneByTag = __webpack_require__(450),
        initCloneObject = __webpack_require__(459),
        isArray = __webpack_require__(10),
        isBuffer = __webpack_require__(80),
        isObject = __webpack_require__(12),
        keys = __webpack_require__(9)

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]'

      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]'

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {}
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false

      /**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG

        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value)
        }
        if (result !== undefined) {
          return result
        }
        if (!isObject(value)) {
          return value
        }
        var isArr = isArray(value)
        if (isArr) {
          result = initCloneArray(value)
          if (!isDeep) {
            return copyArray(value, result)
          }
        } else {
          var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag

          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep)
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value)
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value))
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {}
            }
            result = initCloneByTag(value, tag, baseClone, isDeep)
          }
        }
        // Check for circular references and return its corresponding clone.
        stack || (stack = new Stack())
        var stacked = stack.get(value)
        if (stacked) {
          return stacked
        }
        stack.set(value, result)

        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys

        var props = isArr ? undefined : keysFunc(value)
        arrayEach(props || value, function (subValue, key) {
          if (props) {
            key = subValue
            subValue = value[key]
          }
          // Recursively populate clone (susceptible to call stack limits).
          assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
        })
        return result
      }

      module.exports = baseClone
      /***/
    },
    /* 183 */
    /***/
    function (module, exports) {
      /**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */
      function stubArray() {
        return []
      }

      module.exports = stubArray
      /***/
    },
    /* 184 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayPush = __webpack_require__(99),
        getPrototype = __webpack_require__(100),
        getSymbols = __webpack_require__(98),
        stubArray = __webpack_require__(183)

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeGetSymbols = Object.getOwnPropertySymbols

      /**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
        var result = []
        while (object) {
          arrayPush(result, getSymbols(object))
          object = getPrototype(object)
        }
        return result
      }

      module.exports = getSymbolsIn
      /***/
    },
    /* 185 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetAllKeys = __webpack_require__(186),
        getSymbols = __webpack_require__(98),
        keys = __webpack_require__(9)

      /**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols)
      }

      module.exports = getAllKeys
      /***/
    },
    /* 186 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayPush = __webpack_require__(99),
        isArray = __webpack_require__(10)

      /**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object)
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
      }

      module.exports = baseGetAllKeys
      /***/
    },
    /* 187 */
    /***/
    function (module, exports, __webpack_require__) {
      var DataView = __webpack_require__(446),
        Map = __webpack_require__(95),
        Promise = __webpack_require__(447),
        Set = __webpack_require__(188),
        WeakMap = __webpack_require__(448),
        baseGetTag = __webpack_require__(19),
        toSource = __webpack_require__(138)

      /** `Object#toString` result references. */
      var mapTag = '[object Map]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]'

      var dataViewTag = '[object DataView]'

      /** Used to detect maps, sets, and weakmaps. */
      var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap)

      /**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      var getTag = baseGetTag

      // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
        getTag = function getTag(value) {
          var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : ''

          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag
              case mapCtorString:
                return mapTag
              case promiseCtorString:
                return promiseTag
              case setCtorString:
                return setTag
              case weakMapCtorString:
                return weakMapTag
            }
          }
          return result
        }
      }

      module.exports = getTag
      /***/
    },
    /* 188 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24),
        root = __webpack_require__(13)

      /* Built-in method references that are verified to be native. */
      var Set = getNative(root, 'Set')

      module.exports = Set
      /***/
    },
    /* 189 */
    /***/
    function (module, exports, __webpack_require__) {
      var root = __webpack_require__(13)

      /** Built-in value references. */
      var Uint8Array = root.Uint8Array

      module.exports = Uint8Array
      /***/
    },
    /* 190 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
          length = array == null ? 0 : array.length

        if (initAccum && length) {
          accumulator = array[++index]
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array)
        }
        return accumulator
      }

      module.exports = arrayReduce
      /***/
    },
    /* 191 */
    /***/
    function (module, exports) {
      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
          result = Array(map.size)

        map.forEach(function (value, key) {
          result[++index] = [key, value]
        })
        return result
      }

      module.exports = mapToArray
      /***/
    },
    /* 192 */
    /***/
    function (module, exports, __webpack_require__) {
      var Stack = __webpack_require__(94),
        baseIsEqual = __webpack_require__(193)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2

      /**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
          length = index,
          noCustomizer = !customizer

        if (object == null) {
          return !length
        }
        object = Object(object)
        while (index--) {
          var data = matchData[index]
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false
          }
        }
        while (++index < length) {
          data = matchData[index]
          var key = data[0],
            objValue = object[key],
            srcValue = data[1]

          if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
              return false
            }
          } else {
            var stack = new Stack()
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack)
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false
            }
          }
        }
        return true
      }

      module.exports = baseIsMatch
      /***/
    },
    /* 193 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsEqualDeep = __webpack_require__(464),
        isObjectLike = __webpack_require__(15)

      /**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)
      }

      module.exports = baseIsEqual
      /***/
    },
    /* 194 */
    /***/
    function (module, exports, __webpack_require__) {
      var SetCache = __webpack_require__(102),
        arraySome = __webpack_require__(467),
        cacheHas = __webpack_require__(103)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2

      /**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length

        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(array)
        if (stacked && stack.get(other)) {
          return stacked == other
        }
        var index = -1,
          result = true,
          seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined

        stack.set(array, other)
        stack.set(other, array)

        // Ignore non-index properties.
        while (++index < arrLength) {
          var arrValue = array[index],
            othValue = other[index]

          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack)
          }
          if (compared !== undefined) {
            if (compared) {
              continue
            }
            result = false
            break
          }
          // Recursively compare arrays (susceptible to call stack limits).
          if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex)
                }
              })) {
              result = false
              break
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false
            break
          }
        }
        stack['delete'](array)
        stack['delete'](other)
        return result
      }

      module.exports = equalArrays
      /***/
    },
    /* 195 */
    /***/
    function (module, exports, __webpack_require__) {
      var isStrictComparable = __webpack_require__(196),
        keys = __webpack_require__(9)

      /**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */
      function getMatchData(object) {
        var result = keys(object),
          length = result.length

        while (length--) {
          var key = result[length],
            value = object[key]

          result[length] = [key, value, isStrictComparable(value)]
        }
        return result
      }

      module.exports = getMatchData
      /***/
    },
    /* 196 */
    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(12)

      /**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */
      function isStrictComparable(value) {
        return value === value && !isObject(value)
      }

      module.exports = isStrictComparable
      /***/
    },
    /* 197 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */
      function matchesStrictComparable(key, srcValue) {
        return function (object) {
          if (object == null) {
            return false
          }
          return object[key] === srcValue && (srcValue !== undefined || key in Object(object))
        }
      }

      module.exports = matchesStrictComparable
      /***/
    },
    /* 198 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseToString = __webpack_require__(475)

      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */
      function toString(value) {
        return value == null ? '' : baseToString(value)
      }

      module.exports = toString
      /***/
    },
    /* 199 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseHasIn = __webpack_require__(476),
        hasPath = __webpack_require__(200)

      /**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn)
      }

      module.exports = hasIn
      /***/
    },
    /* 200 */
    /***/
    function (module, exports, __webpack_require__) {
      var castPath = __webpack_require__(67),
        isArguments = __webpack_require__(79),
        isArray = __webpack_require__(10),
        isIndex = __webpack_require__(55),
        isLength = __webpack_require__(78),
        toKey = __webpack_require__(44)

      /**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object)

        var index = -1,
          length = path.length,
          result = false

        while (++index < length) {
          var key = toKey(path[index])
          if (!(result = object != null && hasFunc(object, key))) {
            break
          }
          object = object[key]
        }
        if (result || ++index != length) {
          return result
        }
        length = object == null ? 0 : object.length
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object))
      }

      module.exports = hasPath
      /***/
    },
    /* 201 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1)

        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index
          }
        }
        return -1
      }

      module.exports = baseFindIndex
      /***/
    },
    /* 202 */
    /***/
    function (module, exports, __webpack_require__) {
      var createBaseFor = __webpack_require__(484)

      /**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */
      var baseFor = createBaseFor()

      module.exports = baseFor
      /***/
    },
    /* 203 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8)
      var isString = __webpack_require__(7)
      var d3Geo = __webpack_require__(0)
      var d3GeoProjection = __webpack_require__(170)
      var d3CompositeProjection = __webpack_require__(494)

      module.exports = function (projection) {
        if (isFunction(projection)) {
          return projection()
        }
        if (isString(projection)) {
          if (d3Geo[projection]) {
            return d3Geo[projection]()
          }
          if (d3GeoProjection[projection]) {
            return d3GeoProjection[projection]()
          }
          if (d3CompositeProjection[projection]) {
            return d3CompositeProjection[projection]()
          }
        }
        return null
      }
      /***/
    },
    /* 204 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _area = __webpack_require__(205)

      Object.defineProperty(exports, 'geoArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_area).default
        }
      })

      var _bounds = __webpack_require__(495)

      Object.defineProperty(exports, 'geoBounds', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bounds).default
        }
      })

      var _centroid = __webpack_require__(496)

      Object.defineProperty(exports, 'geoCentroid', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_centroid).default
        }
      })

      var _circle = __webpack_require__(206)

      Object.defineProperty(exports, 'geoCircle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_circle).default
        }
      })

      var _extent = __webpack_require__(208)

      Object.defineProperty(exports, 'geoClipExtent', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_extent).default
        }
      })

      var _distance = __webpack_require__(499)

      Object.defineProperty(exports, 'geoDistance', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_distance).default
        }
      })

      var _graticule = __webpack_require__(500)

      Object.defineProperty(exports, 'geoGraticule', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_graticule).default
        }
      })

      var _interpolate = __webpack_require__(501)

      Object.defineProperty(exports, 'geoInterpolate', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_interpolate).default
        }
      })

      var _length = __webpack_require__(212)

      Object.defineProperty(exports, 'geoLength', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_length).default
        }
      })

      var _index = __webpack_require__(502)

      Object.defineProperty(exports, 'geoPath', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index).default
        }
      })

      var _albers = __webpack_require__(215)

      Object.defineProperty(exports, 'geoAlbers', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_albers).default
        }
      })

      var _albersUsa = __webpack_require__(511)

      Object.defineProperty(exports, 'geoAlbersUsa', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_albersUsa).default
        }
      })

      var _azimuthalEqualArea = __webpack_require__(512)

      Object.defineProperty(exports, 'geoAzimuthalEqualArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_azimuthalEqualArea).default
        }
      })
      Object.defineProperty(exports, 'geoAzimuthalEqualAreaRaw', {
        enumerable: true,
        get: function get() {
          return _azimuthalEqualArea.azimuthalEqualAreaRaw
        }
      })

      var _azimuthalEquidistant = __webpack_require__(513)

      Object.defineProperty(exports, 'geoAzimuthalEquidistant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_azimuthalEquidistant).default
        }
      })
      Object.defineProperty(exports, 'geoAzimuthalEquidistantRaw', {
        enumerable: true,
        get: function get() {
          return _azimuthalEquidistant.azimuthalEquidistantRaw
        }
      })

      var _conicConformal = __webpack_require__(514)

      Object.defineProperty(exports, 'geoConicConformal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicConformal).default
        }
      })
      Object.defineProperty(exports, 'geoConicConformalRaw', {
        enumerable: true,
        get: function get() {
          return _conicConformal.conicConformalRaw
        }
      })

      var _conicEqualArea = __webpack_require__(109)

      Object.defineProperty(exports, 'geoConicEqualArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicEqualArea).default
        }
      })
      Object.defineProperty(exports, 'geoConicEqualAreaRaw', {
        enumerable: true,
        get: function get() {
          return _conicEqualArea.conicEqualAreaRaw
        }
      })

      var _conicEquidistant = __webpack_require__(515)

      Object.defineProperty(exports, 'geoConicEquidistant', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_conicEquidistant).default
        }
      })
      Object.defineProperty(exports, 'geoConicEquidistantRaw', {
        enumerable: true,
        get: function get() {
          return _conicEquidistant.conicEquidistantRaw
        }
      })

      var _equirectangular = __webpack_require__(218)

      Object.defineProperty(exports, 'geoEquirectangular', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_equirectangular).default
        }
      })
      Object.defineProperty(exports, 'geoEquirectangularRaw', {
        enumerable: true,
        get: function get() {
          return _equirectangular.equirectangularRaw
        }
      })

      var _gnomonic = __webpack_require__(516)

      Object.defineProperty(exports, 'geoGnomonic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_gnomonic).default
        }
      })
      Object.defineProperty(exports, 'geoGnomonicRaw', {
        enumerable: true,
        get: function get() {
          return _gnomonic.gnomonicRaw
        }
      })

      var _index2 = __webpack_require__(17)

      Object.defineProperty(exports, 'geoProjection', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_index2).default
        }
      })
      Object.defineProperty(exports, 'geoProjectionMutator', {
        enumerable: true,
        get: function get() {
          return _index2.projectionMutator
        }
      })

      var _mercator = __webpack_require__(112)

      Object.defineProperty(exports, 'geoMercator', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mercator).default
        }
      })
      Object.defineProperty(exports, 'geoMercatorRaw', {
        enumerable: true,
        get: function get() {
          return _mercator.mercatorRaw
        }
      })

      var _orthographic = __webpack_require__(517)

      Object.defineProperty(exports, 'geoOrthographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_orthographic).default
        }
      })
      Object.defineProperty(exports, 'geoOrthographicRaw', {
        enumerable: true,
        get: function get() {
          return _orthographic.orthographicRaw
        }
      })

      var _stereographic = __webpack_require__(518)

      Object.defineProperty(exports, 'geoStereographic', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stereographic).default
        }
      })
      Object.defineProperty(exports, 'geoStereographicRaw', {
        enumerable: true,
        get: function get() {
          return _stereographic.stereographicRaw
        }
      })

      var _transverseMercator = __webpack_require__(519)

      Object.defineProperty(exports, 'geoTransverseMercator', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transverseMercator).default
        }
      })
      Object.defineProperty(exports, 'geoTransverseMercatorRaw', {
        enumerable: true,
        get: function get() {
          return _transverseMercator.transverseMercatorRaw
        }
      })

      var _rotation = __webpack_require__(108)

      Object.defineProperty(exports, 'geoRotation', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_rotation).default
        }
      })

      var _stream = __webpack_require__(28)

      Object.defineProperty(exports, 'geoStream', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stream).default
        }
      })

      var _transform = __webpack_require__(111)

      Object.defineProperty(exports, 'geoTransform', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transform).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 205 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.areaStream = exports.areaRingSum = undefined

      exports.default = function (object) {
        areaSum.reset();
        (0, _stream2.default)(object, areaStream)
        return areaSum * 2
      }

      var _adder = __webpack_require__(45)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(4)

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var areaRingSum = exports.areaRingSum = (0, _adder2.default)()

      var areaSum = (0, _adder2.default)(),
        lambda00,
        phi00,
        lambda0,
        cosPhi0,
        sinPhi0

      var areaStream = exports.areaStream = {
        point: _noop2.default,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: function polygonStart() {
          areaRingSum.reset()
          areaStream.lineStart = areaRingStart
          areaStream.lineEnd = areaRingEnd
        },
        polygonEnd: function polygonEnd() {
          var areaRing = +areaRingSum
          areaSum.add(areaRing < 0 ? _math.tau + areaRing : areaRing)
          this.lineStart = this.lineEnd = this.point = _noop2.default
        },
        sphere: function sphere() {
          areaSum.add(_math.tau)
        }
      }

      function areaRingStart() {
        areaStream.point = areaPointFirst
      }

      function areaRingEnd() {
        areaPoint(lambda00, phi00)
      }

      function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint
        lambda00 = lambda, phi00 = phi
        lambda *= _math.radians, phi *= _math.radians
        lambda0 = lambda, cosPhi0 = (0, _math.cos)(phi = phi / 2 + _math.quarterPi), sinPhi0 = (0, _math.sin)(phi)
      }

      function areaPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        phi = phi / 2 + _math.quarterPi // half the angular distance from south pole

        // Spherical excess E for a spherical triangle with vertices: south pole,
        // previous point, current point.  Uses a formula derived from Cagnolis
        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
        var dLambda = lambda - lambda0,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = (0, _math.cos)(phi),
          sinPhi = (0, _math.sin)(phi),
          k = sinPhi0 * sinPhi,
          u = cosPhi0 * cosPhi + k * (0, _math.cos)(adLambda),
          v = k * sdLambda * (0, _math.sin)(adLambda)
        areaRingSum.add((0, _math.atan2)(v, u))

        // Advance the previous points.
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi
      }
      /***/
    },
    /* 206 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.circleStream = circleStream

      exports.default = function () {
        var center = (0, _constant2.default)([0, 0]),
          radius = (0, _constant2.default)(90),
          precision = (0, _constant2.default)(6),
          ring,
          rotate,
          stream = {
            point: point
          }

        function point(x, y) {
          ring.push(x = rotate(x, y))
          x[0] *= _math.degrees, x[1] *= _math.degrees
        }

        function circle() {
          var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * _math.radians,
            p = precision.apply(this, arguments) * _math.radians
          ring = []
          rotate = (0, _rotation.rotateRadians)(-c[0] * _math.radians, -c[1] * _math.radians, 0).invert
          circleStream(stream, r, p, 1)
          c = {
            type: 'Polygon',
            coordinates: [ring]
          }
          ring = rotate = null
          return c
        }

        circle.center = function (_) {
          return arguments.length ? (center = typeof _ === 'function' ? _ : (0, _constant2.default)([+_[0], +_[1]]), circle) : center
        }

        circle.radius = function (_) {
          return arguments.length ? (radius = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), circle) : radius
        }

        circle.precision = function (_) {
          return arguments.length ? (precision = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), circle) : precision
        }

        return circle
      }

      var _cartesian = __webpack_require__(46)

      var _constant = __webpack_require__(497)

      var _constant2 = _interopRequireDefault(_constant)

      var _math = __webpack_require__(4)

      var _rotation = __webpack_require__(108)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      // Generates a circle centered at [0, 0], with a given radius and precision.
      function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta) return
        var cosRadius = (0, _math.cos)(radius),
          sinRadius = (0, _math.sin)(radius),
          step = direction * delta
        if (t0 == null) {
          t0 = radius + direction * _math.tau
          t1 = radius - step / 2
        } else {
          t0 = circleRadius(cosRadius, t0)
          t1 = circleRadius(cosRadius, t1)
          if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math.tau
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
          point = (0, _cartesian.spherical)([cosRadius, -sinRadius * (0, _math.cos)(t), -sinRadius * (0, _math.sin)(t)])
          stream.point(point[0], point[1])
        }
      }

      // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
      function circleRadius(cosRadius, point) {
        point = (0, _cartesian.cartesian)(point), point[0] -= cosRadius;
        (0, _cartesian.cartesianNormalizeInPlace)(point)
        var radius = (0, _math.acos)(-point[1])
        return ((-point[2] < 0 ? -radius : radius) + _math.tau - _math.epsilon) % _math.tau
      }
      /***/
    },
    /* 207 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1])
        }

        if (a.invert && b.invert) {
          compose.invert = function (x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1])
          }
        }

        return compose
      }
      /***/
    },
    /* 208 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.clipExtent = clipExtent

      exports.default = function () {
        var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip

        return clip = {
          stream: function stream(_stream) {
            return cache && cacheStream === _stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = _stream)
          },
          extent: function extent(_) {
            return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [
              [x0, y0],
              [x1, y1]
            ]
          }
        }
      }

      var _math = __webpack_require__(4)

      var _buffer = __webpack_require__(209)

      var _buffer2 = _interopRequireDefault(_buffer)

      var _line = __webpack_require__(498)

      var _line2 = _interopRequireDefault(_line)

      var _polygon = __webpack_require__(210)

      var _polygon2 = _interopRequireDefault(_polygon)

      var _d3Array = __webpack_require__(14)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var clipMax = 1e9,
        clipMin = -clipMax

      // TODO Use d3-polygons polygonContains here for the ring check?
      // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

      function clipExtent(x0, y0, x1, y1) {
        function visible(x, y) {
          return x0 <= x && x <= x1 && y0 <= y && y <= y1
        }

        function interpolate(from, to, direction, stream) {
          var a = 0,
            a1 = 0
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
            do {
              stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0)
            } while ((a = (a + direction + 4) % 4) !== a1)
          } else {
            stream.point(to[0], to[1])
          }
        }

        function corner(p, direction) {
          return (0, _math.abs)(p[0] - x0) < _math.epsilon ? direction > 0 ? 0 : 3 : (0, _math.abs)(p[0] - x1) < _math.epsilon ? direction > 0 ? 2 : 1 : (0, _math.abs)(p[1] - y0) < _math.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2 // abs(p[1] - y1) < epsilon
        }

        function compareIntersection(a, b) {
          return comparePoint(a.x, b.x)
        }

        function comparePoint(a, b) {
          var ca = corner(a, 1),
            cb = corner(b, 1)
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0]
        }

        return function (stream) {
          var activeStream = stream,
            bufferStream = (0, _buffer2.default)(),
            segments,
            polygon,
            ring,
            x__,
            y__,
            v__,
            // first point
            x_,
            y_,
            v_,
            // previous point
            first,
            clean

          var clipStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: polygonStart,
            polygonEnd: polygonEnd
          }

          function point(x, y) {
            if (visible(x, y)) activeStream.point(x, y)
          }

          function polygonInside() {
            var winding = 0

            for (var i = 0, n = polygon.length; i < n; ++i) {
              for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
                a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1]
                if (a1 <= y1) {
                  if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding
                } else {
                  if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding
                }
              }
            }

            return winding
          }

          // Buffer geometry within a polygon and then clip it en masse.
          function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean = true
          }

          function polygonEnd() {
            var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = (0, _d3Array.merge)(segments)).length
            if (cleanInside || visible) {
              stream.polygonStart()
              if (cleanInside) {
                stream.lineStart()
                interpolate(null, null, 1, stream)
                stream.lineEnd()
              }
              if (visible) {
                (0, _polygon2.default)(segments, compareIntersection, startInside, interpolate, stream)
              }
              stream.polygonEnd()
            }
            activeStream = stream, segments = polygon = ring = null
          }

          function lineStart() {
            clipStream.point = linePoint
            if (polygon) polygon.push(ring = [])
            first = true
            v_ = false
            x_ = y_ = NaN
          }

          // TODO rather than special-case polygons, simply handle them separately.
          // Ideally, coincident intersection points should be jittered to avoid
          // clipping issues.
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__)
              if (v__ && v_) bufferStream.rejoin()
              segments.push(bufferStream.result())
            }
            clipStream.point = point
            if (v_) activeStream.lineEnd()
          }

          function linePoint(x, y) {
            var v = visible(x, y)
            if (polygon) ring.push([x, y])
            if (first) {
              x__ = x, y__ = y, v__ = v
              first = false
              if (v) {
                activeStream.lineStart()
                activeStream.point(x, y)
              }
            } else {
              if (v && v_) activeStream.point(x, y);
              else {
                var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))]
                if ((0, _line2.default)(a, b, x0, y0, x1, y1)) {
                  if (!v_) {
                    activeStream.lineStart()
                    activeStream.point(a[0], a[1])
                  }
                  activeStream.point(b[0], b[1])
                  if (!v) activeStream.lineEnd()
                  clean = false
                } else if (v) {
                  activeStream.lineStart()
                  activeStream.point(x, y)
                  clean = false
                }
              }
            }
            x_ = x, y_ = y, v_ = v
          }

          return clipStream
        }
      }
      /***/
    },
    /* 209 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var lines = [],
          line
        return {
          point: function point(x, y) {
            line.push([x, y])
          },
          lineStart: function lineStart() {
            lines.push(line = [])
          },
          lineEnd: _noop2.default,
          rejoin: function rejoin() {
            if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()))
          },
          result: function result() {
            var result = lines
            lines = []
            line = null
            return result
          }
        }
      }

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 210 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (segments, compareIntersection, startInside, interpolate, stream) {
        var subject = [],
          clip = [],
          i,
          n

        segments.forEach(function (segment) {
          if ((n = segment.length - 1) <= 0) return
          var n,
            p0 = segment[0],
            p1 = segment[n],
            x

          // If the first and last points of a segment are coincident, then treat as a
          // closed ring. TODO if all rings are closed, then the winding order of the
          // exterior ring should be checked.
          if ((0, _pointEqual2.default)(p0, p1)) {
            stream.lineStart()
            for (i = 0; i < n; ++i) {
              stream.point((p0 = segment[i])[0], p0[1])
            }
            stream.lineEnd()
            return
          }

          subject.push(x = new Intersection(p0, segment, null, true))
          clip.push(x.o = new Intersection(p0, null, x, false))
          subject.push(x = new Intersection(p1, segment, null, false))
          clip.push(x.o = new Intersection(p1, null, x, true))
        })

        if (!subject.length) return

        clip.sort(compareIntersection)
        link(subject)
        link(clip)

        for (i = 0, n = clip.length; i < n; ++i) {
          clip[i].e = startInside = !startInside
        }

        var start = subject[0],
          points,
          point

        while (1) {
          // Find first unvisited intersection.
          var current = start,
            isSubject = true
          while (current.v) {
            if ((current = current.n) === start) return
          }
          points = current.z
          stream.lineStart()
          do {
            current.v = current.o.v = true
            if (current.e) {
              if (isSubject) {
                for (i = 0, n = points.length; i < n; ++i) {
                  stream.point((point = points[i])[0], point[1])
                }
              } else {
                interpolate(current.x, current.n.x, 1, stream)
              }
              current = current.n
            } else {
              if (isSubject) {
                points = current.p.z
                for (i = points.length - 1; i >= 0; --i) {
                  stream.point((point = points[i])[0], point[1])
                }
              } else {
                interpolate(current.x, current.p.x, -1, stream)
              }
              current = current.p
            }
            current = current.o
            points = current.z
            isSubject = !isSubject
          } while (!current.v)
          stream.lineEnd()
        }
      }

      var _pointEqual = __webpack_require__(211)

      var _pointEqual2 = _interopRequireDefault(_pointEqual)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function Intersection(point, points, other, entry) {
        this.x = point
        this.z = points
        this.o = other // another intersection
        this.e = entry // is an entry?
        this.v = false // visited
        this.n = this.p = null // next & previous
      }

      // A generalized polygon clipping algorithm: given a polygon that has been cut
      // into its visible line segments, and rejoins the segments by interpolating
      // along the clip edge.

      function link(array) {
        if (!(n = array.length)) return
        var n,
          i = 0,
          a = array[0],
          b
        while (++i < n) {
          a.n = b = array[i]
          b.p = a
          a = b
        }
        a.n = b = array[0]
        b.p = a
      }
      /***/
    },
    /* 211 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        return (0, _math.abs)(a[0] - b[0]) < _math.epsilon && (0, _math.abs)(a[1] - b[1]) < _math.epsilon
      }

      var _math = __webpack_require__(4)
      /***/
    },
    /* 212 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object) {
        lengthSum.reset();
        (0, _stream2.default)(object, lengthStream)
        return +lengthSum
      }

      var _adder = __webpack_require__(45)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(4)

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lengthSum = (0, _adder2.default)(),
        lambda0,
        sinPhi0,
        cosPhi0

      var lengthStream = {
        sphere: _noop2.default,
        point: _noop2.default,
        lineStart: lengthLineStart,
        lineEnd: _noop2.default,
        polygonStart: _noop2.default,
        polygonEnd: _noop2.default
      }

      function lengthLineStart() {
        lengthStream.point = lengthPointFirst
        lengthStream.lineEnd = lengthLineEnd
      }

      function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = _noop2.default
      }

      function lengthPointFirst(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        lambda0 = lambda, sinPhi0 = (0, _math.sin)(phi), cosPhi0 = (0, _math.cos)(phi)
        lengthStream.point = lengthPoint
      }

      function lengthPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var sinPhi = (0, _math.sin)(phi),
          cosPhi = (0, _math.cos)(phi),
          delta = (0, _math.abs)(lambda - lambda0),
          cosDelta = (0, _math.cos)(delta),
          sinDelta = (0, _math.sin)(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta
        lengthSum.add((0, _math.atan2)((0, _math.sqrt)(x * x + y * y), z))
        lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi
      }
      /***/
    },
    /* 213 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return x
      }
      /***/
    },
    /* 214 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var x0 = Infinity,
        y0 = x0,
        x1 = -x0,
        y1 = x1

      var boundsStream = {
        point: boundsPoint,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: _noop2.default,
        polygonEnd: _noop2.default,
        result: function result() {
          var bounds = [
            [x0, y0],
            [x1, y1]
          ]
          x1 = y1 = -(y0 = x0 = Infinity)
          return bounds
        }
      }

      function boundsPoint(x, y) {
        if (x < x0) x0 = x
        if (x > x1) x1 = x
        if (y < y0) y0 = y
        if (y > y1) y1 = y
      }

      exports.default = boundsStream
      /***/
    },
    /* 215 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _conicEqualArea2.default)().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7])
      }

      var _conicEqualArea = __webpack_require__(109)

      var _conicEqualArea2 = _interopRequireDefault(_conicEqualArea)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 216 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (pointVisible, clipLine, interpolate, start) {
        return function (rotate, sink) {
          var line = clipLine(sink),
            rotatedStart = rotate.invert(start[0], start[1]),
            ringBuffer = (0, _buffer2.default)(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring

          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function polygonStart() {
              clip.point = pointRing
              clip.lineStart = ringStart
              clip.lineEnd = ringEnd
              segments = []
              polygon = []
            },
            polygonEnd: function polygonEnd() {
              clip.point = point
              clip.lineStart = lineStart
              clip.lineEnd = lineEnd
              segments = (0, _d3Array.merge)(segments)
              var startInside = (0, _polygonContains2.default)(polygon, rotatedStart)
              if (segments.length) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                (0, _polygon2.default)(segments, compareIntersection, startInside, interpolate, sink)
              } else if (startInside) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true
                sink.lineStart()
                interpolate(null, null, 1, sink)
                sink.lineEnd()
              }
              if (polygonStarted) sink.polygonEnd(), polygonStarted = false
              segments = polygon = null
            },
            sphere: function sphere() {
              sink.polygonStart()
              sink.lineStart()
              interpolate(null, null, 1, sink)
              sink.lineEnd()
              sink.polygonEnd()
            }
          }

          function point(lambda, phi) {
            var point = rotate(lambda, phi)
            if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi)
          }

          function pointLine(lambda, phi) {
            var point = rotate(lambda, phi)
            line.point(point[0], point[1])
          }

          function lineStart() {
            clip.point = pointLine
            line.lineStart()
          }

          function lineEnd() {
            clip.point = point
            line.lineEnd()
          }

          function pointRing(lambda, phi) {
            ring.push([lambda, phi])
            var point = rotate(lambda, phi)
            ringSink.point(point[0], point[1])
          }

          function ringStart() {
            ringSink.lineStart()
            ring = []
          }

          function ringEnd() {
            pointRing(ring[0][0], ring[0][1])
            ringSink.lineEnd()

            var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i,
              n = ringSegments.length,
              m,
              segment,
              point

            ring.pop()
            polygon.push(ring)
            ring = null

            if (!n) return

            // No intersections.
            if (clean & 1) {
              segment = ringSegments[0]
              if ((m = segment.length - 1) > 0) {
                if (!polygonStarted) sink.polygonStart(), polygonStarted = true
                sink.lineStart()
                for (i = 0; i < m; ++i) {
                  sink.point((point = segment[i])[0], point[1])
                }
                sink.lineEnd()
              }
              return
            }

            // Rejoin connected segments.
            // TODO reuse ringBuffer.rejoin()?
            if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()))

            segments.push(ringSegments.filter(validSegment))
          }

          return clip
        }
      }

      var _buffer = __webpack_require__(209)

      var _buffer2 = _interopRequireDefault(_buffer)

      var _polygon = __webpack_require__(210)

      var _polygon2 = _interopRequireDefault(_polygon)

      var _math = __webpack_require__(4)

      var _polygonContains = __webpack_require__(508)

      var _polygonContains2 = _interopRequireDefault(_polygonContains)

      var _d3Array = __webpack_require__(14)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function validSegment(segment) {
        return segment.length > 1
      }

      // Intersections are sorted along the clip edge. For both antimeridian cutting
      // and circle clipping, the same comparison is used.
      function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - _math.halfPi - _math.epsilon : _math.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math.halfPi - _math.epsilon : _math.halfPi - b[1])
      }
      /***/
    },
    /* 217 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.fitSize = fitSize
      exports.fitExtent = fitExtent

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      var _bounds = __webpack_require__(214)

      var _bounds2 = _interopRequireDefault(_bounds)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function fit(project, extent, object) {
        var w = extent[1][0] - extent[0][0],
          h = extent[1][1] - extent[0][1],
          clip = project.clipExtent && project.clipExtent()

        project.scale(150).translate([0, 0])

        if (clip != null) project.clipExtent(null);

        (0, _stream2.default)(object, project.stream(_bounds2.default))

        var b = _bounds2.default.result(),
          k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
          x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
          y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2

        if (clip != null) project.clipExtent(clip)

        return project.scale(k * 150).translate([x, y])
      }

      function fitSize(project) {
        return function (size, object) {
          return fit(project, [
            [0, 0], size
          ], object)
        }
      }

      function fitExtent(project) {
        return function (extent, object) {
          return fit(project, extent, object)
        }
      }
      /***/
    },
    /* 218 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.equirectangularRaw = equirectangularRaw

      exports.default = function () {
        return (0, _index2.default)(equirectangularRaw).scale(152.63)
      }

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function equirectangularRaw(lambda, phi) {
        return [lambda, phi]
      }

      equirectangularRaw.invert = equirectangularRaw
      /***/
    },
    /* 219 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseForOwn = __webpack_require__(528),
        createBaseEach = __webpack_require__(529)

      /**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */
      var baseEach = createBaseEach(baseForOwn)

      module.exports = baseEach
      /***/
    },
    /* 220 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var variance = __webpack_require__(221)

      /**
       * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
       * is the square root of the variance. This is also known as the population
       * standard deviation. It's useful for measuring the amount
       * of variation or dispersion in a set of values.
       *
       * Standard deviation is only appropriate for full-population knowledge: for
       * samples of a population, {@link sampleStandardDeviation} is
       * more appropriate.
       *
       * @param {Array<number>} x input
       * @returns {number} standard deviation
       * @example
       * variance([2, 4, 4, 4, 5, 5, 7, 9]); // => 4
       * standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]); // => 2
       */
      function standardDeviation(x /*: Array<number> */ ) /*: number */ {
        if (x.length === 1) {
          return 0
        }
        var v = variance(x)
        return Math.sqrt(v)
      }

      module.exports = standardDeviation
      /***/
    },
    /* 221 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sumNthPowerDeviations = __webpack_require__(114)

      /**
       * The [variance](http://en.wikipedia.org/wiki/Variance)
       * is the sum of squared deviations from the mean.
       *
       * This is an implementation of variance, not sample variance:
       * see the `sampleVariance` method if you want a sample measure.
       *
       * @param {Array<number>} x a population of one or more data points
       * @returns {number} variance: a value greater than or equal to zero.
       * zero indicates that all values are identical.
       * @throws {Error} if x's length is 0
       * @example
       * variance([1, 2, 3, 4, 5, 6]); // => 2.9166666666666665
       */
      function variance(x /*: Array<number> */ ) /*: number */ {
        // The variance of no numbers is null
        if (x.length === 0) {
          throw new Error('variance requires at least one data point')
        }

        // Find the mean of squared deviations between the
        // mean value and each value.
        return sumNthPowerDeviations(x, 2) / x.length
      }

      module.exports = variance
      /***/
    },
    /* 222 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
       * This method is an improvement over the classical
       * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
       * It aims at computing the sum of a list of numbers while correcting for
       * floating-point errors. Traditionally, sums are calculated as many
       * successive additions, each one with its own floating-point roundoff. These
       * losses in precision add up as the number of numbers increases. This alternative
       * algorithm is more accurate than the simple way of calculating sums by simple
       * addition.
       *
       * This runs on `O(n)`, linear time in respect to the array.
       *
       * @param {Array<number>} x input
       * @return {number} sum of all input numbers
       * @example
       * sum([1, 2, 3]); // => 6
       */
      function sum(x /*: Array<number> */ ) /*: number */ {
        // If the array is empty, we needn't bother computing its sum
        if (x.length === 0) {
          return 0
        }

        // Initializing the sum as the first number in the array
        var sum = x[0]

        // Keeping track of the floating-point error correction
        var correction = 0

        var transition

        for (var i = 1; i < x.length; i++) {
          transition = sum + x[i]

          // Here we need to update the correction in a different fashion
          // if the new absolute value is greater than the absolute sum
          if (Math.abs(sum) >= Math.abs(x[i])) {
            correction += sum - transition + x[i]
          } else {
            correction += x[i] - transition + sum
          }

          sum = transition
        }

        // Returning the corrected sum
        return sum + correction
      }

      module.exports = sum
      /***/
    },
    /* 223 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * Sort an array of numbers by their numeric value, ensuring that the
       * array is not changed in place.
       *
       * This is necessary because the default behavior of .sort
       * in JavaScript is to sort arrays as string values
       *
       *     [1, 10, 12, 102, 20].sort()
       *     // output
       *     [1, 10, 102, 12, 20]
       *
       * @param {Array<number>} x input array
       * @return {Array<number>} sorted array
       * @private
       * @example
       * numericSort([3, 2, 1]) // => [1, 2, 3]
       */
      function numericSort(x /*: Array<number> */ ) /*: Array<number> */ {
        return x
          // ensure the array is not changed in-place
          .slice()
          // comparator function that treats input as numeric
          .sort(function (a, b) {
            return a - b
          })
      }

      module.exports = numericSort
      /***/
    },
    /* 224 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
       * There can be multiple modes in a list: in the event of a tie, this
       * algorithm will return the most recently seen mode.
       *
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * This runs in `O(n)` because the input is sorted.
       *
       * @param {Array<number>} sorted a sample of one or more data points
       * @returns {number} mode
       * @throws {Error} if sorted is empty
       * @example
       * modeSorted([0, 0, 1]); // => 0
       */
      function modeSorted(sorted /*: Array<number> */ ) /*: number */ {
        // Handle edge cases:
        // The mode of an empty list is undefined
        if (sorted.length === 0) {
          throw new Error('mode requires at least one data point')
        } else if (sorted.length === 1) {
          return sorted[0]
        }

        // This assumes it is dealing with an array of size > 1, since size
        // 0 and 1 are handled immediately. Hence it starts at index 1 in the
        // array.
        var last = sorted[0],

          // store the mode as we find new modes
          value = NaN,

          // store how many times we've seen the mode
          maxSeen = 0,

          // how many times the current candidate for the mode
          // has been seen
          seenThis = 1

        // end at sorted.length + 1 to fix the case in which the mode is
        // the highest number that occurs in the sequence. the last iteration
        // compares sorted[i], which is undefined, to the highest number
        // in the series
        for (var i = 1; i < sorted.length + 1; i++) {
          // we're seeing a new number pass by
          if (sorted[i] !== last) {
            // the last number is the new mode since we saw it more
            // often than the old one
            if (seenThis > maxSeen) {
              maxSeen = seenThis
              value = last
            }
            seenThis = 1
            last = sorted[i]
            // if this isn't a new number, it's one more occurrence of
            // the potential mode
          } else {
            seenThis++
          }
        }
        return value
      }

      module.exports = modeSorted
      /***/
    },
    /* 225 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The min is the lowest number in the array. This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x sample of one or more data points
       * @throws {Error} if the the length of x is less than one
       * @returns {number} minimum value
       * @example
       * min([1, 5, -10, 100, 2]); // => -10
       */
      function min(x /*: Array<number> */ ) /*: number */ {
        if (x.length === 0) {
          throw new Error('min requires at least one data point')
        }

        var value = x[0]
        for (var i = 1; i < x.length; i++) {
          // On the first iteration of this loop, min is
          // undefined and is thus made the minimum element in the array
          if (x[i] < value) {
            value = x[i]
          }
        }
        return value
      }

      module.exports = min
      /***/
    },
    /* 226 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * This computes the maximum number in an array.
       *
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x sample of one or more data points
       * @returns {number} maximum value
       * @throws {Error} if the the length of x is less than one
       * @example
       * max([1, 2, 3, 4]);
       * // => 4
       */
      function max(x /*: Array<number> */ ) /*: number */ {
        if (x.length === 0) {
          throw new Error('max requires at least one data point')
        }

        var value = x[0]
        for (var i = 1; i < x.length; i++) {
          // On the first iteration of this loop, max is
          // undefined and is thus made the maximum element in the array
          if (x[i] > value) {
            value = x[i]
          }
        }
        return value
      }

      module.exports = max
      /***/
    },
    /* 227 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var quantile = __webpack_require__(115)

      /**
       * The [median](http://en.wikipedia.org/wiki/Median) is
       * the middle number of a list. This is often a good indicator of 'the middle'
       * when there are outliers that skew the `mean()` value.
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * The median isn't necessarily one of the elements in the list: the value
       * can be the average of two elements if the list has an even length
       * and the two central values are different.
       *
       * @param {Array<number>} x input
       * @returns {number} median value
       * @example
       * median([10, 2, 5, 100, 2, 1]); // => 3.5
       */
      function median(x /*: Array<number> */ ) /*: number */ {
        return +quantile(x, 0.5)
      }

      module.exports = median
      /***/
    },
    /* 228 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var shuffleInPlace = __webpack_require__(229)

      /**
       * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
       * is a fast way to create a random permutation of a finite set. This is
       * a function around `shuffle_in_place` that adds the guarantee that
       * it will not modify its input.
       *
       * @param {Array} x sample of 0 or more numbers
       * @param {Function} [randomSource=Math.random] an optional entropy source that
       * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
       * @return {Array} shuffled version of input
       * @example
       * var shuffled = shuffle([1, 2, 3, 4]);
       * shuffled; // = [2, 3, 1, 4] or any other random permutation
       */
      function shuffle /*: :<T> */ (x /*: Array<T> */ , randomSource /*: Function */ ) {
        // slice the original array so that it is not modified
        var sample = x.slice()

        // and then shuffle that shallow-copied array, in place
        return shuffleInPlace(sample.slice(), randomSource)
      }

      module.exports = shuffle
      /***/
    },
    /* 229 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * A [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)
       * in-place - which means that it **will change the order of the original
       * array by reference**.
       *
       * This is an algorithm that generates a random [permutation](https://en.wikipedia.org/wiki/Permutation)
       * of a set.
       *
       * @param {Array} x sample of one or more numbers
       * @param {Function} [randomSource=Math.random] an optional entropy source that
       * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
       * @returns {Array} x
       * @example
       * var x = [1, 2, 3, 4];
       * shuffleInPlace(x);
       * // x is shuffled to a value like [2, 1, 4, 3]
       */
      function shuffleInPlace(x /*: Array<any> */ , randomSource /*: Function */ ) /*: Array<any> */ {
        // a custom random number source can be provided if you want to use
        // a fixed seed or another random number generator, like
        // [random-js](https://www.npmjs.org/package/random-js)
        randomSource = randomSource || Math.random

        // store the current length of the x to determine
        // when no elements remain to shuffle.
        var length = x.length

        // temporary is used to hold an item when it is being
        // swapped between indices.
        var temporary

        // The index to swap at each stage.
        var index

        // While there are still items to shuffle
        while (length > 0) {
          // chose a random index within the subset of the array
          // that is not yet shuffled
          index = Math.floor(randomSource() * length--)

          // store the value that we'll move temporarily
          temporary = x[length]

          // swap the value at `x[length]` with `x[index]`
          x[length] = x[index]
          x[index] = temporary
        }

        return x
      }

      module.exports = shuffleInPlace
      /***/
    },
    /* 230 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * For a sorted input, counting the number of unique values
       * is possible in constant time and constant memory. This is
       * a simple implementation of the algorithm.
       *
       * Values are compared with `===`, so objects and non-primitive objects
       * are not handled in any special way.
       *
       * @param {Array<*>} x an array of any kind of value
       * @returns {number} count of unique values
       * @example
       * uniqueCountSorted([1, 2, 3]); // => 3
       * uniqueCountSorted([1, 1, 1]); // => 1
       */
      function uniqueCountSorted(x /*: Array<any> */ ) /*: number */ {
        var uniqueValueCount = 0,
          lastSeenValue
        for (var i = 0; i < x.length; i++) {
          if (i === 0 || x[i] !== lastSeenValue) {
            lastSeenValue = x[i]
            uniqueValueCount++
          }
        }
        return uniqueValueCount
      }

      module.exports = uniqueCountSorted
      /***/
    },
    /* 231 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)

      /**
       * [Sample covariance](https://en.wikipedia.org/wiki/Sample_mean_and_sampleCovariance) of two datasets:
       * how much do the two datasets move together?
       * x and y are two datasets, represented as arrays of numbers.
       *
       * @param {Array<number>} x a sample of two or more data points
       * @param {Array<number>} y a sample of two or more data points
       * @throws {Error} if x and y do not have equal lengths
       * @throws {Error} if x or y have length of one or less
       * @returns {number} sample covariance
       * @example
       * sampleCovariance([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]); // => -3.5
       */
      function sampleCovariance(x /*: Array<number> */ , y /*: Array<number> */ ) /*: number */ {
        // The two datasets must have the same length which must be more than 1
        if (x.length !== y.length) {
          throw new Error('sampleCovariance requires samples with equal lengths')
        }

        if (x.length < 2) {
          throw new Error('sampleCovariance requires at least two data points in each sample')
        }

        // determine the mean of each dataset so that we can judge each
        // value of the dataset fairly as the difference from the mean. this
        // way, if one dataset is [1, 2, 3] and [2, 3, 4], their covariance
        // does not suffer because of the difference in absolute values
        var xmean = mean(x),
          ymean = mean(y),
          sum = 0

        // for each pair of values, the covariance increases when their
        // difference from the mean is associated - if both are well above
        // or if both are well below
        // the mean, the covariance increases significantly.
        for (var i = 0; i < x.length; i++) {
          sum += (x[i] - xmean) * (y[i] - ymean)
        }

        // this is Bessels' Correction: an adjustment made to sample statistics
        // that allows for the reduced degree of freedom entailed in calculating
        // values from samples rather than complete populations.
        var besselsCorrection = x.length - 1

        // the covariance is weighted by the length of the datasets.
        return sum / besselsCorrection
      }

      module.exports = sampleCovariance
      /***/
    },
    /* 232 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sampleVariance = __webpack_require__(117)

      /**
       * The [standard deviation](http://en.wikipedia.org/wiki/Standard_deviation)
       * is the square root of the variance.
       *
       * @param {Array<number>} x input array
       * @returns {number} sample standard deviation
       * @example
       * sampleStandardDeviation([2, 4, 4, 4, 5, 5, 7, 9]).toFixed(2);
       * // => '2.14'
       */
      function sampleStandardDeviation(x /*: Array<number> */ ) /*: number */ {
        // The standard deviation of no numbers is null
        var sampleVarianceX = sampleVariance(x)
        return Math.sqrt(sampleVarianceX)
      }

      module.exports = sampleStandardDeviation
      /***/
    },
    /* 233 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * When combining two lists of values for which one already knows the means,
       * one does not have to necessary recompute the mean of the combined lists in
       * linear time. They can instead use this function to compute the combined
       * mean by providing the mean & number of values of the first list and the mean
       * & number of values of the second list.
       *
       * @since 3.0.0
       * @param {number} mean1 mean of the first list
       * @param {number} n1 number of items in the first list
       * @param {number} mean2 mean of the second list
       * @param {number} n2 number of items in the second list
       * @returns {number} the combined mean
       *
       * @example
       * combineMeans(5, 3, 4, 3); // => 4.5
       */
      function combineMeans(mean1 /*: number */ , n1 /*: number */ , mean2 /*: number */ , n2 /*: number */ ) /*: number */ {
        return (mean1 * n1 + mean2 * n2) / (n1 + n2)
      }

      module.exports = combineMeans
      /***/
    },
    /* 234 */
    /***/
    function (module, exports) {
      /* @flow */

      var SQRT_2PI = Math.sqrt(2 * Math.PI)

      function cumulativeDistribution(z) {
        var sum = z,
          tmp = z

        // 15 iterations are enough for 4-digit precision
        for (var i = 1; i < 15; i++) {
          tmp *= z * z / (2 * i + 1)
          sum += tmp
        }
        return Math.round((0.5 + sum / SQRT_2PI * Math.exp(-z * z / 2)) * 1e4) / 1e4
      }

      /**
       * A standard normal table, also called the unit normal table or Z table,
       * is a mathematical table for the values of  (phi), which are the values of
       * the cumulative distribution function of the normal distribution.
       * It is used to find the probability that a statistic is observed below,
       * above, or between values on the standard normal distribution, and by
       * extension, any normal distribution.
       *
       * The probabilities are calculated using the
       * [Cumulative distribution function](https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function).
       * The table used is the cumulative, and not cumulative from 0 to mean
       * (even though the latter has 5 digits precision, instead of 4).
       */
      var standardNormalTable /*: Array<number> */ = []

      for (var z = 0; z <= 3.09; z += 0.01) {
        standardNormalTable.push(cumulativeDistribution(z))
      }

      module.exports = standardNormalTable
      /***/
    },
    /* 235 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The Inverse [Gaussian error function](http://en.wikipedia.org/wiki/Error_function)
       * returns a numerical approximation to the value that would have caused
       * `errorFunction()` to return x.
       *
       * @param {number} x value of error function
       * @returns {number} estimated inverted value
       */
      function inverseErrorFunction(x /*: number */ ) /*: number */ {
        var a = 8 * (Math.PI - 3) / (3 * Math.PI * (4 - Math.PI))

        var inv = Math.sqrt(Math.sqrt(Math.pow(2 / (Math.PI * a) + Math.log(1 - x * x) / 2, 2) - Math.log(1 - x * x) / a) - (2 / (Math.PI * a) + Math.log(1 - x * x) / 2))

        if (x >= 0) {
          return inv
        } else {
          return -inv
        }
      }

      module.exports = inverseErrorFunction
      /***/
    },
    /* 236 */
    /***/
    function (module, exports) {
      module.exports = function (fraction) {
        var step = 1 / fraction
        var pArr = []
        for (var i = 0; i <= 1; i = i + step) {
          pArr.push(i)
        }
        return pArr
      }
      /***/
    },
    /* 237 */
    /***/
    function (module, exports, __webpack_require__) {
      var getPointAtLength = __webpack_require__(238)

      var _require = __webpack_require__(0),
        geoPath = _require.geoPath

      var cloneItems = __webpack_require__(107)

      var _require2 = __webpack_require__(2),
        GEO = _require2.GEO,
        registerConnector = _require2.registerConnector

      var geoPathGenerator = geoPath()

      function GeoJSONConnector(data, options, dataView) {
        dataView.dataType = GEO
        var features = cloneItems(data.features)

        // pre-process
        features.forEach(function (feature) {
          feature.name = feature.properties.name
          feature.longitude = []
          feature.latitude = []
          var pathData = feature.pathData = geoPathGenerator(feature)
          var points = getPointAtLength(pathData)
          points._path.forEach(function (point) {
            feature.longitude.push(point[1])
            feature.latitude.push(point[2])
          })
          var centroid = geoPathGenerator.centroid(feature)
          feature.centroidX = centroid[0]
          feature.centroidY = centroid[1]
        })

        dataView.rows = features
        return data.features
      }

      registerConnector('geo', GeoJSONConnector)
      registerConnector('geojson', GeoJSONConnector)
      registerConnector('GeoJSON', GeoJSONConnector)

      module.exports = GeoJSONConnector
      /***/
    },
    /* 238 */
    /***/
    function (module, exports, __webpack_require__) {
      var parse = __webpack_require__(586)
      var isarray = __webpack_require__(587)
      var abs = __webpack_require__(588)

      module.exports = Points

      function Points(path) {
        if (!(this instanceof Points)) return new Points(path)
        this._path = isarray(path) ? path : parse(path)
        this._path = abs(this._path)
        this._path = zToL(this._path)
      }

      Points.prototype.at = function (pos, opts) {
        return this._walk(pos, opts).pos
      }

      Points.prototype.length = function () {
        return this._walk(null).length
      }

      Points.prototype._walk = function (pos, opts) {
        var cur = [0, 0]
        var prev = [0, 0, 0]
        var len = 0
        var fudge = 1.045
        if (typeof pos === 'number') pos *= fudge

        for (var i = 0; i < this._path.length; i++) {
          var p = this._path[i]
          if (p[0] === 'M') {
            cur[0] = p[1]
            cur[1] = p[2]
            if (pos === 0) {
              return {
                length: len,
                pos: cur
              }
            }
          } else if (p[0] === 'C') {
            prev[0] = cur[0]
            prev[1] = cur[1]
            prev[2] = len

            var n = 100
            for (var j = 0; j <= n; j++) {
              var t = j / n
              var x = xof_C(p, t)
              var y = yof_C(p, t)
              len += dist(cur[0], cur[1], x, y)

              cur[0] = x
              cur[1] = y

              if (typeof pos === 'number' && len >= pos) {
                var dv = (len - pos) / (len - prev[2])

                var npos = [cur[0] * (1 - dv) + prev[0] * dv, cur[1] * (1 - dv) + prev[1] * dv]
                return {
                  length: len,
                  pos: npos
                }
              }
              prev[0] = cur[0]
              prev[1] = cur[1]
              prev[2] = len
            }
          } else if (p[0] === 'Q') {
            prev[0] = cur[0]
            prev[1] = cur[1]
            prev[2] = len

            var n = 100
            for (var j = 0; j <= n; j++) {
              var t = j / n
              var x = xof_Q(p, t)
              var y = yof_Q(p, t)
              len += dist(cur[0], cur[1], x, y)

              cur[0] = x
              cur[1] = y

              if (typeof pos === 'number' && len >= pos) {
                var dv = (len - pos) / (len - prev[2])

                var npos = [cur[0] * (1 - dv) + prev[0] * dv, cur[1] * (1 - dv) + prev[1] * dv]
                return {
                  length: len,
                  pos: npos
                }
              }
              prev[0] = cur[0]
              prev[1] = cur[1]
              prev[2] = len
            }
          } else if (p[0] === 'L') {
            prev[0] = cur[0]
            prev[1] = cur[1]
            prev[2] = len

            len += dist(cur[0], cur[1], p[1], p[2])
            cur[0] = p[1]
            cur[1] = p[2]

            if (typeof pos === 'number' && len >= pos) {
              var dv = (len - pos) / (len - prev[2])
              var npos = [cur[0] * (1 - dv) + prev[0] * dv, cur[1] * (1 - dv) + prev[1] * dv]
              return {
                length: len,
                pos: npos
              }
            }
            prev[0] = cur[0]
            prev[1] = cur[1]
            prev[2] = len
          }
        }
        return {
          length: len / fudge,
          pos: cur
        }

        function xof_C(p, t) {
          return Math.pow(1 - t, 3) * cur[0] + 3 * Math.pow(1 - t, 2) * t * p[1] + 3 * (1 - t) * Math.pow(t, 2) * p[3] + Math.pow(t, 3) * p[5]
        }

        function yof_C(p, t) {
          return Math.pow(1 - t, 3) * cur[1] + 3 * Math.pow(1 - t, 2) * t * p[2] + 3 * (1 - t) * Math.pow(t, 2) * p[4] + Math.pow(t, 3) * p[6]
        }

        function xof_Q(p, t) {
          return Math.pow(1 - t, 2) * cur[0] + 2 * (1 - t) * t * p[1] + Math.pow(t, 2) * p[3]
        }

        function yof_Q(p, t) {
          return Math.pow(1 - t, 2) * cur[1] + 2 * (1 - t) * t * p[2] + Math.pow(t, 2) * p[4]
        }
      }

      function dist(ax, ay, bx, by) {
        var x = ax - bx
        var y = ay - by
        return Math.sqrt(x * x + y * y)
      }

      // Convert 'Z' segments to 'L' segments
      function zToL(path) {
        var ret = []
        var startPoint = ['L', 0, 0]

        for (var i = 0, len = path.length; i < len; i++) {
          var pt = path[i]
          switch (pt[0]) {
            case 'M':
              startPoint = ['L', pt[1], pt[2]]
              ret.push(pt)
              break
            case 'Z':
              ret.push(startPoint)
              break
            default:
              ret.push(pt)
          }
        }
        return ret
      }
      /***/
    },
    /* 239 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.packEnclose = packEnclose

      exports.default = function (circles) {
        packEnclose(circles)
        return circles
      }

      var _enclose = __webpack_require__(240)

      var _enclose2 = _interopRequireDefault(_enclose)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function place(a, b, c) {
        var ax = a.x,
          ay = a.y,
          da = b.r + c.r,
          db = a.r + c.r,
          dx = b.x - ax,
          dy = b.y - ay,
          dc = dx * dx + dy * dy
        if (dc) {
          var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
            y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc)
          c.x = ax + x * dx + y * dy
          c.y = ay + x * dy - y * dx
        } else {
          c.x = ax + db
          c.y = ay
        }
      }

      function intersects(a, b) {
        var dx = b.x - a.x,
          dy = b.y - a.y,
          dr = a.r + b.r
        return dr * dr - 1e-6 > dx * dx + dy * dy
      }

      function score(node) {
        var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab
        return dx * dx + dy * dy
      }

      function Node(circle) {
        this._ = circle
        this.next = null
        this.previous = null
      }

      function packEnclose(circles) {
        if (!(n = circles.length)) return 0

        var a, b, c, n, aa, ca, i, j, k, sj, sk

        // Place the first circle.
        a = circles[0], a.x = 0, a.y = 0
        if (!(n > 1)) return a.r

        // Place the second circle.
        b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0
        if (!(n > 2)) return a.r + b.r

        // Place the third circle.
        place(b, a, c = circles[2])

        // Initialize the front-chain using the first three circles a, b and c.
        a = new Node(a), b = new Node(b), c = new Node(c)
        a.next = c.previous = b
        b.next = a.previous = c
        c.next = b.previous = a

        // Attempt to place each remaining circle
        pack: for (i = 3; i < n; ++i) {
          place(a._, b._, c = circles[i]), c = new Node(c)

          // Find the closest intersecting circle on the front-chain, if any.
          // Closeness is determined by linear distance along the front-chain.
          // Ahead or behind is likewise determined by linear distance.
          j = b.next, k = a.previous, sj = b._.r, sk = a._.r
          do {
            if (sj <= sk) {
              if (intersects(j._, c._)) {
                b = j, a.next = b, b.previous = a, --i
                continue pack
              }
              sj += j._.r, j = j.next
            } else {
              if (intersects(k._, c._)) {
                a = k, a.next = b, b.previous = a, --i
                continue pack
              }
              sk += k._.r, k = k.previous
            }
          } while (j !== k.next)

          // Success! Insert the new circle c between a and b.
          c.previous = a, c.next = b, a.next = b.previous = b = c

          // Compute the new closest circle pair to the centroid.
          aa = score(a)
          while ((c = c.next) !== b) {
            if ((ca = score(c)) < aa) {
              a = c, aa = ca
            }
          }
          b = a.next
        }

        // Compute the enclosing circle of the front chain.
        a = [b._], c = b;
        while ((c = c.next) !== b) {
          a.push(c._)
        }
        c = (0, _enclose2.default)(a)

        // Translate the circles to put the enclosing circle around the origin.
        for (i = 0; i < n; ++i) {
          a = circles[i], a.x -= c.x, a.y -= c.y
        }
        return c.r
      }
      /***/
    },
    /* 240 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (circles) {
        var i = 0,
          n = (circles = (0, _array.shuffle)(_array.slice.call(circles))).length,
          B = [],
          p,
          e

        while (i < n) {
          p = circles[i]
          if (e && enclosesWeak(e, p)) ++i;
          else e = encloseBasis(B = extendBasis(B, p)), i = 0
        }

        return e
      }

      var _array = __webpack_require__(604)

      function extendBasis(B, p) {
        var i, j

        if (enclosesWeakAll(p, B)) return [p]

        // If we get here then B must have at least one element.
        for (i = 0; i < B.length; ++i) {
          if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
            return [B[i], p]
          }
        }

        // If we get here then B must have at least two elements.
        for (i = 0; i < B.length - 1; ++i) {
          for (j = i + 1; j < B.length; ++j) {
            if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
              return [B[i], B[j], p]
            }
          }
        }

        // If we get here then something is very wrong.
        throw new Error()
      }

      function enclosesNot(a, b) {
        var dr = a.r - b.r,
          dx = b.x - a.x,
          dy = b.y - a.y
        return dr < 0 || dr * dr < dx * dx + dy * dy
      }

      function enclosesWeak(a, b) {
        var dr = a.r - b.r + 1e-6,
          dx = b.x - a.x,
          dy = b.y - a.y
        return dr > 0 && dr * dr > dx * dx + dy * dy
      }

      function enclosesWeakAll(a, B) {
        for (var i = 0; i < B.length; ++i) {
          if (!enclosesWeak(a, B[i])) {
            return false
          }
        }
        return true
      }

      function encloseBasis(B) {
        switch (B.length) {
          case 1:
            return encloseBasis1(B[0])
          case 2:
            return encloseBasis2(B[0], B[1])
          case 3:
            return encloseBasis3(B[0], B[1], B[2])
        }
      }

      function encloseBasis1(a) {
        return {
          x: a.x,
          y: a.y,
          r: a.r
        }
      }

      function encloseBasis2(a, b) {
        var x1 = a.x,
          y1 = a.y,
          r1 = a.r,
          x2 = b.x,
          y2 = b.y,
          r2 = b.r,
          x21 = x2 - x1,
          y21 = y2 - y1,
          r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21)
        return {
          x: (x1 + x2 + x21 / l * r21) / 2,
          y: (y1 + y2 + y21 / l * r21) / 2,
          r: (l + r1 + r2) / 2
        }
      }

      function encloseBasis3(a, b, c) {
        var x1 = a.x,
          y1 = a.y,
          r1 = a.r,
          x2 = b.x,
          y2 = b.y,
          r2 = b.r,
          x3 = c.x,
          y3 = c.y,
          r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B)
        return {
          x: x1 + xa + xb * r,
          y: y1 + ya + yb * r,
          r: r
        }
      }
      /***/
    },
    /* 241 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.constantZero = constantZero

      exports.default = function (x) {
        return function () {
          return x
        }
      }

      function constantZero() {
        return 0
      }
      /***/
    },
    /* 242 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (node) {
        node.x0 = Math.round(node.x0)
        node.y0 = Math.round(node.y0)
        node.x1 = Math.round(node.x1)
        node.y1 = Math.round(node.y1)
      }
      /***/
    },
    /* 243 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (topology) {
        var t = (0, _transform2.default)(topology.transform),
          key,
          x0 = Infinity,
          y0 = x0,
          x1 = -x0,
          y1 = -x0

        function bboxPoint(p) {
          p = t(p)
          if (p[0] < x0) x0 = p[0]
          if (p[0] > x1) x1 = p[0]
          if (p[1] < y0) y0 = p[1]
          if (p[1] > y1) y1 = p[1]
        }

        function bboxGeometry(o) {
          switch (o.type) {
            case 'GeometryCollection':
              o.geometries.forEach(bboxGeometry);
              break
            case 'Point':
              bboxPoint(o.coordinates);
              break
            case 'MultiPoint':
              o.coordinates.forEach(bboxPoint);
              break
          }
        }

        topology.arcs.forEach(function (arc) {
          var i = -1,
            n = arc.length,
            p
          while (++i < n) {
            p = t(arc[i], i)
            if (p[0] < x0) x0 = p[0]
            if (p[0] > x1) x1 = p[0]
            if (p[1] < y0) y0 = p[1]
            if (p[1] > y1) y1 = p[1]
          }
        })

        for (key in topology.objects) {
          bboxGeometry(topology.objects[key])
        }

        return [x0, y0, x1, y1]
      }

      var _transform = __webpack_require__(124)

      var _transform2 = _interopRequireDefault(_transform)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 244 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return x
      }
      /***/
    },
    /* 245 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (topology, arcs) {
        var stitchedArcs = {},
          fragmentByStart = {},
          fragmentByEnd = {},
          fragments = [],
          emptyIndex = -1

        // Stitch empty arcs first, since they may be subsumed by other arcs.
        arcs.forEach(function (i, j) {
          var arc = topology.arcs[i < 0 ? ~i : i],
            t
          if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
            t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t
          }
        })

        arcs.forEach(function (i) {
          var e = ends(i),
            start = e[0],
            end = e[1],
            f,
            g

          if (f = fragmentByEnd[start]) {
            delete fragmentByEnd[f.end]
            f.push(i)
            f.end = end
            if (g = fragmentByStart[end]) {
              delete fragmentByStart[g.start]
              var fg = g === f ? f : f.concat(g)
              fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f
            }
          } else if (f = fragmentByStart[end]) {
            delete fragmentByStart[f.start]
            f.unshift(i)
            f.start = start
            if (g = fragmentByEnd[start]) {
              delete fragmentByEnd[g.end]
              var gf = g === f ? f : g.concat(f)
              fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f
            }
          } else {
            f = [i]
            fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f
          }
        })

        function ends(i) {
          var arc = topology.arcs[i < 0 ? ~i : i],
            p0 = arc[0],
            p1
          if (topology.transform) {
            p1 = [0, 0], arc.forEach(function (dp) {
              p1[0] += dp[0], p1[1] += dp[1]
            })
          } else p1 = arc[arc.length - 1]
          return i < 0 ? [p1, p0] : [p0, p1]
        }

        function flush(fragmentByEnd, fragmentByStart) {
          for (var k in fragmentByEnd) {
            var f = fragmentByEnd[k]
            delete fragmentByStart[f.start]
            delete f.start
            delete f.end
            f.forEach(function (i) {
              stitchedArcs[i < 0 ? ~i : i] = 1
            })
            fragments.push(f)
          }
        }

        flush(fragmentByEnd, fragmentByStart)
        flush(fragmentByStart, fragmentByEnd)
        arcs.forEach(function (i) {
          if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i])
        })

        return fragments
      }
      /***/
    },
    /* 246 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (transform) {
        if (transform == null) return _identity2.default
        var x0,
          y0,
          kx = transform.scale[0],
          ky = transform.scale[1],
          dx = transform.translate[0],
          dy = transform.translate[1]
        return function (input, i) {
          if (!i) x0 = y0 = 0
          var j = 2,
            n = input.length,
            output = new Array(n),
            x1 = Math.round((input[0] - dx) / kx),
            y1 = Math.round((input[1] - dy) / ky)
          output[0] = x1 - x0, x0 = x1
          output[1] = y1 - y0, y0 = y1
          while (j < n) {
            output[j] = input[j], ++j
          }
          return output
        }
      }

      var _identity = __webpack_require__(244)

      var _identity2 = _interopRequireDefault(_identity)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 247 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIndexOf = __webpack_require__(625)

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length
        return !!length && baseIndexOf(array, value, 0) > -1
      }

      module.exports = arrayIncludes
      /***/
    },
    /* 248 */
    /***/
    function (module, exports) {
      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
          length = array == null ? 0 : array.length

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true
          }
        }
        return false
      }

      module.exports = arrayIncludesWith
      /***/
    },
    /* 249 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var arrayProto = Array.prototype

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeReverse = arrayProto.reverse

      /**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array)
      }

      module.exports = reverse
      /***/
    },
    /* 250 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.left = left
      exports.right = right
      exports.justify = justify
      exports.center = center

      var _d3Array = __webpack_require__(14)

      function targetDepth(d) {
        return d.target.depth
      }

      function left(node) {
        return node.depth
      }

      function right(node, n) {
        return n - 1 - node.height
      }

      function justify(node, n) {
        return node.sourceLinks.length ? node.depth : n - 1
      }

      function center(node) {
        return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0, _d3Array.min)(node.sourceLinks, targetDepth) - 1 : 0
      }
      /***/
    },
    /* 251 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var x0 = _point.x,
          x1 = null,
          y0 = (0, _constant2.default)(0),
          y1 = _point.y,
          defined = (0, _constant2.default)(true),
          context = null,
          curve = _linear2.default,
          output = null

        function area(data) {
          var i,
            j,
            k,
            n = data.length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n)

          if (context == null) output = curve(buffer = (0, _d3Path.path)())

          for (i = 0; i <= n; ++i) {
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
              if (defined0 = !defined0) {
                j = i
                output.areaStart()
                output.lineStart()
              } else {
                output.lineEnd()
                output.lineStart()
                for (k = i - 1; k >= j; --k) {
                  output.point(x0z[k], y0z[k])
                }
                output.lineEnd()
                output.areaEnd()
              }
            }
            if (defined0) {
              x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data)
              output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i])
            }
          }

          if (buffer) return output = null, buffer + '' || null
        }

        function arealine() {
          return (0, _line2.default)().defined(defined).curve(curve).context(context)
        }

        area.x = function (_) {
          return arguments.length ? (x0 = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), x1 = null, area) : x0
        }

        area.x0 = function (_) {
          return arguments.length ? (x0 = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), area) : x0
        }

        area.x1 = function (_) {
          return arguments.length ? (x1 = _ == null ? null : typeof _ === 'function' ? _ : (0, _constant2.default)(+_), area) : x1
        }

        area.y = function (_) {
          return arguments.length ? (y0 = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), y1 = null, area) : y0
        }

        area.y0 = function (_) {
          return arguments.length ? (y0 = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), area) : y0
        }

        area.y1 = function (_) {
          return arguments.length ? (y1 = _ == null ? null : typeof _ === 'function' ? _ : (0, _constant2.default)(+_), area) : y1
        }

        area.lineX0 = area.lineY0 = function () {
          return arealine().x(x0).y(y0)
        }

        area.lineY1 = function () {
          return arealine().x(x0).y(y1)
        }

        area.lineX1 = function () {
          return arealine().x(x1).y(y0)
        }

        area.defined = function (_) {
          return arguments.length ? (defined = typeof _ === 'function' ? _ : (0, _constant2.default)(!!_), area) : defined
        }

        area.curve = function (_) {
          return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve
        }

        area.context = function (_) {
          return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context
        }

        return area
      }

      var _d3Path = __webpack_require__(29)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _linear = __webpack_require__(72)

      var _linear2 = _interopRequireDefault(_linear)

      var _line = __webpack_require__(130)

      var _line2 = _interopRequireDefault(_line)

      var _point = __webpack_require__(131)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 252 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.curveRadialLinear = undefined
      exports.default = curveRadial

      var _linear = __webpack_require__(72)

      var _linear2 = _interopRequireDefault(_linear)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var curveRadialLinear = exports.curveRadialLinear = curveRadial(_linear2.default)

      function Radial(curve) {
        this._curve = curve
      }

      Radial.prototype = {
        areaStart: function areaStart() {
          this._curve.areaStart()
        },
        areaEnd: function areaEnd() {
          this._curve.areaEnd()
        },
        lineStart: function lineStart() {
          this._curve.lineStart()
        },
        lineEnd: function lineEnd() {
          this._curve.lineEnd()
        },
        point: function point(a, r) {
          this._curve.point(r * Math.sin(a), r * -Math.cos(a))
        }
      }

      function curveRadial(curve) {
        function radial(context) {
          return new Radial(curve(context))
        }

        radial._curve = curve

        return radial
      }
      /***/
    },
    /* 253 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.lineRadial = lineRadial

      exports.default = function () {
        return lineRadial((0, _line2.default)().curve(_radial.curveRadialLinear))
      }

      var _radial = __webpack_require__(252)

      var _radial2 = _interopRequireDefault(_radial)

      var _line = __webpack_require__(130)

      var _line2 = _interopRequireDefault(_line)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function lineRadial(l) {
        var c = l.curve

        l.angle = l.x, delete l.x
        l.radius = l.y, delete l.y

        l.curve = function (_) {
          return arguments.length ? c((0, _radial2.default)(_)) : c()._curve
        }

        return l
      }
      /***/
    },
    /* 254 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x, y) {
        return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)]
      }
      /***/
    },
    /* 255 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var slice = exports.slice = Array.prototype.slice
      /***/
    },
    /* 256 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _math = __webpack_require__(49)

      exports.default = {
        draw: function draw(context, size) {
          var r = Math.sqrt(size / _math.pi)
          context.moveTo(r, 0)
          context.arc(0, 0, r, 0, _math.tau)
        }
      }
      /***/
    },
    /* 257 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = {
        draw: function draw(context, size) {
          var r = Math.sqrt(size / 5) / 2
          context.moveTo(-3 * r, -r)
          context.lineTo(-r, -r)
          context.lineTo(-r, -3 * r)
          context.lineTo(r, -3 * r)
          context.lineTo(r, -r)
          context.lineTo(3 * r, -r)
          context.lineTo(3 * r, r)
          context.lineTo(r, r)
          context.lineTo(r, 3 * r)
          context.lineTo(-r, 3 * r)
          context.lineTo(-r, r)
          context.lineTo(-3 * r, r)
          context.closePath()
        }
      }
      /***/
    },
    /* 258 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2

      exports.default = {
        draw: function draw(context, size) {
          var y = Math.sqrt(size / tan30_2),
            x = y * tan30
          context.moveTo(0, -y)
          context.lineTo(x, 0)
          context.lineTo(0, y)
          context.lineTo(-x, 0)
          context.closePath()
        }
      }
      /***/
    },
    /* 259 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _math = __webpack_require__(49)

      var ka = 0.89081309152928522810,
        kr = Math.sin(_math.pi / 10) / Math.sin(7 * _math.pi / 10),
        kx = Math.sin(_math.tau / 10) * kr,
        ky = -Math.cos(_math.tau / 10) * kr

      exports.default = {
        draw: function draw(context, size) {
          var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r
          context.moveTo(0, -r)
          context.lineTo(x, y)
          for (var i = 1; i < 5; ++i) {
            var a = _math.tau * i / 5,
              c = Math.cos(a),
              s = Math.sin(a)
            context.lineTo(s * r, -c * r)
            context.lineTo(c * x - s * y, s * x + c * y)
          }
          context.closePath()
        }
      }
      /***/
    },
    /* 260 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = {
        draw: function draw(context, size) {
          var w = Math.sqrt(size),
            x = -w / 2
          context.rect(x, x, w, w)
        }
      }
      /***/
    },
    /* 261 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var sqrt3 = Math.sqrt(3)

      exports.default = {
        draw: function draw(context, size) {
          var y = -Math.sqrt(size / (sqrt3 * 3))
          context.moveTo(0, y * 2)
          context.lineTo(-sqrt3 * y, -y)
          context.lineTo(sqrt3 * y, -y)
          context.closePath()
        }
      }
      /***/
    },
    /* 262 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3

      exports.default = {
        draw: function draw(context, size) {
          var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1
          context.moveTo(x0, y0)
          context.lineTo(x1, y1)
          context.lineTo(x2, y2)
          context.lineTo(c * x0 - s * y0, s * x0 + c * y0)
          context.lineTo(c * x1 - s * y1, s * x1 + c * y1)
          context.lineTo(c * x2 - s * y2, s * x2 + c * y2)
          context.lineTo(c * x0 + s * y0, c * y0 - s * x0)
          context.lineTo(c * x1 + s * y1, c * y1 - s * x1)
          context.lineTo(c * x2 + s * y2, c * y2 - s * x2)
          context.closePath()
        }
      }
      /***/
    },
    /* 263 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.CardinalClosed = CardinalClosed

      var _noop = __webpack_require__(73)

      var _noop2 = _interopRequireDefault(_noop)

      var _cardinal = __webpack_require__(75)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function CardinalClosed(context, tension) {
        this._context = context
        this._k = (1 - tension) / 6
      }

      CardinalClosed.prototype = {
        areaStart: _noop2.default,
        areaEnd: _noop2.default,
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x3, this._y3)
                this._context.closePath()
                break
              }
            case 2:
              {
                this._context.lineTo(this._x3, this._y3)
                this._context.closePath()
                break
              }
            case 3:
              {
                this.point(this._x3, this._y3)
                this.point(this._x4, this._y4)
                this.point(this._x5, this._y5)
                break
              }
          }
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._x3 = x, this._y3 = y;
              break
            case 1:
              this._point = 2;
              this._context.moveTo(this._x4 = x, this._y4 = y);
              break
            case 2:
              this._point = 3;
              this._x5 = x, this._y5 = y;
              break
            default:
              (0, _cardinal.point)(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(tension) {
        function cardinal(context) {
          return new CardinalClosed(context, tension)
        }

        cardinal.tension = function (tension) {
          return custom(+tension)
        }

        return cardinal
      }(0))
      /***/
    },
    /* 264 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.CardinalOpen = CardinalOpen

      var _cardinal = __webpack_require__(75)

      function CardinalOpen(context, tension) {
        this._context = context
        this._k = (1 - tension) / 6
      }

      CardinalOpen.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3;
              this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break
            case 3:
              this._point = 4 // proceed
            default:
              (0, _cardinal.point)(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(tension) {
        function cardinal(context) {
          return new CardinalOpen(context, tension)
        }

        cardinal.tension = function (tension) {
          return custom(+tension)
        }

        return cardinal
      }(0))
      /***/
    },
    /* 265 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.createCell = createCell
      exports.cellHalfedgeStart = cellHalfedgeStart
      exports.cellHalfedgeEnd = cellHalfedgeEnd
      exports.sortCellHalfedges = sortCellHalfedges
      exports.clipCells = clipCells

      var _Edge = __webpack_require__(135)

      var _Diagram = __webpack_require__(52)

      function createCell(site) {
        return _Diagram.cells[site.index] = {
          site: site,
          halfedges: []
        }
      }

      function cellHalfedgeAngle(cell, edge) {
        var site = cell.site,
          va = edge.left,
          vb = edge.right
        if (site === vb) vb = va, va = site
        if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0])
        if (site === va) va = edge[1], vb = edge[0];
        else va = edge[0], vb = edge[1]
        return Math.atan2(va[0] - vb[0], vb[1] - va[1])
      }

      function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)]
      }

      function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)]
      }

      function sortCellHalfedges() {
        for (var i = 0, n = _Diagram.cells.length, cell, halfedges, j, m; i < n; ++i) {
          if ((cell = _Diagram.cells[i]) && (m = (halfedges = cell.halfedges).length)) {
            var index = new Array(m),
              array = new Array(m)
            for (j = 0; j < m; ++j) {
              index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram.edges[halfedges[j]])
            }
            index.sort(function (i, j) {
              return array[j] - array[i]
            })
            for (j = 0; j < m; ++j) {
              array[j] = halfedges[index[j]]
            }
            for (j = 0; j < m; ++j) {
              halfedges[j] = array[j]
            }
          }
        }
      }

      function clipCells(x0, y0, x1, y1) {
        var nCells = _Diagram.cells.length,
          iCell,
          cell,
          site,
          iHalfedge,
          halfedges,
          nHalfedges,
          start,
          startX,
          startY,
          end,
          endX,
          endY,
          cover = true

        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = _Diagram.cells[iCell]) {
            site = cell.site
            halfedges = cell.halfedges
            iHalfedge = halfedges.length

            // Remove any dangling clipped edges.
            while (iHalfedge--) {
              if (!_Diagram.edges[halfedges[iHalfedge]]) {
                halfedges.splice(iHalfedge, 1)
              }
            }

            // Insert any border edges as necessary.
            iHalfedge = 0, nHalfedges = halfedges.length
            while (iHalfedge < nHalfedges) {
              end = cellHalfedgeEnd(cell, _Diagram.edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1]
              start = cellHalfedgeStart(cell, _Diagram.edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1]
              if (Math.abs(endX - startX) > _Diagram.epsilon || Math.abs(endY - startY) > _Diagram.epsilon) {
                halfedges.splice(iHalfedge, 0, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, end, Math.abs(endX - x0) < _Diagram.epsilon && y1 - endY > _Diagram.epsilon ? [x0, Math.abs(startX - x0) < _Diagram.epsilon ? startY : y1] : Math.abs(endY - y1) < _Diagram.epsilon && x1 - endX > _Diagram.epsilon ? [Math.abs(startY - y1) < _Diagram.epsilon ? startX : x1, y1] : Math.abs(endX - x1) < _Diagram.epsilon && endY - y0 > _Diagram.epsilon ? [x1, Math.abs(startX - x1) < _Diagram.epsilon ? startY : y0] : Math.abs(endY - y0) < _Diagram.epsilon && endX - x0 > _Diagram.epsilon ? [Math.abs(startY - y0) < _Diagram.epsilon ? startX : x0, y0] : null)) - 1)
                  ++nHalfedges
              }
            }

            if (nHalfedges) cover = false
          }
        }

        // If there werent any edges, have the closest site cover the extent.
        // It doesnt matter which corner of the extent we measure!
        if (cover) {
          var dx,
            dy,
            d2,
            dc = Infinity

          for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
            if (cell = _Diagram.cells[iCell]) {
              site = cell.site
              dx = site[0] - x0
              dy = site[1] - y0
              d2 = dx * dx + dy * dy
              if (d2 < dc) dc = d2, cover = cell
            }
          }

          if (cover) {
            var v00 = [x0, y0],
              v01 = [x0, y1],
              v11 = [x1, y1],
              v10 = [x1, y0]
            cover.halfedges.push(_Diagram.edges.push((0, _Edge.createBorderEdge)(site = cover.site, v00, v01)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v01, v11)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v11, v10)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v10, v00)) - 1)
          }
        }

        // Lastly delete any cells with no edges; these were entirely clipped.
        for (iCell = 0; iCell < nCells; ++iCell) {
          if (cell = _Diagram.cells[iCell]) {
            if (!cell.halfedges.length) {
              delete _Diagram.cells[iCell]
            }
          }
        }
      }
      /***/
    },
    /* 266 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.firstCircle = undefined
      exports.attachCircle = attachCircle
      exports.detachCircle = detachCircle

      var _RedBlackTree = __webpack_require__(134)

      var _Diagram = __webpack_require__(52)

      var circlePool = []

      var firstCircle = exports.firstCircle = undefined

      function Circle() {
        (0, _RedBlackTree.RedBlackNode)(this)
        this.x = this.y = this.arc = this.site = this.cy = null
      }

      function attachCircle(arc) {
        var lArc = arc.P,
          rArc = arc.N

        if (!lArc || !rArc) return

        var lSite = lArc.site,
          cSite = arc.site,
          rSite = rArc.site

        if (lSite === rSite) return

        var bx = cSite[0],
          by = cSite[1],
          ax = lSite[0] - bx,
          ay = lSite[1] - by,
          cx = rSite[0] - bx,
          cy = rSite[1] - by

        var d = 2 * (ax * cy - ay * cx)
        if (d >= -_Diagram.epsilon2) return

        var ha = ax * ax + ay * ay,
          hc = cx * cx + cy * cy,
          x = (cy * ha - ay * hc) / d,
          y = (ax * hc - cx * ha) / d

        var circle = circlePool.pop() || new Circle()
        circle.arc = arc
        circle.site = cSite
        circle.x = x + bx
        circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y) // y bottom

        arc.circle = circle

        var before = null,
          node = _Diagram.circles._

        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L) node = node.L;
            else {
              before = node.P;
              break
            }
          } else {
            if (node.R) node = node.R;
            else {
              before = node;
              break
            }
          }
        }

        _Diagram.circles.insert(before, circle)
        if (!before) exports.firstCircle = firstCircle = circle
      }

      function detachCircle(arc) {
        var circle = arc.circle
        if (circle) {
          if (!circle.P) exports.firstCircle = firstCircle = circle.N
          _Diagram.circles.remove(circle)
          circlePool.push(circle);
          (0, _RedBlackTree.RedBlackNode)(circle)
          arc.circle = null
        }
      }
      /***/
    },
    /* 267 */
    /***/
    function (module, exports) {
      /*
       * @reference: https://github.com/jasondavies/science.js/blob/master/src/stats/kernel.js
       * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js#L16
       */
      function uniform(u) {
        return Math.abs(u) <= 1 ? 0.5 : 0
      }

      function tricubed(u) {
        var abs = 1 - Math.pow(Math.abs(u), 3)
        return Math.pow(abs, 3)
      }
      module.exports = {
        boxcar: uniform,
        cosine: function cosine(u) {
          if (Math.abs(u) <= 1) {
            return Math.PI / 4 * Math.cos(Math.PI / 2 * u)
          }
          return 0
        },
        epanechnikov: function epanechnikov(u) {
          return Math.abs(u) < 1 ? 0.75 * (1 - u * u) : 0
        },
        gaussian: function gaussian(u) {
          // return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * u * u);
          return 0.3989422804 * Math.exp(-0.5 * u * u)
        },
        quartic: function quartic(u) {
          if (Math.abs(u) < 1) {
            var tmp = 1 - u * u
            return 15 / 16 * tmp * tmp
          }
          return 0
        },
        triangular: function triangular(u) {
          var abs = Math.abs(u)
          return abs < 1 ? 1 - abs : 0
        },
        tricube: function tricube(u) {
          return Math.abs(u) < 1 ? 70 / 81 * tricubed(u) : 0
        },
        triweight: function triweight(u) {
          if (Math.abs(u) < 1) {
            var tmp = 1 - u * u
            return 35 / 32 * tmp * tmp * tmp
          }
          return 0
        },

        uniform: uniform
      }
      /***/
    },
    /* 268 */
    /***/
    function (module, exports, __webpack_require__) {
      // extra APIs
      __webpack_require__(269)
      __webpack_require__(521)
      __webpack_require__(522)
      __webpack_require__(531)

      // connectors
      __webpack_require__(578)
      __webpack_require__(581)
      __webpack_require__(585)
      __webpack_require__(237)
      __webpack_require__(589)
      __webpack_require__(590)
      __webpack_require__(612)

      // transforms
      // static
      __webpack_require__(620)
      __webpack_require__(621)
      __webpack_require__(622)
      __webpack_require__(629)
      __webpack_require__(630)
      __webpack_require__(631)
      __webpack_require__(632)
      __webpack_require__(633)
      __webpack_require__(634)
      __webpack_require__(636)
      __webpack_require__(637)
      __webpack_require__(638)
      __webpack_require__(645)
      // imputation
      __webpack_require__(646)
      __webpack_require__(647)
      // statistics
      __webpack_require__(650)
      // regression
      __webpack_require__(655)
      // binning
      __webpack_require__(657)
      __webpack_require__(658)
      __webpack_require__(659)
      __webpack_require__(660)
      // geo
      __webpack_require__(661)
      __webpack_require__(662)
      __webpack_require__(663)
      // diagram
      __webpack_require__(664)
      __webpack_require__(665)
      __webpack_require__(701)
      // hierarchy
      __webpack_require__(707)
      __webpack_require__(708)
      // tag cloud
      __webpack_require__(709)
      // kernel smoothing
      __webpack_require__(711)
      __webpack_require__(712)

      module.exports = __webpack_require__(2)
      /***/
    },
    /* 269 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)

      var _require = __webpack_require__(0),
        _geoArea = _require.geoArea,
        _geoCentroid = _require.geoCentroid,
        _geoContains = _require.geoContains,
        _geoDistance = _require.geoDistance,
        _geoLength = _require.geoLength

      var _require2 = __webpack_require__(170),
        _geoProject = _require2.geoProject

      var View = __webpack_require__(42)
      var getGeoProjection = __webpack_require__(203)

      assign(View.prototype, {
        // geo maintain
        geoArea: function geoArea(feature) {
          return _geoArea(feature)
        },
        geoAreaByName: function geoAreaByName(name) {
          return _geoArea(this.geoFeatureByName(name))
        },
        geoCentroid: function geoCentroid(feature) {
          return _geoCentroid(feature)
        },
        geoCentroidByName: function geoCentroidByName(name) {
          return _geoCentroid(this.geoFeatureByName(name))
        },
        geoDistance: function geoDistance(p1, p2) {
          return _geoDistance(p1, p2)
        },
        geoLength: function geoLength(feature) {
          return _geoLength(feature)
        },
        geoLengthByName: function geoLengthByName(name) {
          return _geoLength(this.geoFeatureByName(name))
        },
        geoContains: function geoContains(feature, position /* [longitude, latitude] */ ) {
          return _geoContains(feature, position)
        },
        geoFeatureByName: function geoFeatureByName(name) {
          var rows = this.rows
          var result = void 0
          rows.some(function (feature) {
            if (feature.name === name) {
              result = feature
              return true
            }
            return false
          })
          return result
        },
        geoFeatureByPosition: function geoFeatureByPosition(position) {
          var rows = this.rows
          var result = void 0
          rows.some(function (feature) {
            if (_geoContains(feature, position)) {
              result = feature
              return true
            }
            return false
          })
          return result
        },
        geoNameByPosition: function geoNameByPosition(position) {
          var feature = this.geoFeatureByPosition(position)
          if (feature) {
            return feature.name
          }
        },

        // projection
        geoProject: function geoProject(feature, projection) {
          projection = getGeoProjection(projection)
          return _geoProject(feature, projection)
        },
        geoProjectByName: function geoProjectByName(name, projection) {
          projection = getGeoProjection(projection)
          return _geoProject(this.geoFeatureByName(name), projection)
        },
        geoProjectPosition: function geoProjectPosition(position, projection) {
          projection = getGeoProjection(projection)
          return projection(position)
        },
        geoProjectInvert: function geoProjectInvert(point /* [x, y] */ , projection) {
          projection = getGeoProjection(projection)
          return projection.invert(point)
        }
      })
      /***/
    },
    /* 270 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8),
        isMasked = __webpack_require__(274),
        isObject = __webpack_require__(12),
        toSource = __webpack_require__(138)

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/

      /** Used for built-in method references. */
      var funcProto = Function.prototype,
        objectProto = Object.prototype

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /** Used to detect if a method is native. */
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$')

      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor
        return pattern.test(toSource(value))
      }

      module.exports = baseIsNative
      /***/
    },
    /* 271 */
    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      var g

      // This works in non-strict mode
      g = (function () {
        return this
      }())

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function('return this')() || (1, eval)('this')
      } catch (e) {
        // This works if the window reference is available
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') g = window
      }

      // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}

      module.exports = g
      /***/
    },
    /* 272 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString

      /** Built-in value references. */
      var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag]

        try {
          value[symToStringTag] = undefined
          var unmasked = true
        } catch (e) {}

        var result = nativeObjectToString.call(value)
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag
          } else {
            delete value[symToStringTag]
          }
        }
        return result
      }

      module.exports = getRawTag
      /***/
    },
    /* 273 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value)
      }

      module.exports = objectToString
      /***/
    },
    /* 274 */
    /***/
    function (module, exports, __webpack_require__) {
      var coreJsData = __webpack_require__(275)

      /** Used to detect methods masquerading as native. */
      var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '')
        return uid ? 'Symbol(src)_1.' + uid : ''
      }())

      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func
      }

      module.exports = isMasked
      /***/
    },
    /* 275 */
    /***/
    function (module, exports, __webpack_require__) {
      var root = __webpack_require__(13)

      /** Used to detect overreaching core-js shims. */
      var coreJsData = root['__core-js_shared__']

      module.exports = coreJsData
      /***/
    },
    /* 276 */
    /***/
    function (module, exports) {
      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key]
      }

      module.exports = getValue
      /***/
    },
    /* 277 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseRest = __webpack_require__(77),
        isIterateeCall = __webpack_require__(141)

      /**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */
      function createAssigner(assigner) {
        return baseRest(function (object, sources) {
          var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined

          customizer = assigner.length > 3 && typeof customizer === 'function' ? (length--, customizer) : undefined

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer
            length = 1
          }
          object = Object(object)
          while (++index < length) {
            var source = sources[index]
            if (source) {
              assigner(object, source, index, customizer)
            }
          }
          return object
        })
      }

      module.exports = createAssigner
      /***/
    },
    /* 278 */
    /***/
    function (module, exports) {
      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg)
          case 1:
            return func.call(thisArg, args[0])
          case 2:
            return func.call(thisArg, args[0], args[1])
          case 3:
            return func.call(thisArg, args[0], args[1], args[2])
        }
        return func.apply(thisArg, args)
      }

      module.exports = apply
      /***/
    },
    /* 279 */
    /***/
    function (module, exports, __webpack_require__) {
      var constant = __webpack_require__(280),
        defineProperty = __webpack_require__(136),
        identity = __webpack_require__(37)

      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var baseSetToString = !defineProperty ? identity : function (func, string) {
        return defineProperty(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(string),
          'writable': true
        })
      }

      module.exports = baseSetToString
      /***/
    },
    /* 280 */
    /***/
    function (module, exports) {
      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */
      function constant(value) {
        return function () {
          return value
        }
      }

      module.exports = constant
      /***/
    },
    /* 281 */
    /***/
    function (module, exports) {
      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
        HOT_SPAN = 16

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeNow = Date.now

      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */
      function shortOut(func) {
        var count = 0,
          lastCalled = 0

        return function () {
          var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled)

          lastCalled = stamp
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0]
            }
          } else {
            count = 0
          }
          return func.apply(undefined, arguments)
        }
      }

      module.exports = shortOut
      /***/
    },
    /* 282 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
          result = Array(n)

        while (++index < n) {
          result[index] = iteratee(index)
        }
        return result
      }

      module.exports = baseTimes
      /***/
    },
    /* 283 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]'

      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag
      }

      module.exports = baseIsArguments
      /***/
    },
    /* 284 */
    /***/
    function (module, exports) {
      /**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */
      function stubFalse() {
        return false
      }

      module.exports = stubFalse
      /***/
    },
    /* 285 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        isLength = __webpack_require__(78),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]'

      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]'

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {}
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false

      /**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
      }

      module.exports = baseIsTypedArray
      /***/
    },
    /* 286 */
    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (module) {
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
          return typeof obj
        } : function (obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
        }

        var freeGlobal = __webpack_require__(137)

        /** Detect free variable `exports`. */
        var freeExports = (false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports

        /** Detect free variable `module`. */
        var freeModule = freeExports && (false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports

        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal.process

        /** Used to access faster Node.js helpers. */
        var nodeUtil = (function () {
          try {
            return freeProcess && freeProcess.binding && freeProcess.binding('util')
          } catch (e) {}
        }())

        module.exports = nodeUtil
        /* WEBPACK VAR INJECTION */
      }.call(exports, __webpack_require__(81)(module)))
      /***/
    },
    /* 287 */
    /***/
    function (module, exports, __webpack_require__) {
      var isPrototype = __webpack_require__(56),
        nativeKeys = __webpack_require__(288)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object)
        }
        var result = []
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key)
          }
        }
        return result
      }

      module.exports = baseKeys
      /***/
    },
    /* 288 */
    /***/
    function (module, exports, __webpack_require__) {
      var overArg = __webpack_require__(144)

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeKeys = overArg(Object.keys, Object)

      module.exports = nativeKeys
      /***/
    },
    /* 289 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (feature) {
        var i, n, a, b, merged, deltaMax, delta

        phi1 = lambda1 = -(lambda0 = phi0 = Infinity)
        ranges = [];
        (0, _stream2.default)(feature, boundsStream)

        // First, sort ranges by their minimum longitudes.
        if (n = ranges.length) {
          ranges.sort(rangeCompare)

          // Then, merge any ranges that overlap.
          for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
            b = ranges[i]
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
              if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1]
              if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0]
            } else {
              merged.push(a = b)
            }
          }

          // Finally, find the largest gap between the merged ranges.
          // The final bounding box will be the inverse of this gap.
          for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
            b = merged[i]
            if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1]
          }
        }

        ranges = range = null

        return lambda0 === Infinity || phi0 === Infinity ? [
          [NaN, NaN],
          [NaN, NaN]
        ] : [
          [lambda0, phi0],
          [lambda1, phi1]
        ]
      }

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _area = __webpack_require__(145)

      var _cartesian = __webpack_require__(38)

      var _math = __webpack_require__(3)

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lambda0,
        phi0,
        lambda1,
        phi1,
        // bounds
        lambda2,
        // previous lambda-coordinate
        lambda00,
        phi00,
        // first point
        p0,
        // previous 3D point
        deltaSum = (0, _adder2.default)(),
        ranges,
        range

      var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function polygonStart() {
          boundsStream.point = boundsRingPoint
          boundsStream.lineStart = boundsRingStart
          boundsStream.lineEnd = boundsRingEnd
          deltaSum.reset()
          _area.areaStream.polygonStart()
        },
        polygonEnd: function polygonEnd() {
          _area.areaStream.polygonEnd()
          boundsStream.point = boundsPoint
          boundsStream.lineStart = boundsLineStart
          boundsStream.lineEnd = boundsLineEnd
          if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          else if (deltaSum > _math.epsilon) phi1 = 90;
          else if (deltaSum < -_math.epsilon) phi0 = -90
          range[0] = lambda0, range[1] = lambda1
        }
      }

      function boundsPoint(lambda, phi) {
        ranges.push(range = [lambda0 = lambda, lambda1 = lambda])
        if (phi < phi0) phi0 = phi
        if (phi > phi1) phi1 = phi
      }

      function linePoint(lambda, phi) {
        var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians])
        if (p0) {
          var normal = (0, _cartesian.cartesianCross)(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = (0, _cartesian.cartesianCross)(equatorial, normal);
          (0, _cartesian.cartesianNormalizeInPlace)(inflection)
          inflection = (0, _cartesian.spherical)(inflection)
          var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * _math.degrees * sign,
            phii,
            antimeridian = (0, _math.abs)(delta) > 180
          if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = inflection[1] * _math.degrees
            if (phii > phi1) phi1 = phii
          } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = -inflection[1] * _math.degrees
            if (phii < phi0) phi0 = phii
          } else {
            if (phi < phi0) phi0 = phi
            if (phi > phi1) phi1 = phi
          }
          if (antimeridian) {
            if (lambda < lambda2) {
              if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda
            } else {
              if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda
            }
          } else {
            if (lambda1 >= lambda0) {
              if (lambda < lambda0) lambda0 = lambda
              if (lambda > lambda1) lambda1 = lambda
            } else {
              if (lambda > lambda2) {
                if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda
              } else {
                if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda
              }
            }
          }
        } else {
          ranges.push(range = [lambda0 = lambda, lambda1 = lambda])
        }
        if (phi < phi0) phi0 = phi
        if (phi > phi1) phi1 = phi
        p0 = p, lambda2 = lambda
      }

      function boundsLineStart() {
        boundsStream.point = linePoint
      }

      function boundsLineEnd() {
        range[0] = lambda0, range[1] = lambda1
        boundsStream.point = boundsPoint
        p0 = null
      }

      function boundsRingPoint(lambda, phi) {
        if (p0) {
          var delta = lambda - lambda2
          deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta)
        } else {
          lambda00 = lambda, phi00 = phi
        }
        _area.areaStream.point(lambda, phi)
        linePoint(lambda, phi)
      }

      function boundsRingStart() {
        _area.areaStream.lineStart()
      }

      function boundsRingEnd() {
        boundsRingPoint(lambda00, phi00)
        _area.areaStream.lineEnd()
        if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180)
        range[0] = lambda0, range[1] = lambda1
        p0 = null
      }

      // Finds the left-right distance between two longitudes.
      // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
      // the distance between 180 to be 360.
      function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1
      }

      function rangeCompare(a, b) {
        return a[0] - b[0]
      }

      function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x
      }
      /***/
    },
    /* 290 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        (0, _stream2.default)(object, centroidStream)

        var x = X2,
          y = Y2,
          z = Z2,
          m = x * x + y * y + z * z

        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
        if (m < _math.epsilon2) {
          x = X1, y = Y1, z = Z1
          // If the feature has zero length, fall back to arithmetic mean of point vectors.
          if (W1 < _math.epsilon) x = X0, y = Y0, z = Z0
          m = x * x + y * y + z * z
          // If the feature still has an undefined ccentroid, then return.
          if (m < _math.epsilon2) return [NaN, NaN]
        }

        return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.asin)(z / (0, _math.sqrt)(m)) * _math.degrees]
      }

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
        x0, y0, z0 // previous point

      var centroidStream = {
        sphere: _noop2.default,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function polygonStart() {
          centroidStream.lineStart = centroidRingStart
          centroidStream.lineEnd = centroidRingEnd
        },
        polygonEnd: function polygonEnd() {
          centroidStream.lineStart = centroidLineStart
          centroidStream.lineEnd = centroidLineEnd
        }
      }

      // Arithmetic mean of Cartesian vectors.
      function centroidPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi)
        centroidPointCartesian(cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi))
      }

      function centroidPointCartesian(x, y, z) {
        ++W0
        X0 += (x - X0) / W0
        Y0 += (y - Y0) / W0
        Z0 += (z - Z0) / W0
      }

      function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst
      }

      function centroidLinePointFirst(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi)
        x0 = cosPhi * (0, _math.cos)(lambda)
        y0 = cosPhi * (0, _math.sin)(lambda)
        z0 = (0, _math.sin)(phi)
        centroidStream.point = centroidLinePoint
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidLinePoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi),
          x = cosPhi * (0, _math.cos)(lambda),
          y = cosPhi * (0, _math.sin)(lambda),
          z = (0, _math.sin)(phi),
          w = (0, _math.atan2)((0, _math.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z)
        W1 += w
        X1 += w * (x0 + (x0 = x))
        Y1 += w * (y0 + (y0 = y))
        Z1 += w * (z0 + (z0 = z))
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidLineEnd() {
        centroidStream.point = centroidPoint
      }

      // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
      // J. Applied Mechanics 42, 239 (1975).
      function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst
      }

      function centroidRingEnd() {
        centroidRingPoint(lambda00, phi00)
        centroidStream.point = centroidPoint
      }

      function centroidRingPointFirst(lambda, phi) {
        lambda00 = lambda, phi00 = phi
        lambda *= _math.radians, phi *= _math.radians
        centroidStream.point = centroidRingPoint
        var cosPhi = (0, _math.cos)(phi)
        x0 = cosPhi * (0, _math.cos)(lambda)
        y0 = cosPhi * (0, _math.sin)(lambda)
        z0 = (0, _math.sin)(phi)
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidRingPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi),
          x = cosPhi * (0, _math.cos)(lambda),
          y = cosPhi * (0, _math.sin)(lambda),
          z = (0, _math.sin)(phi),
          cx = y0 * z - z0 * y,
          cy = z0 * x - x0 * z,
          cz = x0 * y - y0 * x,
          m = (0, _math.sqrt)(cx * cx + cy * cy + cz * cz),
          w = (0, _math.asin)(m),
          // line weight = angle
          v = m && -w / m // area weight multiplier
        X2 += v * cx
        Y2 += v * cy
        Z2 += v * cz
        W1 += w
        X1 += w * (x0 + (x0 = x))
        Y1 += w * (y0 + (y0 = y))
        Z1 += w * (z0 + (z0 = z))
        centroidPointCartesian(x0, y0, z0)
      }
      /***/
    },
    /* 291 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return function () {
          return x
        }
      }
      /***/
    },
    /* 292 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b, x0, y0, x1, y1) {
        var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r

        r = x0 - ax
        if (!dx && r > 0) return
        r /= dx
        if (dx < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dx > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = x1 - ax
        if (!dx && r < 0) return
        r /= dx
        if (dx < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dx > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        r = y0 - ay
        if (!dy && r > 0) return
        r /= dy
        if (dy < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dy > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = y1 - ay
        if (!dy && r < 0) return
        r /= dy
        if (dy < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dy > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy
        if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy
        return true
      }
      /***/
    },
    /* 293 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values0, values1, reduce) {
        var n0 = values0.length,
          n1 = values1.length,
          values = new Array(n0 * n1),
          i0,
          i1,
          i,
          value0

        if (reduce == null) reduce = _pairs.pair

        for (i0 = i = 0; i0 < n0; ++i0) {
          for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
            values[i] = reduce(value0, values1[i1])
          }
        }

        return values
      }

      var _pairs = __webpack_require__(153)
      /***/
    },
    /* 294 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
      }
      /***/
    },
    /* 295 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var value = _identity2.default,
          domain = _extent2.default,
          threshold = _sturges2.default

        function histogram(data) {
          var i,
            n = data.length,
            x,
            values = new Array(n)

          for (i = 0; i < n; ++i) {
            values[i] = value(data[i], i, data)
          }

          var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1)

          // Convert number of thresholds into uniform thresholds.
          if (!Array.isArray(tz)) {
            tz = (0, _ticks.tickStep)(x0, x1, tz)
            tz = (0, _range2.default)(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz) // exclusive
          }

          // Remove any thresholds outside the domain.
          var m = tz.length
          while (tz[0] <= x0) {
            tz.shift(), --m
          }
          while (tz[m - 1] > x1) {
            tz.pop(), --m
          }
          var bins = new Array(m + 1),
            bin

          // Initialize bins.
          for (i = 0; i <= m; ++i) {
            bin = bins[i] = []
            bin.x0 = i > 0 ? tz[i - 1] : x0
            bin.x1 = i < m ? tz[i] : x1
          }

          // Assign data to bins by value, ignoring any outside the domain.
          for (i = 0; i < n; ++i) {
            x = values[i]
            if (x0 <= x && x <= x1) {
              bins[(0, _bisect2.default)(tz, x, 0, m)].push(data[i])
            }
          }

          return bins
        }

        histogram.value = function (_) {
          return arguments.length ? (value = typeof _ === 'function' ? _ : (0, _constant2.default)(_), histogram) : value
        }

        histogram.domain = function (_) {
          return arguments.length ? (domain = typeof _ === 'function' ? _ : (0, _constant2.default)([_[0], _[1]]), histogram) : domain
        }

        histogram.thresholds = function (_) {
          return arguments.length ? (threshold = typeof _ === 'function' ? _ : Array.isArray(_) ? (0, _constant2.default)(_array.slice.call(_)) : (0, _constant2.default)(_), histogram) : threshold
        }

        return histogram
      }

      var _array = __webpack_require__(157)

      var _bisect = __webpack_require__(151)

      var _bisect2 = _interopRequireDefault(_bisect)

      var _constant = __webpack_require__(296)

      var _constant2 = _interopRequireDefault(_constant)

      var _extent = __webpack_require__(156)

      var _extent2 = _interopRequireDefault(_extent)

      var _identity = __webpack_require__(297)

      var _identity2 = _interopRequireDefault(_identity)

      var _range = __webpack_require__(158)

      var _range2 = _interopRequireDefault(_range)

      var _ticks = __webpack_require__(159)

      var _sturges = __webpack_require__(160)

      var _sturges2 = _interopRequireDefault(_sturges)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 296 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return function () {
          return x
        }
      }
      /***/
    },
    /* 297 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return x
      }
      /***/
    },
    /* 298 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, min, max) {
        values = _array.map.call(values, _number2.default).sort(_ascending2.default)
        return Math.ceil((max - min) / (2 * ((0, _quantile2.default)(values, 0.75) - (0, _quantile2.default)(values, 0.25)) * Math.pow(values.length, -1 / 3)))
      }

      var _array = __webpack_require__(157)

      var _ascending = __webpack_require__(34)

      var _ascending2 = _interopRequireDefault(_ascending)

      var _number = __webpack_require__(39)

      var _number2 = _interopRequireDefault(_number)

      var _quantile = __webpack_require__(84)

      var _quantile2 = _interopRequireDefault(_quantile)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 299 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, min, max) {
        return Math.ceil((max - min) / (3.5 * (0, _deviation2.default)(values) * Math.pow(values.length, -1 / 3)))
      }

      var _deviation = __webpack_require__(154)

      var _deviation2 = _interopRequireDefault(_deviation)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 300 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          i = -1,
          value,
          max

        if (valueof == null) {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = values[i]) != null && value >= value) {
              max = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = values[i]) != null && value > max) {
                  max = value
                }
              }
            }
          }
        } else {
          while (++i < n) {
            // Find the first comparable value.
            if ((value = valueof(values[i], i, values)) != null && value >= value) {
              max = value
              while (++i < n) {
                // Compare the remaining values.
                if ((value = valueof(values[i], i, values)) != null && value > max) {
                  max = value
                }
              }
            }
          }
        }

        return max
      }
      /***/
    },
    /* 301 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          m = n,
          i = -1,
          value,
          sum = 0

        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(values[i]))) sum += value;
            else --m
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(valueof(values[i], i, values)))) sum += value;
            else --m
          }
        }

        if (m) return sum / m
      }

      var _number = __webpack_require__(39)

      var _number2 = _interopRequireDefault(_number)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 302 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          i = -1,
          value,
          numbers = []

        if (valueof == null) {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(values[i]))) {
              numbers.push(value)
            }
          }
        } else {
          while (++i < n) {
            if (!isNaN(value = (0, _number2.default)(valueof(values[i], i, values)))) {
              numbers.push(value)
            }
          }
        }

        return (0, _quantile2.default)(numbers.sort(_ascending2.default), 0.5)
      }

      var _ascending = __webpack_require__(34)

      var _ascending2 = _interopRequireDefault(_ascending)

      var _number = __webpack_require__(39)

      var _number2 = _interopRequireDefault(_number)

      var _quantile = __webpack_require__(84)

      var _quantile2 = _interopRequireDefault(_quantile)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 303 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (arrays) {
        var n = arrays.length,
          m,
          i = -1,
          j = 0,
          merged,
          array

        while (++i < n) {
          j += arrays[i].length
        }
        merged = new Array(j)

        while (--n >= 0) {
          array = arrays[n]
          m = array.length
          while (--m >= 0) {
            merged[--j] = array[m]
          }
        }

        return merged
      }
      /***/
    },
    /* 304 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (array, indexes) {
        var i = indexes.length,
          permutes = new Array(i)
        while (i--) {
          permutes[i] = array[indexes[i]]
        }
        return permutes
      }
      /***/
    },
    /* 305 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (values, compare) {
        if (!(n = values.length)) return
        var n,
          i = 0,
          j = 0,
          xi,
          xj = values[j]

        if (compare == null) compare = _ascending2.default

        while (++i < n) {
          if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
            xj = xi, j = i
          }
        }

        if (compare(xj, xj) === 0) return j
      }

      var _ascending = __webpack_require__(34)

      var _ascending2 = _interopRequireDefault(_ascending)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 306 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (array, i0, i1) {
        var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
          t,
          i

        while (m) {
          i = Math.random() * m-- | 0
          t = array[m + i0]
          array[m + i0] = array[i + i0]
          array[i + i0] = t
        }

        return array
      }
      /***/
    },
    /* 307 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (values, valueof) {
        var n = values.length,
          i = -1,
          value,
          sum = 0

        if (valueof == null) {
          while (++i < n) {
            if (value = +values[i]) sum += value // Note: zero and null are equivalent.
          }
        } else {
          while (++i < n) {
            if (value = +valueof(values[i], i, values)) sum += value
          }
        }

        return sum
      }
      /***/
    },
    /* 308 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _transpose2.default)(arguments)
      }

      var _transpose = __webpack_require__(162)

      var _transpose2 = _interopRequireDefault(_transpose)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 309 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object, point) {
        return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point)
      }

      var _polygonContains = __webpack_require__(163)

      var _polygonContains2 = _interopRequireDefault(_polygonContains)

      var _distance = __webpack_require__(164)

      var _distance2 = _interopRequireDefault(_distance)

      var _math = __webpack_require__(3)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var containsObjectType = {
        Feature: function Feature(object, point) {
          return containsGeometry(object.geometry, point)
        },
        FeatureCollection: function FeatureCollection(object, point) {
          var features = object.features,
            i = -1,
            n = features.length
          while (++i < n) {
            if (containsGeometry(features[i].geometry, point)) return true
          }
          return false
        }
      }

      var containsGeometryType = {
        Sphere: function Sphere() {
          return true
        },
        Point: function Point(object, point) {
          return containsPoint(object.coordinates, point)
        },
        MultiPoint: function MultiPoint(object, point) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            if (containsPoint(coordinates[i], point)) return true
          }
          return false
        },
        LineString: function LineString(object, point) {
          return containsLine(object.coordinates, point)
        },
        MultiLineString: function MultiLineString(object, point) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            if (containsLine(coordinates[i], point)) return true
          }
          return false
        },
        Polygon: function Polygon(object, point) {
          return containsPolygon(object.coordinates, point)
        },
        MultiPolygon: function MultiPolygon(object, point) {
          var coordinates = object.coordinates,
            i = -1,
            n = coordinates.length
          while (++i < n) {
            if (containsPolygon(coordinates[i], point)) return true
          }
          return false
        },
        GeometryCollection: function GeometryCollection(object, point) {
          var geometries = object.geometries,
            i = -1,
            n = geometries.length
          while (++i < n) {
            if (containsGeometry(geometries[i], point)) return true
          }
          return false
        }
      }

      function containsGeometry(geometry, point) {
        return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false
      }

      function containsPoint(coordinates, point) {
        return (0, _distance2.default)(coordinates, point) === 0
      }

      function containsLine(coordinates, point) {
        var ab = (0, _distance2.default)(coordinates[0], coordinates[1]),
          ao = (0, _distance2.default)(coordinates[0], point),
          ob = (0, _distance2.default)(point, coordinates[1])
        return ao + ob <= ab + _math.epsilon
      }

      function containsPolygon(coordinates, point) {
        return !!(0, _polygonContains2.default)(coordinates.map(ringRadians), pointRadians(point))
      }

      function ringRadians(ring) {
        return ring = ring.map(pointRadians), ring.pop(), ring
      }

      function pointRadians(point) {
        return [point[0] * _math.radians, point[1] * _math.radians]
      }
      /***/
    },
    /* 310 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = graticule
      exports.graticule10 = graticule10

      var _d3Array = __webpack_require__(14)

      var _math = __webpack_require__(3)

      function graticuleX(y0, y1, dy) {
        var y = (0, _d3Array.range)(y0, y1 - _math.epsilon, dy).concat(y1)
        return function (x) {
          return y.map(function (y) {
            return [x, y]
          })
        }
      }

      function graticuleY(x0, x1, dx) {
        var x = (0, _d3Array.range)(x0, x1 - _math.epsilon, dx).concat(x1)
        return function (y) {
          return x.map(function (x) {
            return [x, y]
          })
        }
      }

      function graticule() {
        var x1,
          x0,
          X1,
          X0,
          y1,
          y0,
          Y1,
          Y0,
          dx = 10,
          dy = dx,
          DX = 90,
          DY = 360,
          x,
          y,
          X,
          Y,
          precision = 2.5

        function graticule() {
          return {
            type: 'MultiLineString',
            coordinates: lines()
          }
        }

        function lines() {
          return (0, _d3Array.range)((0, _math.ceil)(X0 / DX) * DX, X1, DX).map(X).concat((0, _d3Array.range)((0, _math.ceil)(Y0 / DY) * DY, Y1, DY).map(Y)).concat((0, _d3Array.range)((0, _math.ceil)(x0 / dx) * dx, x1, dx).filter(function (x) {
            return (0, _math.abs)(x % DX) > _math.epsilon
          }).map(x)).concat((0, _d3Array.range)((0, _math.ceil)(y0 / dy) * dy, y1, dy).filter(function (y) {
            return (0, _math.abs)(y % DY) > _math.epsilon
          }).map(y))
        }

        graticule.lines = function () {
          return lines().map(function (coordinates) {
            return {
              type: 'LineString',
              coordinates: coordinates
            }
          })
        }

        graticule.outline = function () {
          return {
            type: 'Polygon',
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          }
        }

        graticule.extent = function (_) {
          if (!arguments.length) return graticule.extentMinor()
          return graticule.extentMajor(_).extentMinor(_)
        }

        graticule.extentMajor = function (_) {
          if (!arguments.length) return [
            [X0, Y0],
            [X1, Y1]
          ]
          X0 = +_[0][0], X1 = +_[1][0]
          Y0 = +_[0][1], Y1 = +_[1][1]
          if (X0 > X1) _ = X0, X0 = X1, X1 = _
          if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _
          return graticule.precision(precision)
        }

        graticule.extentMinor = function (_) {
          if (!arguments.length) return [
            [x0, y0],
            [x1, y1]
          ]
          x0 = +_[0][0], x1 = +_[1][0]
          y0 = +_[0][1], y1 = +_[1][1]
          if (x0 > x1) _ = x0, x0 = x1, x1 = _
          if (y0 > y1) _ = y0, y0 = y1, y1 = _
          return graticule.precision(precision)
        }

        graticule.step = function (_) {
          if (!arguments.length) return graticule.stepMinor()
          return graticule.stepMajor(_).stepMinor(_)
        }

        graticule.stepMajor = function (_) {
          if (!arguments.length) return [DX, DY]
          DX = +_[0], DY = +_[1]
          return graticule
        }

        graticule.stepMinor = function (_) {
          if (!arguments.length) return [dx, dy]
          dx = +_[0], dy = +_[1]
          return graticule
        }

        graticule.precision = function (_) {
          if (!arguments.length) return precision
          precision = +_
          x = graticuleX(y0, y1, 90)
          y = graticuleY(x0, x1, precision)
          X = graticuleX(Y0, Y1, 90)
          Y = graticuleY(X0, X1, precision)
          return graticule
        }

        return graticule.extentMajor([
          [-180, -90 + _math.epsilon],
          [180, 90 - _math.epsilon]
        ]).extentMinor([
          [-180, -80 - _math.epsilon],
          [180, 80 + _math.epsilon]
        ])
      }

      function graticule10() {
        return graticule()()
      }
      /***/
    },
    /* 311 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        var x0 = a[0] * _math.radians,
          y0 = a[1] * _math.radians,
          x1 = b[0] * _math.radians,
          y1 = b[1] * _math.radians,
          cy0 = (0, _math.cos)(y0),
          sy0 = (0, _math.sin)(y0),
          cy1 = (0, _math.cos)(y1),
          sy1 = (0, _math.sin)(y1),
          kx0 = cy0 * (0, _math.cos)(x0),
          ky0 = cy0 * (0, _math.sin)(x0),
          kx1 = cy1 * (0, _math.cos)(x1),
          ky1 = cy1 * (0, _math.sin)(x1),
          d = 2 * (0, _math.asin)((0, _math.sqrt)((0, _math.haversin)(y1 - y0) + cy0 * cy1 * (0, _math.haversin)(x1 - x0))),
          k = (0, _math.sin)(d)

        var interpolate = d ? function (t) {
          var B = (0, _math.sin)(t *= d) / k,
            A = (0, _math.sin)(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1
          return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.atan2)(z, (0, _math.sqrt)(x * x + y * y)) * _math.degrees]
        } : function () {
          return [x0 * _math.degrees, y0 * _math.degrees]
        }

        interpolate.distance = d

        return interpolate
      }

      var _math = __webpack_require__(3)
      /***/
    },
    /* 312 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (projection, context) {
        var pointRadius = 4.5,
          projectionStream,
          contextStream

        function path(object) {
          if (object) {
            if (typeof pointRadius === 'function') contextStream.pointRadius(+pointRadius.apply(this, arguments));
            (0, _stream2.default)(object, projectionStream(contextStream))
          }
          return contextStream.result()
        }

        path.area = function (object) {
          (0, _stream2.default)(object, projectionStream(_area2.default))
          return _area2.default.result()
        }

        path.measure = function (object) {
          (0, _stream2.default)(object, projectionStream(_measure2.default))
          return _measure2.default.result()
        }

        path.bounds = function (object) {
          (0, _stream2.default)(object, projectionStream(_bounds2.default))
          return _bounds2.default.result()
        }

        path.centroid = function (object) {
          (0, _stream2.default)(object, projectionStream(_centroid2.default))
          return _centroid2.default.result()
        }

        path.projection = function (_) {
          return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity2.default) : (projection = _).stream, path) : projection
        }

        path.context = function (_) {
          if (!arguments.length) return context
          contextStream = _ == null ? (context = null, new _string2.default()) : new _context2.default(context = _)
          if (typeof pointRadius !== 'function') contextStream.pointRadius(pointRadius)
          return path
        }

        path.pointRadius = function (_) {
          if (!arguments.length) return pointRadius
          pointRadius = typeof _ === 'function' ? _ : (contextStream.pointRadius(+_), +_)
          return path
        }

        return path.projection(projection).context(context)
      }

      var _identity = __webpack_require__(85)

      var _identity2 = _interopRequireDefault(_identity)

      var _stream = __webpack_require__(25)

      var _stream2 = _interopRequireDefault(_stream)

      var _area = __webpack_require__(313)

      var _area2 = _interopRequireDefault(_area)

      var _bounds = __webpack_require__(166)

      var _bounds2 = _interopRequireDefault(_bounds)

      var _centroid = __webpack_require__(314)

      var _centroid2 = _interopRequireDefault(_centroid)

      var _context = __webpack_require__(315)

      var _context2 = _interopRequireDefault(_context)

      var _measure = __webpack_require__(316)

      var _measure2 = _interopRequireDefault(_measure)

      var _string = __webpack_require__(317)

      var _string2 = _interopRequireDefault(_string)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 313 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var areaSum = (0, _adder2.default)(),
        areaRingSum = (0, _adder2.default)(),
        x00,
        y00,
        x0,
        y0

      var areaStream = {
        point: _noop2.default,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: function polygonStart() {
          areaStream.lineStart = areaRingStart
          areaStream.lineEnd = areaRingEnd
        },
        polygonEnd: function polygonEnd() {
          areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop2.default
          areaSum.add((0, _math.abs)(areaRingSum))
          areaRingSum.reset()
        },
        result: function result() {
          var area = areaSum / 2
          areaSum.reset()
          return area
        }
      }

      function areaRingStart() {
        areaStream.point = areaPointFirst
      }

      function areaPointFirst(x, y) {
        areaStream.point = areaPoint
        x00 = x0 = x, y00 = y0 = y
      }

      function areaPoint(x, y) {
        areaRingSum.add(y0 * x - x0 * y)
        x0 = x, y0 = y
      }

      function areaRingEnd() {
        areaPoint(x00, y00)
      }

      exports.default = areaStream
      /***/
    },
    /* 314 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _math = __webpack_require__(3)

      // TODO Enforce positive area for exterior, negative area for interior?

      var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00,
        y00,
        x0,
        y0

      var centroidStream = {
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function polygonStart() {
          centroidStream.lineStart = centroidRingStart
          centroidStream.lineEnd = centroidRingEnd
        },
        polygonEnd: function polygonEnd() {
          centroidStream.point = centroidPoint
          centroidStream.lineStart = centroidLineStart
          centroidStream.lineEnd = centroidLineEnd
        },
        result: function result() {
          var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN]
          X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0
          return centroid
        }
      }

      function centroidPoint(x, y) {
        X0 += x
        Y0 += y
          ++Z0
      }

      function centroidLineStart() {
        centroidStream.point = centroidPointFirstLine
      }

      function centroidPointFirstLine(x, y) {
        centroidStream.point = centroidPointLine
        centroidPoint(x0 = x, y0 = y)
      }

      function centroidPointLine(x, y) {
        var dx = x - x0,
          dy = y - y0,
          z = (0, _math.sqrt)(dx * dx + dy * dy)
        X1 += z * (x0 + x) / 2
        Y1 += z * (y0 + y) / 2
        Z1 += z
        centroidPoint(x0 = x, y0 = y)
      }

      function centroidLineEnd() {
        centroidStream.point = centroidPoint
      }

      function centroidRingStart() {
        centroidStream.point = centroidPointFirstRing
      }

      function centroidRingEnd() {
        centroidPointRing(x00, y00)
      }

      function centroidPointFirstRing(x, y) {
        centroidStream.point = centroidPointRing
        centroidPoint(x00 = x0 = x, y00 = y0 = y)
      }

      function centroidPointRing(x, y) {
        var dx = x - x0,
          dy = y - y0,
          z = (0, _math.sqrt)(dx * dx + dy * dy)

        X1 += z * (x0 + x) / 2
        Y1 += z * (y0 + y) / 2
        Z1 += z

        z = y0 * x - x0 * y
        X2 += z * (x0 + x)
        Y2 += z * (y0 + y)
        Z2 += z * 3
        centroidPoint(x0 = x, y0 = y)
      }

      exports.default = centroidStream
      /***/
    },
    /* 315 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = PathContext

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function PathContext(context) {
        this._context = context
      }

      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function pointRadius(_) {
          return this._radius = _, this
        },
        polygonStart: function polygonStart() {
          this._line = 0
        },
        polygonEnd: function polygonEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line === 0) this._context.closePath()
          this._point = NaN
        },
        point: function point(x, y) {
          switch (this._point) {
            case 0:
              {
                this._context.moveTo(x, y)
                this._point = 1
                break
              }
            case 1:
              {
                this._context.lineTo(x, y)
                break
              }
            default:
              {
                this._context.moveTo(x + this._radius, y)
                this._context.arc(x, y, this._radius, 0, _math.tau)
                break
              }
          }
        },
        result: _noop2.default
      }
      /***/
    },
    /* 316 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _adder = __webpack_require__(33)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(3)

      var _noop = __webpack_require__(21)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lengthSum = (0, _adder2.default)(),
        lengthRing,
        x00,
        y00,
        x0,
        y0

      var lengthStream = {
        point: _noop2.default,
        lineStart: function lineStart() {
          lengthStream.point = lengthPointFirst
        },
        lineEnd: function lineEnd() {
          if (lengthRing) lengthPoint(x00, y00)
          lengthStream.point = _noop2.default
        },
        polygonStart: function polygonStart() {
          lengthRing = true
        },
        polygonEnd: function polygonEnd() {
          lengthRing = null
        },
        result: function result() {
          var length = +lengthSum
          lengthSum.reset()
          return length
        }
      }

      function lengthPointFirst(x, y) {
        lengthStream.point = lengthPoint
        x00 = x0 = x, y00 = y0 = y
      }

      function lengthPoint(x, y) {
        x0 -= x, y0 -= y
        lengthSum.add((0, _math.sqrt)(x0 * x0 + y0 * y0))
        x0 = x, y0 = y
      }

      exports.default = lengthStream
      /***/
    },
    /* 317 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = PathString

      function PathString() {
        this._string = []
      }

      PathString.prototype = {
        _radius: 4.5,
        _circle: circle(4.5),
        pointRadius: function pointRadius(_) {
          if ((_ = +_) !== this._radius) this._radius = _, this._circle = null
          return this
        },
        polygonStart: function polygonStart() {
          this._line = 0
        },
        polygonEnd: function polygonEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line === 0) this._string.push('Z')
          this._point = NaN
        },
        point: function point(x, y) {
          switch (this._point) {
            case 0:
              {
                this._string.push('M', x, ',', y)
                this._point = 1
                break
              }
            case 1:
              {
                this._string.push('L', x, ',', y)
                break
              }
            default:
              {
                if (this._circle == null) this._circle = circle(this._radius)
                this._string.push('M', x, ',', y, this._circle)
                break
              }
          }
        },
        result: function result() {
          if (this._string.length) {
            var result = this._string.join('')
            this._string = []
            return result
          } else {
            return null
          }
        }
      }

      function circle(radius) {
        return 'm0,' + radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + -2 * radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + 2 * radius + 'z'
      }
      /***/
    },
    /* 318 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _index = __webpack_require__(168)

      var _index2 = _interopRequireDefault(_index)

      var _math = __webpack_require__(3)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      exports.default = (0, _index2.default)(function () {
        return true
      }, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math.pi, -_math.halfPi])

      // Takes a line and cuts into visible segments. Return values: 0 - there were
      // intersections or the line was empty; 1 - no intersections; 2 - there were
      // intersections, and the first and last segments should be rejoined.

      function clipAntimeridianLine(stream) {
        var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          _clean // no intersections

        return {
          lineStart: function lineStart() {
            stream.lineStart()
            _clean = 1
          },
          point: function point(lambda1, phi1) {
            var sign1 = lambda1 > 0 ? _math.pi : -_math.pi,
              delta = (0, _math.abs)(lambda1 - lambda0)
            if ((0, _math.abs)(delta - _math.pi) < _math.epsilon) {
              // line crosses a pole
              stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math.halfPi : -_math.halfPi)
              stream.point(sign0, phi0)
              stream.lineEnd()
              stream.lineStart()
              stream.point(sign1, phi0)
              stream.point(lambda1, phi0)
              _clean = 0
            } else if (sign0 !== sign1 && delta >= _math.pi) {
              // line crosses antimeridian
              if ((0, _math.abs)(lambda0 - sign0) < _math.epsilon) lambda0 -= sign0 * _math.epsilon // handle degeneracies
              if ((0, _math.abs)(lambda1 - sign1) < _math.epsilon) lambda1 -= sign1 * _math.epsilon
              phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1)
              stream.point(sign0, phi0)
              stream.lineEnd()
              stream.lineStart()
              stream.point(sign1, phi0)
              _clean = 0
            }
            stream.point(lambda0 = lambda1, phi0 = phi1)
            sign0 = sign1
          },
          lineEnd: function lineEnd() {
            stream.lineEnd()
            lambda0 = phi0 = NaN
          },
          clean: function clean() {
            return 2 - _clean // if intersections, rejoin first and last segments
          }
        }
      }

      function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = (0, _math.sin)(lambda0 - lambda1)
        return (0, _math.abs)(sinLambda0Lambda1) > _math.epsilon ? (0, _math.atan)(((0, _math.sin)(phi0) * (cosPhi1 = (0, _math.cos)(phi1)) * (0, _math.sin)(lambda1) - (0, _math.sin)(phi1) * (cosPhi0 = (0, _math.cos)(phi0)) * (0, _math.sin)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2
      }

      function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi
        if (from == null) {
          phi = direction * _math.halfPi
          stream.point(-_math.pi, phi)
          stream.point(0, phi)
          stream.point(_math.pi, phi)
          stream.point(_math.pi, 0)
          stream.point(_math.pi, -phi)
          stream.point(0, -phi)
          stream.point(-_math.pi, -phi)
          stream.point(-_math.pi, 0)
          stream.point(-_math.pi, phi)
        } else if ((0, _math.abs)(from[0] - to[0]) > _math.epsilon) {
          var lambda = from[0] < to[0] ? _math.pi : -_math.pi
          phi = direction * lambda / 2
          stream.point(-lambda, phi)
          stream.point(0, phi)
          stream.point(lambda, phi)
        } else {
          stream.point(to[0], to[1])
        }
      }
      /***/
    },
    /* 319 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (radius, delta) {
        var cr = (0, _math.cos)(radius),
          smallRadius = cr > 0,
          notHemisphere = (0, _math.abs)(cr) > _math.epsilon // TODO optimise for this common case

        function interpolate(from, to, direction, stream) {
          (0, _circle.circleStream)(stream, radius, delta, direction, from, to)
        }

        function visible(lambda, phi) {
          return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr
        }

        // Takes a line and cuts into visible segments. Return values used for polygon
        // clipping: 0 - there were intersections or the line was empty; 1 - no
        // intersections 2 - there were intersections, and the first and last segments
        // should be rejoined.
        function clipLine(stream) {
          var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            _clean // no intersections
          return {
            lineStart: function lineStart() {
              v00 = v0 = false
              _clean = 1
            },
            point: function point(lambda, phi) {
              var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0
              if (!point0 && (v00 = v0 = v)) stream.lineStart()
              // Handle degeneracies.
              // TODO ignore if not clipping polygons.
              if (v !== v0) {
                point2 = intersect(point0, point1)
                if (!point2 || (0, _pointEqual2.default)(point0, point2) || (0, _pointEqual2.default)(point1, point2)) {
                  point1[0] += _math.epsilon
                  point1[1] += _math.epsilon
                  v = visible(point1[0], point1[1])
                }
              }
              if (v !== v0) {
                _clean = 0
                if (v) {
                  // outside going in
                  stream.lineStart()
                  point2 = intersect(point1, point0)
                  stream.point(point2[0], point2[1])
                } else {
                  // inside going out
                  point2 = intersect(point0, point1)
                  stream.point(point2[0], point2[1])
                  stream.lineEnd()
                }
                point0 = point2
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t
                // If the codes for two points are different, or are both zero,
                // and there this segment intersects with the small circle.
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  _clean = 0
                  if (smallRadius) {
                    stream.lineStart()
                    stream.point(t[0][0], t[0][1])
                    stream.point(t[1][0], t[1][1])
                    stream.lineEnd()
                  } else {
                    stream.point(t[1][0], t[1][1])
                    stream.lineEnd()
                    stream.lineStart()
                    stream.point(t[0][0], t[0][1])
                  }
                }
              }
              if (v && (!point0 || !(0, _pointEqual2.default)(point0, point1))) {
                stream.point(point1[0], point1[1])
              }
              point0 = point1, v0 = v, c0 = c
            },
            lineEnd: function lineEnd() {
              if (v0) stream.lineEnd()
              point0 = null
            },
            // Rejoin first and last segments if there were intersections and the first
            // and last points were visible.
            clean: function clean() {
              return _clean | (v00 && v0) << 1
            }
          }
        }

        // Intersects the great circle between a and b with the clip circle.
        function intersect(a, b, two) {
          var pa = (0, _cartesian.cartesian)(a),
            pb = (0, _cartesian.cartesian)(b)

          // We have two planes, n1.p = d1 and n2.p = d2.
          // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
          var n1 = [1, 0, 0],
            // normal
            n2 = (0, _cartesian.cartesianCross)(pa, pb),
            n2n2 = (0, _cartesian.cartesianDot)(n2, n2),
            n1n2 = n2[0],
            // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2

          // Two polar points.
          if (!determinant) return !two && a

          var c1 = cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),
            A = (0, _cartesian.cartesianScale)(n1, c1),
            B = (0, _cartesian.cartesianScale)(n2, c2);
          (0, _cartesian.cartesianAddInPlace)(A, B)

          // Solve |p(t)|^2 = 1.
          var u = n1xn2,
            w = (0, _cartesian.cartesianDot)(A, u),
            uu = (0, _cartesian.cartesianDot)(u, u),
            t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1)

          if (t2 < 0) return

          var t = (0, _math.sqrt)(t2),
            q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);
          (0, _cartesian.cartesianAddInPlace)(q, A)
          q = (0, _cartesian.spherical)(q)

          if (!two) return q

          // Two intersection points.
          var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z

          if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z

          var delta = lambda1 - lambda0,
            polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,
            meridian = polar || delta < _math.epsilon

          if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z

          // Check that the first point is between a and b.
          if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
            var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);
            (0, _cartesian.cartesianAddInPlace)(q1, A)
            return [q, (0, _cartesian.spherical)(q1)]
          }
        }

        // Generates a 4-bit vector representing the location of a point relative to
        // the small circle's bounding box.
        function code(lambda, phi) {
          var r = smallRadius ? radius : _math.pi - radius,
            code = 0
          if (lambda < -r) code |= 1 // left
          else if (lambda > r) code |= 2 // right
          if (phi < -r) code |= 4 // below
          else if (phi > r) code |= 8 // above
          return code
        }

        return (0, _index2.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi])
      }

      var _cartesian = __webpack_require__(38)

      var _circle = __webpack_require__(146)

      var _math = __webpack_require__(3)

      var _pointEqual = __webpack_require__(150)

      var _pointEqual2 = _interopRequireDefault(_pointEqual)

      var _index = __webpack_require__(168)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 320 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (project, delta2) {
        return +delta2 ? resample(project, delta2) : resampleNone(project)
      }

      var _cartesian = __webpack_require__(38)

      var _math = __webpack_require__(3)

      var _transform = __webpack_require__(58)

      var maxDepth = 16,
        // maximum depth of subdivision
        cosMinDistance = (0, _math.cos)(30 * _math.radians) // cos(minimum angular distance)

      function resampleNone(project) {
        return (0, _transform.transformer)({
          point: function point(x, y) {
            x = project(x, y)
            this.stream.point(x[0], x[1])
          }
        })
      }

      function resample(project, delta2) {
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy
          if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = (0, _math.sqrt)(a * a + b * b + c * c),
              phi2 = (0, _math.asin)(c /= m),
              lambda2 = (0, _math.abs)((0, _math.abs)(c) - 1) < _math.epsilon || (0, _math.abs)(lambda0 - lambda1) < _math.epsilon ? (lambda0 + lambda1) / 2 : (0, _math.atan2)(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2
            if (dz * dz / d2 > delta2 || // perpendicular projected distance
              (0, _math.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || // midpoint close to an end
              a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              // angular distance
              resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream)
              stream.point(x2, y2)
              resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream)
            }
          }
        }
        return function (stream) {
          var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0 // previous point

          var resampleStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function polygonStart() {
              stream.polygonStart();
              resampleStream.lineStart = ringStart
            },
            polygonEnd: function polygonEnd() {
              stream.polygonEnd();
              resampleStream.lineStart = lineStart
            }
          }

          function point(x, y) {
            x = project(x, y)
            stream.point(x[0], x[1])
          }

          function lineStart() {
            x0 = NaN
            resampleStream.point = linePoint
            stream.lineStart()
          }

          function linePoint(lambda, phi) {
            var c = (0, _cartesian.cartesian)([lambda, phi]),
              p = project(lambda, phi)
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream)
            stream.point(x0, y0)
          }

          function lineEnd() {
            resampleStream.point = point
            stream.lineEnd()
          }

          function ringStart() {
            lineStart()
            resampleStream.point = ringPoint
            resampleStream.lineEnd = ringEnd
          }

          function ringPoint(lambda, phi) {
            linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0
            resampleStream.point = linePoint
          }

          function ringEnd() {
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream)
            resampleStream.lineEnd = lineEnd
            lineEnd()
          }

          return resampleStream
        }
      }
      /***/
    },
    /* 321 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.cylindricalEqualAreaRaw = cylindricalEqualAreaRaw

      var _math = __webpack_require__(3)

      function cylindricalEqualAreaRaw(phi0) {
        var cosPhi0 = (0, _math.cos)(phi0)

        function forward(lambda, phi) {
          return [lambda * cosPhi0, (0, _math.sin)(phi) / cosPhi0]
        }

        forward.invert = function (x, y) {
          return [x / cosPhi0, (0, _math.asin)(y * cosPhi0)]
        }

        return forward
      }
      /***/
    },
    /* 322 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var cache,
          cacheStream,
          lower48 = (0, _albers2.default)(),
          lower48Point,
          alaska = (0, _conicEqualArea2.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
          alaskaPoint,
          // EPSG:3338
          hawaii = (0, _conicEqualArea2.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
          hawaiiPoint,
          // ESRI:102007
          _point,
          pointStream = {
            point: function point(x, y) {
              _point = [x, y]
            }
          }

        function albersUsa(coordinates) {
          var x = coordinates[0],
            y = coordinates[1]
          return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point)
        }

        albersUsa.invert = function (coordinates) {
          var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k
          return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates)
        }

        albersUsa.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)])
        }

        albersUsa.precision = function (_) {
          if (!arguments.length) return lower48.precision()
          lower48.precision(_), alaska.precision(_), hawaii.precision(_)
          return reset()
        }

        albersUsa.scale = function (_) {
          if (!arguments.length) return lower48.scale()
          lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_)
          return albersUsa.translate(lower48.translate())
        }

        albersUsa.translate = function (_) {
          if (!arguments.length) return lower48.translate()
          var k = lower48.scale(),
            x = +_[0],
            y = +_[1]

          lower48Point = lower48.translate(_).clipExtent([
            [x - 0.455 * k, y - 0.238 * k],
            [x + 0.455 * k, y + 0.238 * k]
          ]).stream(pointStream)

          alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([
            [x - 0.425 * k + _math.epsilon, y + 0.120 * k + _math.epsilon],
            [x - 0.214 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]
          ]).stream(pointStream)

          hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([
            [x - 0.214 * k + _math.epsilon, y + 0.166 * k + _math.epsilon],
            [x - 0.115 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]
          ]).stream(pointStream)

          return reset()
        }

        albersUsa.fitExtent = function (extent, object) {
          return (0, _fit.fitExtent)(albersUsa, extent, object)
        }

        albersUsa.fitSize = function (size, object) {
          return (0, _fit.fitSize)(albersUsa, size, object)
        }

        function reset() {
          cache = cacheStream = null
          return albersUsa
        }

        return albersUsa.scale(1070)
      }

      var _math = __webpack_require__(3)

      var _albers = __webpack_require__(167)

      var _albers2 = _interopRequireDefault(_albers)

      var _conicEqualArea = __webpack_require__(86)

      var _conicEqualArea2 = _interopRequireDefault(_conicEqualArea)

      var _fit = __webpack_require__(88)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      // The projections must have mutually exclusive clip regions on the sphere,
      // as this will avoid emitting interleaving lines and polygons.
      function multiplex(streams) {
        var n = streams.length
        return {
          point: function point(x, y) {
            var i = -1;
            while (++i < n) {
              streams[i].point(x, y)
            }
          },
          sphere: function sphere() {
            var i = -1;
            while (++i < n) {
              streams[i].sphere()
            }
          },
          lineStart: function lineStart() {
            var i = -1;
            while (++i < n) {
              streams[i].lineStart()
            }
          },
          lineEnd: function lineEnd() {
            var i = -1;
            while (++i < n) {
              streams[i].lineEnd()
            }
          },
          polygonStart: function polygonStart() {
            var i = -1;
            while (++i < n) {
              streams[i].polygonStart()
            }
          },
          polygonEnd: function polygonEnd() {
            var i = -1;
            while (++i < n) {
              streams[i].polygonEnd()
            }
          }
        }
      }

      // A composite projection for the United States, configured by default for
      // 960500. The projection also works quite well at 960600 if you change the
      // scale to 1285 and adjust the translate accordingly. The set of standard
      // parallels for each region comes from USGS, which is published here:
      // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
      /***/
    },
    /* 323 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalEqualAreaRaw = undefined

      exports.default = function () {
        return (0, _index2.default)(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3)
      }

      var _math = __webpack_require__(3)

      var _azimuthal = __webpack_require__(40)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var azimuthalEqualAreaRaw = exports.azimuthalEqualAreaRaw = (0, _azimuthal.azimuthalRaw)(function (cxcy) {
        return (0, _math.sqrt)(2 / (1 + cxcy))
      })

      azimuthalEqualAreaRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return 2 * (0, _math.asin)(z / 2)
      })
      /***/
    },
    /* 324 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalEquidistantRaw = undefined

      exports.default = function () {
        return (0, _index2.default)(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3)
      }

      var _math = __webpack_require__(3)

      var _azimuthal = __webpack_require__(40)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var azimuthalEquidistantRaw = exports.azimuthalEquidistantRaw = (0, _azimuthal.azimuthalRaw)(function (c) {
        return (c = (0, _math.acos)(c)) && c / (0, _math.sin)(c)
      })

      azimuthalEquidistantRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return z
      })
      /***/
    },
    /* 325 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicConformalRaw = conicConformalRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicConformalRaw).scale(109.5).parallels([30, 30])
      }

      var _math = __webpack_require__(3)

      var _conic = __webpack_require__(87)

      var _mercator = __webpack_require__(89)

      function tany(y) {
        return (0, _math.tan)((_math.halfPi + y) / 2)
      }

      function conicConformalRaw(y0, y1) {
        var cy0 = (0, _math.cos)(y0),
          n = y0 === y1 ? (0, _math.sin)(y0) : (0, _math.log)(cy0 / (0, _math.cos)(y1)) / (0, _math.log)(tany(y1) / tany(y0)),
          f = cy0 * (0, _math.pow)(tany(y0), n) / n

        if (!n) return _mercator.mercatorRaw

        function project(x, y) {
          if (f > 0) {
            if (y < -_math.halfPi + _math.epsilon) y = -_math.halfPi + _math.epsilon
          } else {
            if (y > _math.halfPi - _math.epsilon) y = _math.halfPi - _math.epsilon
          }
          var r = f / (0, _math.pow)(tany(y), n)
          return [r * (0, _math.sin)(n * x), f - r * (0, _math.cos)(n * x)]
        }

        project.invert = function (x, y) {
          var fy = f - y,
            r = (0, _math.sign)(n) * (0, _math.sqrt)(x * x + fy * fy)
          return [(0, _math.atan2)(x, (0, _math.abs)(fy)) / n * (0, _math.sign)(fy), 2 * (0, _math.atan)((0, _math.pow)(f / r, 1 / n)) - _math.halfPi]
        }

        return project
      }
      /***/
    },
    /* 326 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicEquidistantRaw = conicEquidistantRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicEquidistantRaw).scale(131.154).center([0, 13.9389])
      }

      var _math = __webpack_require__(3)

      var _conic = __webpack_require__(87)

      var _equirectangular = __webpack_require__(169)

      function conicEquidistantRaw(y0, y1) {
        var cy0 = (0, _math.cos)(y0),
          n = y0 === y1 ? (0, _math.sin)(y0) : (cy0 - (0, _math.cos)(y1)) / (y1 - y0),
          g = cy0 / n + y0

        if ((0, _math.abs)(n) < _math.epsilon) return _equirectangular.equirectangularRaw

        function project(x, y) {
          var gy = g - y,
            nx = n * x
          return [gy * (0, _math.sin)(nx), g - gy * (0, _math.cos)(nx)]
        }

        project.invert = function (x, y) {
          var gy = g - y
          return [(0, _math.atan2)(x, (0, _math.abs)(gy)) / n * (0, _math.sign)(gy), g - (0, _math.sign)(n) * (0, _math.sqrt)(x * x + gy * gy)]
        }

        return project
      }
      /***/
    },
    /* 327 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.gnomonicRaw = gnomonicRaw

      exports.default = function () {
        return (0, _index2.default)(gnomonicRaw).scale(144.049).clipAngle(60)
      }

      var _math = __webpack_require__(3)

      var _azimuthal = __webpack_require__(40)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function gnomonicRaw(x, y) {
        var cy = (0, _math.cos)(y),
          k = (0, _math.cos)(x) * cy
        return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k]
      }

      gnomonicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.atan)
      /***/
    },
    /* 328 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var k = 1,
          tx = 0,
          ty = 0,
          sx = 1,
          sy = 1,
          transform = _identity2.default,
          // scale, translate and reflect
          x0 = null,
          y0,
          x1,
          y1,
          clip = _identity2.default,
          // clip extent
          cache,
          cacheStream,
          projection

        function reset() {
          cache = cacheStream = null
          return projection
        }

        return projection = {
          stream: function stream(_stream) {
            return cache && cacheStream === _stream ? cache : cache = transform(clip(cacheStream = _stream))
          },
          clipExtent: function clipExtent(_) {
            return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity2.default) : (0, _extent.clipExtent)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
              [x0, y0],
              [x1, y1]
            ]
          },
          scale: function scale(_) {
            return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k
          },
          translate: function translate(_) {
            return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty]
          },
          reflectX: function reflectX(_) {
            return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0
          },
          reflectY: function reflectY(_) {
            return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0
          },
          fitExtent: function fitExtent(extent, object) {
            return (0, _fit.fitExtent)(projection, extent, object)
          },
          fitSize: function fitSize(size, object) {
            return (0, _fit.fitSize)(projection, size, object)
          }
        }
      }

      var _extent = __webpack_require__(83)

      var _identity = __webpack_require__(85)

      var _identity2 = _interopRequireDefault(_identity)

      var _transform = __webpack_require__(58)

      var _fit = __webpack_require__(88)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function scaleTranslate(kx, ky, tx, ty) {
        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity2.default : (0, _transform.transformer)({
          point: function point(x, y) {
            this.stream.point(x * kx + tx, y * ky + ty)
          }
        })
      }
      /***/
    },
    /* 329 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.orthographicRaw = orthographicRaw

      exports.default = function () {
        return (0, _index2.default)(orthographicRaw).scale(249.5).clipAngle(90 + _math.epsilon)
      }

      var _math = __webpack_require__(3)

      var _azimuthal = __webpack_require__(40)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function orthographicRaw(x, y) {
        return [(0, _math.cos)(y) * (0, _math.sin)(x), (0, _math.sin)(y)]
      }

      orthographicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.asin)
      /***/
    },
    /* 330 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.stereographicRaw = stereographicRaw

      exports.default = function () {
        return (0, _index2.default)(stereographicRaw).scale(250).clipAngle(142)
      }

      var _math = __webpack_require__(3)

      var _azimuthal = __webpack_require__(40)

      var _index = __webpack_require__(16)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function stereographicRaw(x, y) {
        var cy = (0, _math.cos)(y),
          k = 1 + (0, _math.cos)(x) * cy
        return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k]
      }

      stereographicRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return 2 * (0, _math.atan)(z)
      })
      /***/
    },
    /* 331 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.transverseMercatorRaw = transverseMercatorRaw

      exports.default = function () {
        var m = (0, _mercator.mercatorProjection)(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate

        m.center = function (_) {
          return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]])
        }

        m.rotate = function (_) {
          return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90])
        }

        return rotate([0, 0, 90]).scale(159.155)
      }

      var _math = __webpack_require__(3)

      var _mercator = __webpack_require__(89)

      function transverseMercatorRaw(lambda, phi) {
        return [(0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2)), -lambda]
      }

      transverseMercatorRaw.invert = function (x, y) {
        return [-y, 2 * (0, _math.atan)((0, _math.exp)(x)) - _math.halfPi]
      }
      /***/
    },
    /* 332 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.airyRaw = airyRaw

      exports.default = function () {
        var beta = _math.halfPi,
          m = (0, _d3Geo.geoProjectionMutator)(airyRaw),
          p = m(beta)

        p.radius = function (_) {
          return arguments.length ? m(beta = _ * _math.radians) : beta * _math.degrees
        }

        return p.scale(179.976).clipAngle(147)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function airyRaw(beta) {
        var tanBeta_2 = (0, _math.tan)(beta / 2),
          b = 2 * (0, _math.log)((0, _math.cos)(beta / 2)) / (tanBeta_2 * tanBeta_2)

        function forward(x, y) {
          var cosx = (0, _math.cos)(x),
            cosy = (0, _math.cos)(y),
            siny = (0, _math.sin)(y),
            cosz = cosy * cosx,
            k = -((1 - cosz ? (0, _math.log)((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz))
          return [k * cosy * (0, _math.sin)(x), k * siny]
        }

        forward.invert = function (x, y) {
          var r = (0, _math.sqrt)(x * x + y * y),
            z = -beta / 2,
            i = 50,
            delta
          if (!r) return [0, 0]
          do {
            var z_2 = z / 2,
              cosz_2 = (0, _math.cos)(z_2),
              sinz_2 = (0, _math.sin)(z_2),
              tanz_2 = (0, _math.tan)(z_2),
              lnsecz_2 = (0, _math.log)(1 / cosz_2)
            z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2))
          } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
          var sinz = (0, _math.sin)(z)
          return [(0, _math.atan2)(x * sinz, r * (0, _math.cos)(z)), (0, _math.asin)(y * sinz / r)]
        }

        return forward
      }
      /***/
    },
    /* 333 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.armadilloRaw = armadilloRaw

      exports.default = function () {
        var phi0 = 20 * _math.radians,
          sPhi0 = phi0 >= 0 ? 1 : -1,
          tanPhi0 = (0, _math.tan)(sPhi0 * phi0),
          m = (0, _d3Geo.geoProjectionMutator)(armadilloRaw),
          p = m(phi0),
          stream_ = p.stream

        p.parallel = function (_) {
          if (!arguments.length) return phi0 * _math.degrees
          tanPhi0 = (0, _math.tan)((sPhi0 = (phi0 = _ * _math.radians) >= 0 ? 1 : -1) * phi0)
          return m(phi0)
        }

        p.stream = function (stream) {
          var rotate = p.rotate(),
            rotateStream = stream_(stream),
            sphereStream = (p.rotate([0, 0]), stream_(stream))
          p.rotate(rotate)
          rotateStream.sphere = function () {
            sphereStream.polygonStart(), sphereStream.lineStart()
            for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90) {
              sphereStream.point(lambda, sPhi0 * 90)
            }
            while (sPhi0 * (lambda -= phi0) >= -180) {
              // TODO precision?
              sphereStream.point(lambda, sPhi0 * -(0, _math.atan2)((0, _math.cos)(lambda * _math.radians / 2), tanPhi0) * _math.degrees)
            }
            sphereStream.lineEnd(), sphereStream.polygonEnd()
          }
          return rotateStream
        }

        return p.scale(218.695).center([0, 28.0974])
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function armadilloRaw(phi0) {
        var sinPhi0 = (0, _math.sin)(phi0),
          cosPhi0 = (0, _math.cos)(phi0),
          sPhi0 = phi0 >= 0 ? 1 : -1,
          tanPhi0 = (0, _math.tan)(sPhi0 * phi0),
          k = (1 + sinPhi0 - cosPhi0) / 2

        function forward(lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            cosLambda = (0, _math.cos)(lambda /= 2)
          return [(1 + cosPhi) * (0, _math.sin)(lambda), (sPhi0 * phi > -(0, _math.atan2)(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + (0, _math.sin)(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.
          ]
        }

        forward.invert = function (x, y) {
          var lambda = 0,
            phi = 0,
            i = 50
          do {
            var cosLambda = (0, _math.cos)(lambda),
              sinLambda = (0, _math.sin)(lambda),
              cosPhi = (0, _math.cos)(phi),
              sinPhi = (0, _math.sin)(phi),
              A = 1 + cosPhi,
              fx = A * sinLambda - x,
              fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y,
              dxdLambda = A * cosLambda / 2,
              dxdPhi = -sinLambda * sinPhi,
              dydLambda = sinPhi0 * A * sinLambda / 2,
              dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi,
              denominator = dxdPhi * dydLambda - dydPhi * dxdLambda,
              dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2,
              dPhi = (fx * dydLambda - fy * dxdLambda) / denominator
            lambda -= dLambda, phi -= dPhi
          } while (((0, _math.abs)(dLambda) > _math.epsilon || (0, _math.abs)(dPhi) > _math.epsilon) && --i > 0)
          return sPhi0 * phi > -(0, _math.atan2)((0, _math.cos)(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null
        }

        return forward
      }
      /***/
    },
    /* 334 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.bakerRaw = bakerRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(bakerRaw).scale(112.314)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var sqrt8 = (0, _math.sqrt)(8),
        phi0 = (0, _math.log)(1 + _math.sqrt2)

      function bakerRaw(lambda, phi) {
        var phi0 = (0, _math.abs)(phi)
        return phi0 < _math.quarterPi ? [lambda, (0, _math.log)((0, _math.tan)(_math.quarterPi + phi / 2))] : [lambda * (0, _math.cos)(phi0) * (2 * _math.sqrt2 - 1 / (0, _math.sin)(phi0)), (0, _math.sign)(phi) * (2 * _math.sqrt2 * (phi0 - _math.quarterPi) - (0, _math.log)((0, _math.tan)(phi0 / 2)))]
      }

      bakerRaw.invert = function (x, y) {
        if ((y0 = (0, _math.abs)(y)) < phi0) return [x, 2 * (0, _math.atan)((0, _math.exp)(y)) - _math.halfPi]
        var phi = _math.quarterPi,
          i = 25,
          delta,
          y0
        do {
          var cosPhi_2 = (0, _math.cos)(phi / 2),
            tanPhi_2 = (0, _math.tan)(phi / 2)
          phi -= delta = (sqrt8 * (phi - _math.quarterPi) - (0, _math.log)(tanPhi_2) - y0) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2))
        } while ((0, _math.abs)(delta) > _math.epsilon2 && --i > 0)
        return [x / ((0, _math.cos)(phi) * (sqrt8 - 1 / (0, _math.sin)(phi))), (0, _math.sign)(y) * phi]
      }
      /***/
    },
    /* 335 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.berghausRaw = berghausRaw

      exports.default = function () {
        var lobes = 5,
          m = (0, _d3Geo.geoProjectionMutator)(berghausRaw),
          p = m(lobes),
          projectionStream = p.stream,
          epsilon = 1e-2,
          cr = -(0, _math.cos)(epsilon * _math.radians),
          sr = (0, _math.sin)(epsilon * _math.radians)

        p.lobes = function (_) {
          return arguments.length ? m(lobes = +_) : lobes
        }

        p.stream = function (stream) {
          var rotate = p.rotate(),
            rotateStream = projectionStream(stream),
            sphereStream = (p.rotate([0, 0]), projectionStream(stream))
          p.rotate(rotate)
          rotateStream.sphere = function () {
            sphereStream.polygonStart(), sphereStream.lineStart()
            for (var i = 0, delta = 360 / lobes, delta0 = 2 * _math.pi / lobes, phi = 90 - 180 / lobes, phi0 = _math.halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {
              sphereStream.point((0, _math.atan2)(sr * (0, _math.cos)(phi0), cr) * _math.degrees, (0, _math.asin)(sr * (0, _math.sin)(phi0)) * _math.degrees)
              if (phi < -90) {
                sphereStream.point(-90, -180 - phi - epsilon)
                sphereStream.point(-90, -180 - phi + epsilon)
              } else {
                sphereStream.point(90, phi + epsilon)
                sphereStream.point(90, phi - epsilon)
              }
            }
            sphereStream.lineEnd(), sphereStream.polygonEnd()
          }
          return rotateStream
        }

        return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function berghausRaw(lobes) {
        var k = 2 * _math.pi / lobes

        function forward(lambda, phi) {
          var p = (0, _d3Geo.geoAzimuthalEquidistantRaw)(lambda, phi)
          if ((0, _math.abs)(lambda) > _math.halfPi) {
            // back hemisphere
            var theta = (0, _math.atan2)(p[1], p[0]),
              r = (0, _math.sqrt)(p[0] * p[0] + p[1] * p[1]),
              theta0 = k * (0, _math.round)((theta - _math.halfPi) / k) + _math.halfPi,
              alpha = (0, _math.atan2)((0, _math.sin)(theta -= theta0), 2 - (0, _math.cos)(theta)) // angle relative to lobe end
            theta = theta0 + (0, _math.asin)(_math.pi / r * (0, _math.sin)(alpha)) - alpha
            p[0] = r * (0, _math.cos)(theta)
            p[1] = r * (0, _math.sin)(theta)
          }
          return p
        }

        forward.invert = function (x, y) {
          var r = (0, _math.sqrt)(x * x + y * y)
          if (r > _math.halfPi) {
            var theta = (0, _math.atan2)(y, x),
              theta0 = k * (0, _math.round)((theta - _math.halfPi) / k) + _math.halfPi,
              s = theta > theta0 ? -1 : 1,
              A = r * (0, _math.cos)(theta0 - theta),
              cotAlpha = 1 / (0, _math.tan)(s * (0, _math.acos)((A - _math.pi) / (0, _math.sqrt)(_math.pi * (_math.pi - 2 * A) + r * r)))
            theta = theta0 + 2 * (0, _math.atan)((cotAlpha + s * (0, _math.sqrt)(cotAlpha * cotAlpha - 3)) / 3)
            x = r * (0, _math.cos)(theta), y = r * (0, _math.sin)(theta)
          }
          return _d3Geo.geoAzimuthalEquidistantRaw.invert(x, y)
        }

        return forward
      }
      /***/
    },
    /* 336 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.bonneRaw = bonneRaw

      exports.default = function () {
        return (0, _parallel2.default)(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45)
      }

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      var _math = __webpack_require__(1)

      var _sinusoidal = __webpack_require__(41)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function bonneRaw(phi0) {
        if (!phi0) return _sinusoidal.sinusoidalRaw
        var cotPhi0 = 1 / (0, _math.tan)(phi0)

        function forward(lambda, phi) {
          var rho = cotPhi0 + phi0 - phi,
            e = rho ? lambda * (0, _math.cos)(phi) / rho : rho
          return [rho * (0, _math.sin)(e), cotPhi0 - rho * (0, _math.cos)(e)]
        }

        forward.invert = function (x, y) {
          var rho = (0, _math.sqrt)(x * x + (y = cotPhi0 - y) * y),
            phi = cotPhi0 + phi0 - rho
          return [rho / (0, _math.cos)(phi) * (0, _math.atan2)(x, y), phi]
        }

        return forward
      }
      /***/
    },
    /* 337 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.bottomleyRaw = bottomleyRaw

      exports.default = function () {
        var sinPsi = 0.5,
          m = (0, _d3Geo.geoProjectionMutator)(bottomleyRaw),
          p = m(sinPsi)

        p.fraction = function (_) {
          return arguments.length ? m(sinPsi = +_) : sinPsi
        }

        return p.scale(158.837)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function bottomleyRaw(sinPsi) {
        function forward(lambda, phi) {
          var rho = _math.halfPi - phi,
            eta = rho ? lambda * sinPsi * (0, _math.sin)(rho) / rho : rho
          return [rho * (0, _math.sin)(eta) / sinPsi, _math.halfPi - rho * (0, _math.cos)(eta)]
        }

        forward.invert = function (x, y) {
          var x1 = x * sinPsi,
            y1 = _math.halfPi - y,
            rho = (0, _math.sqrt)(x1 * x1 + y1 * y1),
            eta = (0, _math.atan2)(x1, y1)
          return [(rho ? rho / (0, _math.sin)(rho) : 1) * eta / sinPsi, _math.halfPi - rho]
        }

        return forward
      }
      /***/
    },
    /* 338 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.bromleyRaw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(bromleyRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _mollweide = __webpack_require__(22)

      var bromleyRaw = exports.bromleyRaw = (0, _mollweide.mollweideBromleyRaw)(1, 4 / _math.pi, _math.pi)
      /***/
    },
    /* 339 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.chamberlinRaw = chamberlinRaw
      exports.chamberlinAfrica = chamberlinAfrica
      exports.default = chamberlin

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      // Azimuthal distance.
      function distance(dPhi, c1, s1, c2, s2, dLambda) {
        var cosdLambda = (0, _math.cos)(dLambda),
          r
        if ((0, _math.abs)(dPhi) > 1 || (0, _math.abs)(dLambda) > 1) {
          r = (0, _math.acos)(s1 * s2 + c1 * c2 * cosdLambda)
        } else {
          var sindPhi = (0, _math.sin)(dPhi / 2),
            sindLambda = (0, _math.sin)(dLambda / 2)
          r = 2 * (0, _math.asin)((0, _math.sqrt)(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda))
        }
        return (0, _math.abs)(r) > _math.epsilon ? [r, (0, _math.atan2)(c2 * (0, _math.sin)(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0]
      }

      // Angle opposite a, and contained between sides of lengths b and c.
      function angle(b, c, a) {
        return (0, _math.acos)((b * b + c * c - a * a) / (2 * b * c))
      }

      // Normalize longitude.
      function longitude(lambda) {
        return lambda - 2 * _math.pi * (0, _math.floor)((lambda + _math.pi) / (2 * _math.pi))
      }

      function chamberlinRaw(p0, p1, p2) {
        var points = [
          [p0[0], p0[1], (0, _math.sin)(p0[1]), (0, _math.cos)(p0[1])],
          [p1[0], p1[1], (0, _math.sin)(p1[1]), (0, _math.cos)(p1[1])],
          [p2[0], p2[1], (0, _math.sin)(p2[1]), (0, _math.cos)(p2[1])]
        ]

        for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
          b = points[i]
          a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0])
          a.point = [0, 0]
        }

        var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]),
          beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]),
          beta2 = _math.pi - beta0

        points[2].point[1] = 0
        points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2)

        var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * (0, _math.cos)(beta0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * (0, _math.sin)(beta0))]

        function forward(lambda, phi) {
          var sinPhi = (0, _math.sin)(phi),
            cosPhi = (0, _math.cos)(phi),
            v = new Array(3),
            i

          // Compute distance and azimuth from control points.
          for (i = 0; i < 3; ++i) {
            var p = points[i]
            v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0])
            if (!v[i][0]) return p.point
            v[i][1] = longitude(v[i][1] - p.v[1])
          }

          // Arithmetic mean of interception points.
          var point = mean.slice()
          for (i = 0; i < 3; ++i) {
            var j = i == 2 ? 0 : i + 1
            var a = angle(points[i].v[0], v[i][0], v[j][0])
            if (v[i][1] < 0) a = -a

            if (!i) {
              point[0] += v[i][0] * (0, _math.cos)(a)
              point[1] -= v[i][0] * (0, _math.sin)(a)
            } else if (i == 1) {
              a = beta1 - a
              point[0] -= v[i][0] * (0, _math.cos)(a)
              point[1] -= v[i][0] * (0, _math.sin)(a)
            } else {
              a = beta2 - a
              point[0] += v[i][0] * (0, _math.cos)(a)
              point[1] += v[i][0] * (0, _math.sin)(a)
            }
          }

          point[0] /= 3, point[1] /= 3
          return point
        }

        return forward
      }

      function pointRadians(p) {
        return p[0] *= _math.radians, p[1] *= _math.radians, p
      }

      function chamberlinAfrica() {
        return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2])
      }

      function chamberlin(p0, p1, p2) {
        // TODO order matters!
        var c = (0, _d3Geo.geoCentroid)({
            type: 'MultiPoint',
            coordinates: [p0, p1, p2]
          }),
          R = [-c[0], -c[1]],
          r = (0, _d3Geo.geoRotation)(R),
          p = (0, _d3Geo.geoProjection)(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R),
          center = p.center

        delete p.rotate

        p.center = function (_) {
          return arguments.length ? center(r(_)) : r.invert(center())
        }

        return p.clipAngle(90)
      }
      /***/
    },
    /* 340 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.craigRaw = craigRaw

      exports.default = function () {
        return (0, _parallel2.default)(craigRaw).scale(249.828).clipAngle(90)
      }

      var _math = __webpack_require__(1)

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function craigRaw(phi0) {
        var tanPhi0 = (0, _math.tan)(phi0)

        function forward(lambda, phi) {
          return [lambda, (lambda ? lambda / (0, _math.sin)(lambda) : 1) * ((0, _math.sin)(phi) * (0, _math.cos)(lambda) - tanPhi0 * (0, _math.cos)(phi))]
        }

        forward.invert = tanPhi0 ? function (x, y) {
          if (x) y *= (0, _math.sin)(x) / x
          var cosLambda = (0, _math.cos)(x)
          return [x, 2 * (0, _math.atan2)((0, _math.sqrt)(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)]
        } : function (x, y) {
          return [x, (0, _math.asin)(x ? y * (0, _math.tan)(x) / x : y)]
        }

        return forward
      }
      /***/
    },
    /* 341 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.crasterRaw = crasterRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(crasterRaw).scale(156.19)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var sqrt3 = (0, _math.sqrt)(3)

      function crasterRaw(lambda, phi) {
        return [sqrt3 * lambda * (2 * (0, _math.cos)(2 * phi / 3) - 1) / _math.sqrtPi, sqrt3 * _math.sqrtPi * (0, _math.sin)(phi / 3)]
      }

      crasterRaw.invert = function (x, y) {
        var phi = 3 * (0, _math.asin)(y / (sqrt3 * _math.sqrtPi))
        return [_math.sqrtPi * x / (sqrt3 * (2 * (0, _math.cos)(2 * phi / 3) - 1)), phi]
      }
      /***/
    },
    /* 342 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.cylindricalStereographicRaw = cylindricalStereographicRaw

      exports.default = function () {
        return (0, _parallel2.default)(cylindricalStereographicRaw).scale(124.75)
      }

      var _math = __webpack_require__(1)

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function cylindricalStereographicRaw(phi0) {
        var cosPhi0 = (0, _math.cos)(phi0)

        function forward(lambda, phi) {
          return [lambda * cosPhi0, (1 + cosPhi0) * (0, _math.tan)(phi / 2)]
        }

        forward.invert = function (x, y) {
          return [x / cosPhi0, (0, _math.atan)(y / (1 + cosPhi0)) * 2]
        }

        return forward
      }
      /***/
    },
    /* 343 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert1Raw = eckert1Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert1Raw).scale(165.664)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert1Raw(lambda, phi) {
        var alpha = (0, _math.sqrt)(8 / (3 * _math.pi))
        return [alpha * lambda * (1 - (0, _math.abs)(phi) / _math.pi), alpha * phi]
      }

      eckert1Raw.invert = function (x, y) {
        var alpha = (0, _math.sqrt)(8 / (3 * _math.pi)),
          phi = y / alpha
        return [x / (alpha * (1 - (0, _math.abs)(phi) / _math.pi)), phi]
      }
      /***/
    },
    /* 344 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert2Raw = eckert2Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert2Raw).scale(165.664)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert2Raw(lambda, phi) {
        var alpha = (0, _math.sqrt)(4 - 3 * (0, _math.sin)((0, _math.abs)(phi)))
        return [2 / (0, _math.sqrt)(6 * _math.pi) * lambda * alpha, (0, _math.sign)(phi) * (0, _math.sqrt)(2 * _math.pi / 3) * (2 - alpha)]
      }

      eckert2Raw.invert = function (x, y) {
        var alpha = 2 - (0, _math.abs)(y) / (0, _math.sqrt)(2 * _math.pi / 3)
        return [x * (0, _math.sqrt)(6 * _math.pi) / (2 * alpha), (0, _math.sign)(y) * (0, _math.asin)((4 - alpha * alpha) / 3)]
      }
      /***/
    },
    /* 345 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert3Raw = eckert3Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert3Raw).scale(180.739)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert3Raw(lambda, phi) {
        var k = (0, _math.sqrt)(_math.pi * (4 + _math.pi))
        return [2 / k * lambda * (1 + (0, _math.sqrt)(1 - 4 * phi * phi / (_math.pi * _math.pi))), 4 / k * phi]
      }

      eckert3Raw.invert = function (x, y) {
        var k = (0, _math.sqrt)(_math.pi * (4 + _math.pi)) / 2
        return [x * k / (1 + (0, _math.sqrt)(1 - y * y * (4 + _math.pi) / (4 * _math.pi))), y * k / 2]
      }
      /***/
    },
    /* 346 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert4Raw = eckert4Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert4Raw).scale(180.739)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert4Raw(lambda, phi) {
        var k = (2 + _math.halfPi) * (0, _math.sin)(phi)
        phi /= 2
        for (var i = 0, delta = Infinity; i < 10 && (0, _math.abs)(delta) > _math.epsilon; i++) {
          var cosPhi = (0, _math.cos)(phi)
          phi -= delta = (phi + (0, _math.sin)(phi) * (cosPhi + 2) - k) / (2 * cosPhi * (1 + cosPhi))
        }
        return [2 / (0, _math.sqrt)(_math.pi * (4 + _math.pi)) * lambda * (1 + (0, _math.cos)(phi)), 2 * (0, _math.sqrt)(_math.pi / (4 + _math.pi)) * (0, _math.sin)(phi)]
      }

      eckert4Raw.invert = function (x, y) {
        var A = y * (0, _math.sqrt)((4 + _math.pi) / _math.pi) / 2,
          k = (0, _math.asin)(A),
          c = (0, _math.cos)(k)
        return [x / (2 / (0, _math.sqrt)(_math.pi * (4 + _math.pi)) * (1 + c)), (0, _math.asin)((k + A * (c + 2)) / (2 + _math.halfPi))]
      }
      /***/
    },
    /* 347 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert5Raw = eckert5Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert5Raw).scale(173.044)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert5Raw(lambda, phi) {
        return [lambda * (1 + (0, _math.cos)(phi)) / (0, _math.sqrt)(2 + _math.pi), 2 * phi / (0, _math.sqrt)(2 + _math.pi)]
      }

      eckert5Raw.invert = function (x, y) {
        var k = (0, _math.sqrt)(2 + _math.pi),
          phi = y * k / 2
        return [k * x / (1 + (0, _math.cos)(phi)), phi]
      }
      /***/
    },
    /* 348 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eckert6Raw = eckert6Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eckert6Raw).scale(173.044)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function eckert6Raw(lambda, phi) {
        var k = (1 + _math.halfPi) * (0, _math.sin)(phi)
        for (var i = 0, delta = Infinity; i < 10 && (0, _math.abs)(delta) > _math.epsilon; i++) {
          phi -= delta = (phi + (0, _math.sin)(phi) - k) / (1 + (0, _math.cos)(phi))
        }
        k = (0, _math.sqrt)(2 + _math.pi)
        return [lambda * (1 + (0, _math.cos)(phi)) / k, 2 * phi / k]
      }

      eckert6Raw.invert = function (x, y) {
        var j = 1 + _math.halfPi,
          k = (0, _math.sqrt)(j / 2)
        return [x * 2 * k / (1 + (0, _math.cos)(y *= k)), (0, _math.asin)((y + (0, _math.sin)(y)) / j)]
      }
      /***/
    },
    /* 349 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.eisenlohrRaw = eisenlohrRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(eisenlohrRaw).scale(62.5271)
      }

      var _d3Geo = __webpack_require__(0)

      var _august = __webpack_require__(172)

      var _math = __webpack_require__(1)

      var eisenlohrK = 3 + 2 * _math.sqrt2

      function eisenlohrRaw(lambda, phi) {
        var s0 = (0, _math.sin)(lambda /= 2),
          c0 = (0, _math.cos)(lambda),
          k = (0, _math.sqrt)((0, _math.cos)(phi)),
          c1 = (0, _math.cos)(phi /= 2),
          t = (0, _math.sin)(phi) / (c1 + _math.sqrt2 * c0 * k),
          c = (0, _math.sqrt)(2 / (1 + t * t)),
          v = (0, _math.sqrt)((_math.sqrt2 * c1 + (c0 + s0) * k) / (_math.sqrt2 * c1 + (c0 - s0) * k))
        return [eisenlohrK * (c * (v - 1 / v) - 2 * (0, _math.log)(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * (0, _math.atan)(t))]
      }

      eisenlohrRaw.invert = function (x, y) {
        if (!(p = _august.augustRaw.invert(x / 1.2, y * 1.065))) return null
        var lambda = p[0],
          phi = p[1],
          i = 20,
          p
        x /= eisenlohrK, y /= eisenlohrK
        do {
          var _0 = lambda / 2,
            _1 = phi / 2,
            s0 = (0, _math.sin)(_0),
            c0 = (0, _math.cos)(_0),
            s1 = (0, _math.sin)(_1),
            c1 = (0, _math.cos)(_1),
            cos1 = (0, _math.cos)(phi),
            k = (0, _math.sqrt)(cos1),
            t = s1 / (c1 + _math.sqrt2 * c0 * k),
            t2 = t * t,
            c = (0, _math.sqrt)(2 / (1 + t2)),
            v0 = _math.sqrt2 * c1 + (c0 + s0) * k,
            v1 = _math.sqrt2 * c1 + (c0 - s0) * k,
            v2 = v0 / v1,
            v = (0, _math.sqrt)(v2),
            vm1v = v - 1 / v,
            vp1v = v + 1 / v,
            fx = c * vm1v - 2 * (0, _math.log)(v) - x,
            fy = c * t * vp1v - 2 * (0, _math.atan)(t) - y,
            deltatDeltaLambda = s1 && _math.sqrt1_2 * k * s0 * t2 / s1,
            deltatDeltaPhi = (_math.sqrt2 * c0 * c1 + k) / (2 * (c1 + _math.sqrt2 * c0 * k) * (c1 + _math.sqrt2 * c0 * k) * k),
            deltacDeltat = -0.5 * t * c * c * c,
            deltacDeltaLambda = deltacDeltat * deltatDeltaLambda,
            deltacDeltaPhi = deltacDeltat * deltatDeltaPhi,
            A = (A = 2 * c1 + _math.sqrt2 * k * (c0 - s0)) * A * v,
            deltavDeltaLambda = (_math.sqrt2 * c0 * c1 * k + cos1) / A,
            deltavDeltaPhi = -(_math.sqrt2 * s0 * s1) / (k * A),
            deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2),
            deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2),
            deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2),
            deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2),
            denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda
          if (!denominator) break
          var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
            deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator
          lambda -= deltaLambda
          phi = (0, _math.max)(-_math.halfPi, (0, _math.min)(_math.halfPi, phi - deltaPhi))
        } while (((0, _math.abs)(deltaLambda) > _math.epsilon || (0, _math.abs)(deltaPhi) > _math.epsilon) && --i > 0)
        return (0, _math.abs)((0, _math.abs)(phi) - _math.halfPi) < _math.epsilon ? [0, phi] : i && [lambda, phi]
      }
      /***/
    },
    /* 350 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.faheyRaw = faheyRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(faheyRaw).scale(137.152)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var faheyK = (0, _math.cos)(35 * _math.radians)

      function faheyRaw(lambda, phi) {
        var t = (0, _math.tan)(phi / 2)
        return [lambda * faheyK * (0, _math.sqrt)(1 - t * t), (1 + faheyK) * t]
      }

      faheyRaw.invert = function (x, y) {
        var t = y / (1 + faheyK)
        return [x && x / (faheyK * (0, _math.sqrt)(1 - t * t)), 2 * (0, _math.atan)(t)]
      }
      /***/
    },
    /* 351 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.foucautRaw = foucautRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(foucautRaw).scale(135.264)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function foucautRaw(lambda, phi) {
        var k = phi / 2,
          cosk = (0, _math.cos)(k)
        return [2 * lambda / _math.sqrtPi * (0, _math.cos)(phi) * cosk * cosk, _math.sqrtPi * (0, _math.tan)(k)]
      }

      foucautRaw.invert = function (x, y) {
        var k = (0, _math.atan)(y / _math.sqrtPi),
          cosk = (0, _math.cos)(k),
          phi = 2 * k
        return [x * _math.sqrtPi / 2 / ((0, _math.cos)(phi) * cosk * cosk), phi]
      }
      /***/
    },
    /* 352 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (projectionType) {
        if (projectionType == null) projectionType = _d3Geo.geoOrthographic
        var projection = projectionType(),
          equirectangular = (0, _d3Geo.geoEquirectangular)().scale(_math.degrees).precision(0).clipAngle(null).translate([0, 0]) // antimeridian cutting

        function gilbert(point) {
          return projection(gilbertForward(point))
        }

        if (projection.invert) {
          gilbert.invert = function (point) {
            return gilbertInvert(projection.invert(point))
          }
        }

        gilbert.stream = function (stream) {
          var s1 = projection.stream(stream),
            s0 = equirectangular.stream({
              point: function point(lambda, phi) {
                s1.point(lambda / 2, (0, _math.asin)((0, _math.tan)(-phi / 2 * _math.radians)) * _math.degrees)
              },
              lineStart: function lineStart() {
                s1.lineStart()
              },
              lineEnd: function lineEnd() {
                s1.lineEnd()
              },
              polygonStart: function polygonStart() {
                s1.polygonStart()
              },
              polygonEnd: function polygonEnd() {
                s1.polygonEnd()
              }
            })
          s0.sphere = s1.sphere
          return s0
        }

        function property(name) {
          gilbert[name] = function (_) {
            return arguments.length ? (projection[name](_), gilbert) : projection[name]()
          }
        }

        gilbert.rotate = function (_) {
          return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate()
        }

        gilbert.center = function (_) {
          return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center())
        }

        property('clipAngle')
        property('clipExtent')
        property('scale')
        property('translate')
        property('precision')

        return gilbert.scale(249.5)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function gilbertForward(point) {
        return [point[0] / 2, (0, _math.asin)((0, _math.tan)(point[1] / 2 * _math.radians)) * _math.degrees]
      }

      function gilbertInvert(point) {
        return [point[0] * 2, 2 * (0, _math.atan)((0, _math.sin)(point[1] * _math.radians)) * _math.degrees]
      }
      /***/
    },
    /* 353 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.gingeryRaw = gingeryRaw

      exports.default = function () {
        var n = 6,
          rho = 30 * _math.radians,
          cRho = (0, _math.cos)(rho),
          sRho = (0, _math.sin)(rho),
          m = (0, _d3Geo.geoProjectionMutator)(gingeryRaw),
          p = m(rho, n),
          stream_ = p.stream,
          epsilon = 1e-2,
          cr = -(0, _math.cos)(epsilon * _math.radians),
          sr = (0, _math.sin)(epsilon * _math.radians)

        p.radius = function (_) {
          if (!arguments.length) return rho * _math.degrees
          cRho = (0, _math.cos)(rho = _ * _math.radians)
          sRho = (0, _math.sin)(rho)
          return m(rho, n)
        }

        p.lobes = function (_) {
          if (!arguments.length) return n
          return m(rho, n = +_)
        }

        p.stream = function (stream) {
          var rotate = p.rotate(),
            rotateStream = stream_(stream),
            sphereStream = (p.rotate([0, 0]), stream_(stream))
          p.rotate(rotate)
          rotateStream.sphere = function () {
            sphereStream.polygonStart(), sphereStream.lineStart()
            for (var i = 0, delta = 2 * _math.pi / n, phi = 0; i < n; ++i, phi -= delta) {
              sphereStream.point((0, _math.atan2)(sr * (0, _math.cos)(phi), cr) * _math.degrees, (0, _math.asin)(sr * (0, _math.sin)(phi)) * _math.degrees)
              sphereStream.point((0, _math.atan2)(sRho * (0, _math.cos)(phi - delta / 2), cRho) * _math.degrees, (0, _math.asin)(sRho * (0, _math.sin)(phi - delta / 2)) * _math.degrees)
            }
            sphereStream.lineEnd(), sphereStream.polygonEnd()
          }
          return rotateStream
        }

        return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function gingeryRaw(rho, n) {
        var k = 2 * _math.pi / n,
          rho2 = rho * rho

        function forward(lambda, phi) {
          var p = (0, _d3Geo.geoAzimuthalEquidistantRaw)(lambda, phi),
            x = p[0],
            y = p[1],
            r2 = x * x + y * y

          if (r2 > rho2) {
            var r = (0, _math.sqrt)(r2),
              theta = (0, _math.atan2)(y, x),
              theta0 = k * (0, _math.round)(theta / k),
              alpha = theta - theta0,
              rhoCosAlpha = rho * (0, _math.cos)(alpha),
              k_ = (rho * (0, _math.sin)(alpha) - alpha * (0, _math.sin)(rhoCosAlpha)) / (_math.halfPi - rhoCosAlpha),
              s_ = gingeryLength(alpha, k_),
              e = (_math.pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math.pi)

            x = r
            var i = 50,
              delta
            do {
              x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e)
            } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)

            y = alpha * (0, _math.sin)(x)
            if (x < _math.halfPi) y -= k_ * (x - _math.halfPi)

            var s = (0, _math.sin)(theta0),
              c = (0, _math.cos)(theta0)
            p[0] = x * c - y * s
            p[1] = x * s + y * c
          }
          return p
        }

        forward.invert = function (x, y) {
          var r2 = x * x + y * y
          if (r2 > rho2) {
            var r = (0, _math.sqrt)(r2),
              theta = (0, _math.atan2)(y, x),
              theta0 = k * (0, _math.round)(theta / k),
              dTheta = theta - theta0

            x = r * (0, _math.cos)(dTheta)
            y = r * (0, _math.sin)(dTheta)

            var x_halfPi = x - _math.halfPi,
              sinx = (0, _math.sin)(x),
              alpha = y / sinx,
              delta = x < _math.halfPi ? Infinity : 0,
              i = 10

            while (true) {
              var rhosinAlpha = rho * (0, _math.sin)(alpha),
                rhoCosAlpha = rho * (0, _math.cos)(alpha),
                sinRhoCosAlpha = (0, _math.sin)(rhoCosAlpha),
                halfPi_RhoCosAlpha = _math.halfPi - rhoCosAlpha,
                k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha,
                s_ = gingeryLength(alpha, k_)

              if ((0, _math.abs)(delta) < _math.epsilon2 || !--i) break

              alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * (0, _math.cos)(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha))
            }
            r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (_math.pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math.pi)
            theta = theta0 + alpha
            x = r * (0, _math.cos)(theta)
            y = r * (0, _math.sin)(theta)
          }
          return _d3Geo.geoAzimuthalEquidistantRaw.invert(x, y)
        }

        return forward
      }

      function gingeryLength(alpha, k) {
        return function (x) {
          var y_ = alpha * (0, _math.cos)(x)
          if (x < _math.halfPi) y_ -= k
          return (0, _math.sqrt)(1 + y_ * y_)
        }
      }

      // Numerical integration: trapezoidal rule.
      function gingeryIntegrate(f, a, b) {
        var n = 50,
          h = (b - a) / n,
          s = f(a) + f(b)
        for (var i = 1, x = a; i < n; ++i) {
          s += 2 * f(x += h)
        }
        return s * 0.5 * h
      }
      /***/
    },
    /* 354 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ginzburg4Raw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(ginzburg4Raw).scale(149.995)
      }

      var _d3Geo = __webpack_require__(0)

      var _ginzburgPolyconic = __webpack_require__(59)

      var _ginzburgPolyconic2 = _interopRequireDefault(_ginzburgPolyconic)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var ginzburg4Raw = exports.ginzburg4Raw = (0, _ginzburgPolyconic2.default)(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555)
      /***/
    },
    /* 355 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ginzburg5Raw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(ginzburg5Raw).scale(153.93)
      }

      var _d3Geo = __webpack_require__(0)

      var _ginzburgPolyconic = __webpack_require__(59)

      var _ginzburgPolyconic2 = _interopRequireDefault(_ginzburgPolyconic)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var ginzburg5Raw = exports.ginzburg5Raw = (0, _ginzburgPolyconic2.default)(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742)
      /***/
    },
    /* 356 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ginzburg6Raw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(ginzburg6Raw).scale(130.945)
      }

      var _d3Geo = __webpack_require__(0)

      var _ginzburgPolyconic = __webpack_require__(59)

      var _ginzburgPolyconic2 = _interopRequireDefault(_ginzburgPolyconic)

      var _math = __webpack_require__(1)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var ginzburg6Raw = exports.ginzburg6Raw = (0, _ginzburgPolyconic2.default)(5 / 6 * _math.pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045)
      /***/
    },
    /* 357 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ginzburg8Raw = ginzburg8Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(ginzburg8Raw).scale(131.747)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function ginzburg8Raw(lambda, phi) {
        var lambda2 = lambda * lambda,
          phi2 = phi * phi
        return [lambda * (1 - 0.162388 * phi2) * (0.87 - 0.000952426 * lambda2 * lambda2), phi * (1 + phi2 / 12)]
      }

      ginzburg8Raw.invert = function (x, y) {
        var lambda = x,
          phi = y,
          i = 50,
          delta
        do {
          var phi2 = phi * phi
          phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4)
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        i = 50
        x /= 1 - 0.162388 * phi2
        do {
          var lambda4 = (lambda4 = lambda * lambda) * lambda4
          lambda -= delta = (lambda * (0.87 - 0.000952426 * lambda4) - x) / (0.87 - 0.00476213 * lambda4)
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        return [lambda, phi]
      }
      /***/
    },
    /* 358 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ginzburg9Raw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(ginzburg9Raw).scale(131.087)
      }

      var _d3Geo = __webpack_require__(0)

      var _ginzburgPolyconic = __webpack_require__(59)

      var _ginzburgPolyconic2 = _interopRequireDefault(_ginzburgPolyconic)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var ginzburg9Raw = exports.ginzburg9Raw = (0, _ginzburgPolyconic2.default)(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762)
      /***/
    },
    /* 359 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.ellipticJi = ellipticJi
      exports.ellipticJ = ellipticJ
      exports.ellipticFi = ellipticFi
      exports.ellipticF = ellipticF

      var _math = __webpack_require__(1)

      // Returns [sn, cn, dn](u + iv|m).
      function ellipticJi(u, v, m) {
        var a, b, c
        if (!u) {
          b = ellipticJ(v, 1 - m)
          return [
            [0, b[0] / b[1]],
            [1 / b[1], 0],
            [b[2] / b[1], 0]
          ]
        }
        a = ellipticJ(u, m)
        if (!v) return [
          [a[0], 0],
          [a[1], 0],
          [a[2], 0]
        ]
        b = ellipticJ(v, 1 - m)
        c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0]
        return [
          [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],
          [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],
          [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]
        ]
      }

      // Returns [sn, cn, dn, ph](u|m).
      function ellipticJ(u, m) {
        var ai, b, phi, t, twon
        if (m < _math.epsilon) {
          t = (0, _math.sin)(u)
          b = (0, _math.cos)(u)
          ai = m * (u - t * b) / 4
          return [t - ai * b, b + ai * t, 1 - m * t * t / 2, u - ai]
        }
        if (m >= 1 - _math.epsilon) {
          ai = (1 - m) / 4
          b = (0, _math.cosh)(u)
          t = (0, _math.tanh)(u)
          phi = 1 / b
          twon = b * (0, _math.sinh)(u)
          return [t + ai * (twon - u) / (b * b), phi - ai * t * phi * (twon - u), phi + ai * t * phi * (twon + u), 2 * (0, _math.atan)((0, _math.exp)(u)) - _math.halfPi + ai * (twon - u) / b]
        }

        var a = [1, 0, 0, 0, 0, 0, 0, 0, 0],
          c = [(0, _math.sqrt)(m), 0, 0, 0, 0, 0, 0, 0, 0],
          i = 0
        b = (0, _math.sqrt)(1 - m)
        twon = 1

        while ((0, _math.abs)(c[i] / a[i]) > _math.epsilon && i < 8) {
          ai = a[i++]
          c[i] = (ai - b) / 2
          a[i] = (ai + b) / 2
          b = (0, _math.sqrt)(ai * b)
          twon *= 2
        }

        phi = twon * a[i] * u
        do {
          t = c[i] * (0, _math.sin)(b = phi) / a[i]
          phi = ((0, _math.asin)(t) + phi) / 2
        } while (--i)

        return [(0, _math.sin)(phi), t = (0, _math.cos)(phi), t / (0, _math.cos)(phi - b), phi]
      }

      // Calculate F(phi+iPsi|m).
      // See Abramowitz and Stegun, 17.4.11.
      function ellipticFi(phi, psi, m) {
        var r = (0, _math.abs)(phi),
          i = (0, _math.abs)(psi),
          sinhPsi = (0, _math.sinh)(i)
        if (r) {
          var cscPhi = 1 / (0, _math.sin)(r),
            cotPhi2 = 1 / ((0, _math.tan)(r) * (0, _math.tan)(r)),
            b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m),
            c = (m - 1) * cotPhi2,
            cotLambda2 = (-b + (0, _math.sqrt)(b * b - 4 * c)) / 2
          return [ellipticF((0, _math.atan)(1 / (0, _math.sqrt)(cotLambda2)), m) * (0, _math.sign)(phi), ellipticF((0, _math.atan)((0, _math.sqrt)((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * (0, _math.sign)(psi)]
        }
        return [0, ellipticF((0, _math.atan)(sinhPsi), 1 - m) * (0, _math.sign)(psi)]
      }

      // Calculate F(phi|m) where m = k = sin.
      // See Abramowitz and Stegun, 17.6.7.
      function ellipticF(phi, m) {
        if (!m) return phi
        if (m === 1) return (0, _math.log)((0, _math.tan)(phi / 2 + _math.quarterPi))
        var a = 1,
          b = (0, _math.sqrt)(1 - m),
          c = (0, _math.sqrt)(m)
        for (var i = 0;
          (0, _math.abs)(c) > _math.epsilon; i++) {
          if (phi % _math.pi) {
            var dPhi = (0, _math.atan)(b * (0, _math.tan)(phi) / a)
            if (dPhi < 0) dPhi += _math.pi
            phi += dPhi + ~~(phi / _math.pi) * _math.pi
          } else phi += phi
          c = (a + b) / 2
          b = (0, _math.sqrt)(a * b)
          c = ((a = c) - b) / 2
        }
        return phi / ((0, _math.pow)(2, i) * a)
      }
      /***/
    },
    /* 360 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.hammerRaw = hammerRaw

      exports.default = function () {
        var B = 2,
          m = (0, _d3Geo.geoProjectionMutator)(hammerRaw),
          p = m(B)

        p.coefficient = function (_) {
          if (!arguments.length) return B
          return m(B = +_)
        }

        return p.scale(169.529)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function hammerRaw(A, B) {
        if (arguments.length < 2) B = A
        if (B === 1) return _d3Geo.geoAzimuthalEqualAreaRaw
        if (B === Infinity) return hammerQuarticAuthalicRaw

        function forward(lambda, phi) {
          var coordinates = (0, _d3Geo.geoAzimuthalEqualAreaRaw)(lambda / B, phi)
          coordinates[0] *= A
          return coordinates
        }

        forward.invert = function (x, y) {
          var coordinates = _d3Geo.geoAzimuthalEqualAreaRaw.invert(x / A, y)
          coordinates[0] *= B
          return coordinates
        }

        return forward
      }

      function hammerQuarticAuthalicRaw(lambda, phi) {
        return [lambda * (0, _math.cos)(phi) / (0, _math.cos)(phi /= 2), 2 * (0, _math.sin)(phi)]
      }

      hammerQuarticAuthalicRaw.invert = function (x, y) {
        var phi = 2 * (0, _math.asin)(y / 2)
        return [x * (0, _math.cos)(phi / 2) / (0, _math.cos)(phi), phi]
      }
      /***/
    },
    /* 361 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.hammerRetroazimuthalRaw = hammerRetroazimuthalRaw

      exports.default = function () {
        var phi0 = 0,
          m = (0, _d3Geo.geoProjectionMutator)(hammerRetroazimuthalRaw),
          p = m(phi0),
          rotate_ = p.rotate,
          stream_ = p.stream,
          circle = (0, _d3Geo.geoCircle)()

        p.parallel = function (_) {
          if (!arguments.length) return phi0 * _math.degrees
          var r = p.rotate()
          return m(phi0 = _ * _math.radians).rotate(r)
        }

        // Temporary hack; see hammerRetroazimuthalRotation.
        p.rotate = function (_) {
          if (!arguments.length) return _ = rotate_.call(p), _[1] += phi0 * _math.degrees, _
          rotate_.call(p, [_[0], _[1] - phi0 * _math.degrees])
          circle.center([-_[0], -_[1]])
          return p
        }

        p.stream = function (stream) {
          stream = stream_(stream)
          stream.sphere = function () {
            stream.polygonStart()
            var epsilon = 1e-2,
              ring = circle.radius(90 - epsilon)().coordinates[0],
              n = ring.length - 1,
              i = -1,
              p
            stream.lineStart()
            while (++i < n) {
              stream.point((p = ring[i])[0], p[1])
            }
            stream.lineEnd()
            ring = circle.radius(90 + epsilon)().coordinates[0]
            n = ring.length - 1
            stream.lineStart()
            while (--i >= 0) {
              stream.point((p = ring[i])[0], p[1])
            }
            stream.lineEnd()
            stream.polygonEnd()
          }
          return stream
        }

        return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function hammerRetroazimuthalRaw(phi0) {
        var sinPhi0 = (0, _math.sin)(phi0),
          cosPhi0 = (0, _math.cos)(phi0),
          rotate = hammerRetroazimuthalRotation(phi0)

        rotate.invert = hammerRetroazimuthalRotation(-phi0)

        function forward(lambda, phi) {
          var p = rotate(lambda, phi)
          lambda = p[0], phi = p[1]
          var sinPhi = (0, _math.sin)(phi),
            cosPhi = (0, _math.cos)(phi),
            cosLambda = (0, _math.cos)(lambda),
            z = (0, _math.acos)(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda),
            sinz = (0, _math.sin)(z),
            K = (0, _math.abs)(sinz) > _math.epsilon ? z / sinz : 1
          return [K * cosPhi0 * (0, _math.sin)(lambda), ((0, _math.abs)(lambda) > _math.halfPi ? K : -K) * ( // rotate for back hemisphere
            sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)]
        }

        forward.invert = function (x, y) {
          var rho = (0, _math.sqrt)(x * x + y * y),
            sinz = -(0, _math.sin)(rho),
            cosz = (0, _math.cos)(rho),
            a = rho * cosz,
            b = -y * sinz,
            c = rho * sinPhi0,
            d = (0, _math.sqrt)(a * a + b * b - c * c),
            phi = (0, _math.atan2)(a * c + b * d, b * c - a * d),
            lambda = (rho > _math.halfPi ? -1 : 1) * (0, _math.atan2)(x * sinz, rho * (0, _math.cos)(phi) * cosz + y * (0, _math.sin)(phi) * sinz)
          return rotate.invert(lambda, phi)
        }

        return forward
      }

      // Latitudinal rotation by phi0.
      // Temporary hack until D3 supports arbitrary small-circle clipping origins.
      function hammerRetroazimuthalRotation(phi0) {
        var sinPhi0 = (0, _math.sin)(phi0),
          cosPhi0 = (0, _math.cos)(phi0)

        return function (lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            x = (0, _math.cos)(lambda) * cosPhi,
            y = (0, _math.sin)(lambda) * cosPhi,
            z = (0, _math.sin)(phi)
          return [(0, _math.atan2)(y, x * cosPhi0 - z * sinPhi0), (0, _math.asin)(z * cosPhi0 + x * sinPhi0)]
        }
      }
      /***/
    },
    /* 362 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.healpixRaw = healpixRaw

      exports.default = function () {
        var H = 4,
          m = (0, _d3Geo.geoProjectionMutator)(healpixRaw),
          p = m(H),
          stream_ = p.stream

        p.lobes = function (_) {
          return arguments.length ? m(H = +_) : H
        }

        p.stream = function (stream) {
          var rotate = p.rotate(),
            rotateStream = stream_(stream),
            sphereStream = (p.rotate([0, 0]), stream_(stream))
          p.rotate(rotate)
          rotateStream.sphere = function () {
            (0, _d3Geo.geoStream)(sphere(180 / H), sphereStream)
          }
          return rotateStream
        }

        return p.scale(239.75)
      }

      var _d3Array = __webpack_require__(14)

      var _d3Geo = __webpack_require__(0)

      var _collignon = __webpack_require__(90)

      var _cylindricalEqualArea = __webpack_require__(174)

      var _math = __webpack_require__(1)

      var healpixParallel = 41 + 48 / 36 + 37 / 3600,
        // for K=3; TODO automate
        healpixLambert = (0, _cylindricalEqualArea.cylindricalEqualAreaRaw)(0)

      function healpixRaw(H) {
        var phi0 = healpixParallel * _math.radians,
          dx = (0, _collignon.collignonRaw)(_math.pi, phi0)[0] - (0, _collignon.collignonRaw)(-_math.pi, phi0)[0],
          y0 = healpixLambert(0, phi0)[1],
          y1 = (0, _collignon.collignonRaw)(0, phi0)[1],
          dy1 = _math.sqrtPi - y1,
          k = _math.tau / H,
          w = 4 / _math.tau,
          h = y0 + dy1 * dy1 * 4 / _math.tau

        function forward(lambda, phi) {
          var point,
            phi2 = (0, _math.abs)(phi)
          if (phi2 > phi0) {
            var i = (0, _math.min)(H - 1, (0, _math.max)(0, (0, _math.floor)((lambda + _math.pi) / k)))
            lambda += _math.pi * (H - 1) / H - i * k
            point = (0, _collignon.collignonRaw)(lambda, phi2)
            point[0] = point[0] * _math.tau / dx - _math.tau * (H - 1) / (2 * H) + i * _math.tau / H
            point[1] = y0 + (point[1] - y1) * 4 * dy1 / _math.tau
            if (phi < 0) point[1] = -point[1]
          } else {
            point = healpixLambert(lambda, phi)
          }
          point[0] *= w, point[1] /= h
          return point
        }

        forward.invert = function (x, y) {
          x /= w, y *= h
          var y2 = (0, _math.abs)(y)
          if (y2 > y0) {
            var i = (0, _math.min)(H - 1, (0, _math.max)(0, (0, _math.floor)((x + _math.pi) / k)))
            x = (x + _math.pi * (H - 1) / H - i * k) * dx / _math.tau
            var point = _collignon.collignonRaw.invert(x, 0.25 * (y2 - y0) * _math.tau / dy1 + y1)
            point[0] -= _math.pi * (H - 1) / H - i * k
            if (y < 0) point[1] = -point[1]
            return point
          }
          return healpixLambert.invert(x, y)
        }

        return forward
      }

      function sphere(step) {
        return {
          type: 'Polygon',
          coordinates: [(0, _d3Array.range)(-180, 180 + step / 2, step).map(function (x, i) {
            return [x, i & 1 ? 90 - 1e-6 : healpixParallel]
          }).concat((0, _d3Array.range)(180, -180 - step / 2, -step).map(function (x, i) {
            return [x, i & 1 ? -90 + 1e-6 : -healpixParallel]
          }))]
        }
      }
      /***/
    },
    /* 363 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.hillRaw = hillRaw

      exports.default = function () {
        var K = 1,
          m = (0, _d3Geo.geoProjectionMutator)(hillRaw),
          p = m(K)

        p.ratio = function (_) {
          return arguments.length ? m(K = +_) : K
        }

        return p.scale(167.774).center([0, 18.67])
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function hillRaw(K) {
        var L = 1 + K,
          sinBt = (0, _math.sin)(1 / L),
          Bt = (0, _math.asin)(sinBt),
          A = 2 * (0, _math.sqrt)(_math.pi / (B = _math.pi + 4 * Bt * L)),
          B,
          rho0 = 0.5 * A * (L + (0, _math.sqrt)(K * (2 + K))),
          K2 = K * K,
          L2 = L * L

        function forward(lambda, phi) {
          var t = 1 - (0, _math.sin)(phi),
            rho,
            omega
          if (t && t < 2) {
            var theta = _math.halfPi - phi,
              i = 25,
              delta
            do {
              var sinTheta = (0, _math.sin)(theta),
                cosTheta = (0, _math.cos)(theta),
                Bt_Bt1 = Bt + (0, _math.atan2)(sinTheta, L - cosTheta),
                C = 1 + L2 - 2 * L * cosTheta
              theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1)
            } while ((0, _math.abs)(delta) > _math.epsilon2 && --i > 0)
            rho = A * (0, _math.sqrt)(C)
            omega = lambda * Bt_Bt1 / _math.pi
          } else {
            rho = A * (K + t)
            omega = lambda * Bt / _math.pi
          }
          return [rho * (0, _math.sin)(omega), rho0 - rho * (0, _math.cos)(omega)]
        }

        forward.invert = function (x, y) {
          var rho2 = x * x + (y -= rho0) * y,
            cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L),
            theta = (0, _math.acos)(cosTheta),
            sinTheta = (0, _math.sin)(theta),
            Bt_Bt1 = Bt + (0, _math.atan2)(sinTheta, L - cosTheta)
          return [(0, _math.asin)(x / (0, _math.sqrt)(rho2)) * _math.pi / Bt_Bt1, (0, _math.asin)(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)]
        }

        return forward
      }
      /***/
    },
    /* 364 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_boggs.boggsRaw, lobes).scale(160.857)
      }

      var _boggs = __webpack_require__(173)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 0],
            [-100, 90],
            [-40, 0]
          ],
          [
            [-40, 0],
            [30, 90],
            [180, 0]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, 0],
            [-160, -90],
            [-100, 0]
          ],
          [
            [-100, 0],
            [-60, -90],
            [-20, 0]
          ],
          [
            [-20, 0],
            [20, -90],
            [80, 0]
          ],
          [
            [80, 0],
            [140, -90],
            [180, 0]
          ]
        ]
      ]
      /***/
    },
    /* 365 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_homolosine.homolosineRaw, lobes).scale(152.63)
      }

      var _homolosine = __webpack_require__(178)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 0],
            [-100, 90],
            [-40, 0]
          ],
          [
            [-40, 0],
            [30, 90],
            [180, 0]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, 0],
            [-160, -90],
            [-100, 0]
          ],
          [
            [-100, 0],
            [-60, -90],
            [-20, 0]
          ],
          [
            [-20, 0],
            [20, -90],
            [80, 0]
          ],
          [
            [80, 0],
            [140, -90],
            [180, 0]
          ]
        ]
      ]
      /***/
    },
    /* 366 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_mollweide.mollweideRaw, lobes).scale(169.529)
      }

      var _mollweide = __webpack_require__(22)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 0],
            [-100, 90],
            [-40, 0]
          ],
          [
            [-40, 0],
            [30, 90],
            [180, 0]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, 0],
            [-160, -90],
            [-100, 0]
          ],
          [
            [-100, 0],
            [-60, -90],
            [-20, 0]
          ],
          [
            [-20, 0],
            [20, -90],
            [80, 0]
          ],
          [
            [80, 0],
            [140, -90],
            [180, 0]
          ]
        ]
      ]
      /***/
    },
    /* 367 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_mollweide.mollweideRaw, lobes).scale(169.529).rotate([20, 0])
      }

      var _mollweide = __webpack_require__(22)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 0],
            [-90, 90],
            [0, 0]
          ],
          [
            [0, 0],
            [90, 90],
            [180, 0]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, 0],
            [-90, -90],
            [0, 0]
          ],
          [
            [0, 0],
            [90, -90],
            [180, 0]
          ]
        ]
      ]
      /***/
    },
    /* 368 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_sinuMollweide.sinuMollweideRaw, lobes).rotate([-20, -55]).scale(164.263).center([0, -5.4036])
      }

      var _sinuMollweide = __webpack_require__(91)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 35],
            [-30, 90],
            [0, 35]
          ],
          [
            [0, 35],
            [30, 90],
            [180, 35]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, -10],
            [-102, -90],
            [-65, -10]
          ],
          [
            [-65, -10],
            [5, -90],
            [77, -10]
          ],
          [
            [77, -10],
            [103, -90],
            [180, -10]
          ]
        ]
      ]
      /***/
    },
    /* 369 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_sinusoidal.sinusoidalRaw, lobes).scale(152.63).rotate([-20, 0])
      }

      var _sinusoidal = __webpack_require__(41)

      var _index = __webpack_require__(26)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lobes = [
        [ // northern hemisphere
          [
            [-180, 0],
            [-110, 90],
            [-40, 0]
          ],
          [
            [-40, 0],
            [0, 90],
            [40, 0]
          ],
          [
            [40, 0],
            [110, 90],
            [180, 0]
          ]
        ],
        [ // southern hemisphere
          [
            [-180, 0],
            [-110, -90],
            [-40, 0]
          ],
          [
            [-40, 0],
            [0, -90],
            [40, 0]
          ],
          [
            [40, 0],
            [110, -90],
            [180, 0]
          ]
        ]
      ]
      /***/
    },
    /* 370 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.kavrayskiy7Raw = kavrayskiy7Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(kavrayskiy7Raw).scale(158.837)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function kavrayskiy7Raw(lambda, phi) {
        return [3 / _math.tau * lambda * (0, _math.sqrt)(_math.pi * _math.pi / 3 - phi * phi), phi]
      }

      kavrayskiy7Raw.invert = function (x, y) {
        return [_math.tau / 3 * x / (0, _math.sqrt)(_math.pi * _math.pi / 3 - y * y), y]
      }
      /***/
    },
    /* 371 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.lagrangeRaw = lagrangeRaw

      exports.default = function () {
        var n = 0.5,
          m = (0, _d3Geo.geoProjectionMutator)(lagrangeRaw),
          p = m(n)

        p.spacing = function (_) {
          return arguments.length ? m(n = +_) : n
        }

        return p.scale(124.75)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function lagrangeRaw(n) {
        function forward(lambda, phi) {
          if ((0, _math.abs)((0, _math.abs)(phi) - _math.halfPi) < _math.epsilon) return [0, phi < 0 ? -2 : 2]
          var sinPhi = (0, _math.sin)(phi),
            v = (0, _math.pow)((1 + sinPhi) / (1 - sinPhi), n / 2),
            c = 0.5 * (v + 1 / v) + (0, _math.cos)(lambda *= n)
          return [2 * (0, _math.sin)(lambda) / c, (v - 1 / v) / c]
        }

        forward.invert = function (x, y) {
          var y0 = (0, _math.abs)(y)
          if ((0, _math.abs)(y0 - 2) < _math.epsilon) return x ? null : [0, (0, _math.sign)(y) * _math.halfPi]
          if (y0 > 2) return null

          x /= 2, y /= 2
          var x2 = x * x,
            y2 = y * y,
            t = 2 * y / (1 + x2 + y2) // tanh(nPhi)
          t = (0, _math.pow)((1 + t) / (1 - t), 1 / n)
          return [(0, _math.atan2)(2 * x, 1 - x2 - y2) / n, (0, _math.asin)((t - 1) / (t + 1))]
        }

        return forward
      }
      /***/
    },
    /* 372 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.larriveeRaw = larriveeRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(larriveeRaw).scale(97.2672)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var pi_sqrt2 = _math.pi / _math.sqrt2

      function larriveeRaw(lambda, phi) {
        return [lambda * (1 + (0, _math.sqrt)((0, _math.cos)(phi))) / 2, phi / ((0, _math.cos)(phi / 2) * (0, _math.cos)(lambda / 6))]
      }

      larriveeRaw.invert = function (x, y) {
        var x0 = (0, _math.abs)(x),
          y0 = (0, _math.abs)(y),
          lambda = _math.epsilon,
          phi = _math.halfPi
        if (y0 < pi_sqrt2) phi *= y0 / pi_sqrt2;
        else lambda += 6 * (0, _math.acos)(pi_sqrt2 / y0)
        for (var i = 0; i < 25; i++) {
          var sinPhi = (0, _math.sin)(phi),
            sqrtcosPhi = (0, _math.sqrt)((0, _math.cos)(phi)),
            sinPhi_2 = (0, _math.sin)(phi / 2),
            cosPhi_2 = (0, _math.cos)(phi / 2),
            sinLambda_6 = (0, _math.sin)(lambda / 6),
            cosLambda_6 = (0, _math.cos)(lambda / 6),
            f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x0,
            f1 = phi / (cosPhi_2 * cosLambda_6) - y0,
            df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0,
            df0dLambda = 0.5 * (1 + sqrtcosPhi),
            df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6),
            df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6),
            denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda,
            dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom,
            dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom
          phi -= dPhi
          lambda -= dLambda
          if ((0, _math.abs)(dPhi) < _math.epsilon && (0, _math.abs)(dLambda) < _math.epsilon) break
        }
        return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi]
      }
      /***/
    },
    /* 373 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.laskowskiRaw = laskowskiRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(laskowskiRaw).scale(139.98)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function laskowskiRaw(lambda, phi) {
        var lambda2 = lambda * lambda,
          phi2 = phi * phi
        return [lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)), phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032))]
      }

      laskowskiRaw.invert = function (x, y) {
        var lambda = (0, _math.sign)(x) * _math.pi,
          phi = y / 2,
          i = 50
        do {
          var lambda2 = lambda * lambda,
            phi2 = phi * phi,
            lambdaPhi = lambda * phi,
            fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x,
            fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y,
            deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009),
            deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2),
            deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 0.000199025 * lambda2 + 2 * -0.02855 * phi2),
            deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 0.000199025 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2),
            denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda,
            deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
            deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator
          lambda -= deltaLambda, phi -= deltaPhi
        } while (((0, _math.abs)(deltaLambda) > _math.epsilon || (0, _math.abs)(deltaPhi) > _math.epsilon) && --i > 0)
        return i && [lambda, phi]
      }
      /***/
    },
    /* 374 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.littrowRaw = littrowRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(littrowRaw).scale(144.049).clipAngle(90 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function littrowRaw(lambda, phi) {
        return [(0, _math.sin)(lambda) / (0, _math.cos)(phi), (0, _math.tan)(phi) * (0, _math.cos)(lambda)]
      }

      littrowRaw.invert = function (x, y) {
        var x2 = x * x,
          y2 = y * y,
          y2_1 = y2 + 1,
          cosPhi = x ? _math.sqrt1_2 * (0, _math.sqrt)((y2_1 - (0, _math.sqrt)(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / (0, _math.sqrt)(y2_1)
        return [(0, _math.asin)(x * cosPhi), (0, _math.sign)(y) * (0, _math.acos)(cosPhi)]
      }
      /***/
    },
    /* 375 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.loximuthalRaw = loximuthalRaw

      exports.default = function () {
        return (0, _parallel2.default)(loximuthalRaw).parallel(40).scale(158.837)
      }

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      var _math = __webpack_require__(1)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function loximuthalRaw(phi0) {
        var cosPhi0 = (0, _math.cos)(phi0),
          tanPhi0 = (0, _math.tan)(_math.quarterPi + phi0 / 2)

        function forward(lambda, phi) {
          var y = phi - phi0,
            x = (0, _math.abs)(y) < _math.epsilon ? lambda * cosPhi0 : (0, _math.abs)(x = _math.quarterPi + phi / 2) < _math.epsilon || (0, _math.abs)((0, _math.abs)(x) - _math.halfPi) < _math.epsilon ? 0 : lambda * y / (0, _math.log)((0, _math.tan)(x) / tanPhi0)
          return [x, y]
        }

        forward.invert = function (x, y) {
          var lambda,
            phi = y + phi0
          return [(0, _math.abs)(y) < _math.epsilon ? x / cosPhi0 : (0, _math.abs)(lambda = _math.quarterPi + phi / 2) < _math.epsilon || (0, _math.abs)((0, _math.abs)(lambda) - _math.halfPi) < _math.epsilon ? 0 : x * (0, _math.log)((0, _math.tan)(lambda) / tanPhi0) / y, phi]
        }

        return forward
      }
      /***/
    },
    /* 376 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.millerRaw = millerRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(millerRaw).scale(108.318)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function millerRaw(lambda, phi) {
        return [lambda, 1.25 * (0, _math.log)((0, _math.tan)(_math.quarterPi + 0.4 * phi))]
      }

      millerRaw.invert = function (x, y) {
        return [x, 2.5 * (0, _math.atan)((0, _math.exp)(0.8 * y)) - 0.625 * _math.pi]
      }
      /***/
    },
    /* 377 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.modifiedStereographicRaw = modifiedStereographicRaw
      exports.modifiedStereographicAlaska = modifiedStereographicAlaska
      exports.modifiedStereographicGs48 = modifiedStereographicGs48
      exports.modifiedStereographicGs50 = modifiedStereographicGs50
      exports.modifiedStereographicMiller = modifiedStereographicMiller
      exports.modifiedStereographicLee = modifiedStereographicLee
      exports.default = modifiedStereographic

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function modifiedStereographicRaw(C) {
        var m = C.length - 1

        function forward(lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            k = 2 / (1 + cosPhi * (0, _math.cos)(lambda)),
            zr = k * cosPhi * (0, _math.sin)(lambda),
            zi = k * (0, _math.sin)(phi),
            i = m,
            w = C[i],
            ar = w[0],
            ai = w[1],
            t
          while (--i >= 0) {
            w = C[i]
            ar = w[0] + zr * (t = ar) - zi * ai
            ai = w[1] + zr * ai + zi * t
          }
          ar = zr * (t = ar) - zi * ai
          ai = zr * ai + zi * t
          return [ar, ai]
        }

        forward.invert = function (x, y) {
          var i = 20,
            zr = x,
            zi = y
          do {
            var j = m,
              w = C[j],
              ar = w[0],
              ai = w[1],
              br = 0,
              bi = 0,
              t

            while (--j >= 0) {
              w = C[j]
              br = ar + zr * (t = br) - zi * bi
              bi = ai + zr * bi + zi * t
              ar = w[0] + zr * (t = ar) - zi * ai
              ai = w[1] + zr * ai + zi * t
            }
            br = ar + zr * (t = br) - zi * bi
            bi = ai + zr * bi + zi * t
            ar = zr * (t = ar) - zi * ai - x
            ai = zr * ai + zi * t - y

            var denominator = br * br + bi * bi,
              deltar,
              deltai
            zr -= deltar = (ar * br + ai * bi) / denominator
            zi -= deltai = (ai * br - ar * bi) / denominator
          } while ((0, _math.abs)(deltar) + (0, _math.abs)(deltai) > _math.epsilon * _math.epsilon && --i > 0)

          if (i) {
            var rho = (0, _math.sqrt)(zr * zr + zi * zi),
              c = 2 * (0, _math.atan)(rho * 0.5),
              sinc = (0, _math.sin)(c)
            return [(0, _math.atan2)(zr * sinc, rho * (0, _math.cos)(c)), rho ? (0, _math.asin)(zi * sinc / rho) : 0]
          }
        }

        return forward
      }

      var alaska = [
          [0.9972523, 0],
          [0.0052513, -0.0041175],
          [0.0074606, 0.0048125],
          [-0.0153783, -0.1968253],
          [0.0636871, -0.1408027],
          [0.3660976, -0.2937382]
        ],
        gs48 = [
          [0.98879, 0],
          [0, 0],
          [-0.050909, 0],
          [0, 0],
          [0.075528, 0]
        ],
        gs50 = [
          [0.9842990, 0],
          [0.0211642, 0.0037608],
          [-0.1036018, -0.0575102],
          [-0.0329095, -0.0320119],
          [0.0499471, 0.1223335],
          [0.0260460, 0.0899805],
          [0.0007388, -0.1435792],
          [0.0075848, -0.1334108],
          [-0.0216473, 0.0776645],
          [-0.0225161, 0.0853673]
        ],
        miller = [
          [0.9245, 0],
          [0, 0],
          [0.01943, 0]
        ],
        lee = [
          [0.721316, 0],
          [0, 0],
          [-0.00881625, -0.00617325]
        ]

      function modifiedStereographicAlaska() {
        return modifiedStereographic(alaska, [152, -64]).scale(1500).center([-160.908, 62.4864]).clipAngle(25)
      }

      function modifiedStereographicGs48() {
        return modifiedStereographic(gs48, [95, -38]).scale(1000).clipAngle(55).center([-96.5563, 38.8675])
      }

      function modifiedStereographicGs50() {
        return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628])
      }

      function modifiedStereographicMiller() {
        return modifiedStereographic(miller, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82)
      }

      function modifiedStereographicLee() {
        return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10])
      }

      function modifiedStereographic(coefficients, rotate) {
        var p = (0, _d3Geo.geoProjection)(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90),
          r = (0, _d3Geo.geoRotation)(rotate),
          center = p.center

        delete p.rotate

        p.center = function (_) {
          return arguments.length ? center(r(_)) : r.invert(center())
        }

        return p
      }
      /***/
    },
    /* 378 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mtFlatPolarParabolicRaw = mtFlatPolarParabolicRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(mtFlatPolarParabolicRaw).scale(164.859)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var sqrt6 = (0, _math.sqrt)(6),
        sqrt7 = (0, _math.sqrt)(7)

      function mtFlatPolarParabolicRaw(lambda, phi) {
        var theta = (0, _math.asin)(7 * (0, _math.sin)(phi) / (3 * sqrt6))
        return [sqrt6 * lambda * (2 * (0, _math.cos)(2 * theta / 3) - 1) / sqrt7, 9 * (0, _math.sin)(theta / 3) / sqrt7]
      }

      mtFlatPolarParabolicRaw.invert = function (x, y) {
        var theta = 3 * (0, _math.asin)(y * sqrt7 / 9)
        return [x * sqrt7 / (sqrt6 * (2 * (0, _math.cos)(2 * theta / 3) - 1)), (0, _math.asin)((0, _math.sin)(theta) * 3 * sqrt6 / 7)]
      }
      /***/
    },
    /* 379 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mtFlatPolarQuarticRaw = mtFlatPolarQuarticRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(mtFlatPolarQuarticRaw).scale(188.209)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function mtFlatPolarQuarticRaw(lambda, phi) {
        var k = (1 + _math.sqrt1_2) * (0, _math.sin)(phi),
          theta = phi
        for (var i = 0, delta; i < 25; i++) {
          theta -= delta = ((0, _math.sin)(theta / 2) + (0, _math.sin)(theta) - k) / (0.5 * (0, _math.cos)(theta / 2) + (0, _math.cos)(theta))
          if ((0, _math.abs)(delta) < _math.epsilon) break
        }
        return [lambda * (1 + 2 * (0, _math.cos)(theta) / (0, _math.cos)(theta / 2)) / (3 * _math.sqrt2), 2 * (0, _math.sqrt)(3) * (0, _math.sin)(theta / 2) / (0, _math.sqrt)(2 + _math.sqrt2)]
      }

      mtFlatPolarQuarticRaw.invert = function (x, y) {
        var sinTheta_2 = y * (0, _math.sqrt)(2 + _math.sqrt2) / (2 * (0, _math.sqrt)(3)),
          theta = 2 * (0, _math.asin)(sinTheta_2)
        return [3 * _math.sqrt2 * x / (1 + 2 * (0, _math.cos)(theta) / (0, _math.cos)(theta / 2)), (0, _math.asin)((sinTheta_2 + (0, _math.sin)(theta)) / (1 + _math.sqrt1_2))]
      }
      /***/
    },
    /* 380 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.mtFlatPolarSinusoidalRaw = mtFlatPolarSinusoidalRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(mtFlatPolarSinusoidalRaw).scale(166.518)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function mtFlatPolarSinusoidalRaw(lambda, phi) {
        var A = (0, _math.sqrt)(6 / (4 + _math.pi)),
          k = (1 + _math.pi / 4) * (0, _math.sin)(phi),
          theta = phi / 2
        for (var i = 0, delta; i < 25; i++) {
          theta -= delta = (theta / 2 + (0, _math.sin)(theta) - k) / (0.5 + (0, _math.cos)(theta))
          if ((0, _math.abs)(delta) < _math.epsilon) break
        }
        return [A * (0.5 + (0, _math.cos)(theta)) * lambda / 1.5, A * theta]
      }

      mtFlatPolarSinusoidalRaw.invert = function (x, y) {
        var A = (0, _math.sqrt)(6 / (4 + _math.pi)),
          theta = y / A
        if ((0, _math.abs)((0, _math.abs)(theta) - _math.halfPi) < _math.epsilon) theta = theta < 0 ? -_math.halfPi : _math.halfPi
        return [1.5 * x / (A * (0.5 + (0, _math.cos)(theta))), (0, _math.asin)((theta / 2 + (0, _math.sin)(theta)) / (1 + _math.pi / 4))]
      }
      /***/
    },
    /* 381 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.naturalEarthRaw = naturalEarthRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(naturalEarthRaw).scale(175.295)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function naturalEarthRaw(lambda, phi) {
        var phi2 = phi * phi,
          phi4 = phi2 * phi2
        return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))]
      }

      naturalEarthRaw.invert = function (x, y) {
        var phi = y,
          i = 25,
          delta
        do {
          var phi2 = phi * phi,
            phi4 = phi2 * phi2
          phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)))
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi]
      }
      /***/
    },
    /* 382 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.naturalEarth2Raw = naturalEarth2Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(naturalEarth2Raw).scale(175.295)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function naturalEarth2Raw(lambda, phi) {
        var phi2 = phi * phi,
          phi4 = phi2 * phi2,
          phi6 = phi2 * phi4
        return [lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)), phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))]
      }

      naturalEarth2Raw.invert = function (x, y) {
        var phi = y,
          i = 25,
          delta,
          phi2,
          phi4,
          phi6
        do {
          phi2 = phi * phi;
          phi4 = phi2 * phi2
          phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4)) - y) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -0.00396 * phi4))
        } while ((0, _math.abs)(delta) > _math.epsilon2 && --i > 0)
        phi2 = phi * phi;
        phi4 = phi2 * phi2;
        phi6 = phi2 * phi4
        return [x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)), phi]
      }
      /***/
    },
    /* 383 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.nellHammerRaw = nellHammerRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(nellHammerRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function nellHammerRaw(lambda, phi) {
        return [lambda * (1 + (0, _math.cos)(phi)) / 2, 2 * (phi - (0, _math.tan)(phi / 2))]
      }

      nellHammerRaw.invert = function (x, y) {
        var p = y / 2
        for (var i = 0, delta = Infinity; i < 10 && (0, _math.abs)(delta) > _math.epsilon; ++i) {
          var c = (0, _math.cos)(y / 2)
          y -= delta = (y - (0, _math.tan)(y / 2) - p) / (1 - 0.5 / (c * c))
        }
        return [2 * x / (1 + (0, _math.cos)(y)), y]
      }
      /***/
    },
    /* 384 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.pattersonRaw = pattersonRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(pattersonRaw).scale(139.319)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      // Based on Java implementation by Bojan Savric.
      // https://github.com/OSUCartography/JMapProjLib/blob/master/src/com/jhlabs/map/proj/PattersonProjection.java

      var pattersonK1 = 1.0148,
        pattersonK2 = 0.23185,
        pattersonK3 = -0.14499,
        pattersonK4 = 0.02406,
        pattersonC1 = pattersonK1,
        pattersonC2 = 5 * pattersonK2,
        pattersonC3 = 7 * pattersonK3,
        pattersonC4 = 9 * pattersonK4,
        pattersonYmax = 1.790857183

      function pattersonRaw(lambda, phi) {
        var phi2 = phi * phi
        return [lambda, phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))]
      }

      pattersonRaw.invert = function (x, y) {
        if (y > pattersonYmax) y = pattersonYmax;
        else if (y < -pattersonYmax) y = -pattersonYmax
        var yc = y,
          delta

        do {
          // Newton-Raphson
          var y2 = yc * yc
          yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)))
        } while ((0, _math.abs)(delta) > _math.epsilon)

        return [x, yc]
      }
      /***/
    },
    /* 385 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.polyconicRaw = polyconicRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(polyconicRaw).scale(103.74)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function polyconicRaw(lambda, phi) {
        if ((0, _math.abs)(phi) < _math.epsilon) return [lambda, 0]
        var tanPhi = (0, _math.tan)(phi),
          k = lambda * (0, _math.sin)(phi)
        return [(0, _math.sin)(k) / tanPhi, phi + (1 - (0, _math.cos)(k)) / tanPhi]
      }

      polyconicRaw.invert = function (x, y) {
        if ((0, _math.abs)(y) < _math.epsilon) return [x, 0]
        var k = x * x + y * y,
          phi = y * 0.5,
          i = 10,
          delta
        do {
          var tanPhi = (0, _math.tan)(phi),
            secPhi = 1 / (0, _math.cos)(phi),
            j = k - 2 * y * phi + phi * phi
          phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi)
        } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
        tanPhi = (0, _math.tan)(phi)
        return [((0, _math.abs)(y) < (0, _math.abs)(phi + 1 / tanPhi) ? (0, _math.asin)(x * tanPhi) : (0, _math.sign)(x) * ((0, _math.acos)((0, _math.abs)(x * tanPhi)) + _math.halfPi)) / (0, _math.sin)(phi), phi]
      }
      /***/
    },
    /* 386 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        var u = subtract(a[1], a[0]),
          v = subtract(b[1], b[0]),
          phi = angle(u, v),
          s = length(u) / length(v)

        return multiply([1, 0, a[0][0], 0, 1, a[0][1]], multiply([s, 0, 0, 0, s, 0], multiply([(0, _math.cos)(phi), (0, _math.sin)(phi), 0, -(0, _math.sin)(phi), (0, _math.cos)(phi), 0], [1, 0, -b[0][0], 0, 1, -b[0][1]])))
      }

      exports.inverse = inverse
      exports.multiply = multiply

      var _math = __webpack_require__(1)

      // Inverts a transform matrix.
      function inverse(m) {
        var k = 1 / (m[0] * m[4] - m[1] * m[3])
        return [k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]), -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])]
      }

      // Multiplies two 3x2 matrices.

      // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:
      // [a, b, c,
      //  d, e, f,
      //  0, 0, 1] - this redundant row is left out.

      // Transform matrix for [a0, a1] -> [b0, b1].
      function multiply(a, b) {
        return [a[0] * b[0] + a[1] * b[3], a[0] * b[1] + a[1] * b[4], a[0] * b[2] + a[1] * b[5] + a[2], a[3] * b[0] + a[4] * b[3], a[3] * b[1] + a[4] * b[4], a[3] * b[2] + a[4] * b[5] + a[5]]
      }

      // Subtracts 2D vectors.
      function subtract(a, b) {
        return [a[0] - b[0], a[1] - b[1]]
      }

      // Magnitude of a 2D vector.
      function length(v) {
        return (0, _math.sqrt)(v[0] * v[0] + v[1] * v[1])
      }

      // Angle between two 2D vectors.
      function angle(a, b) {
        return (0, _math.atan2)(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1])
      }
      /***/
    },
    /* 387 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (faceProjection) {
        faceProjection = faceProjection || function (face) {
          var c = (0, _d3Geo.geoCentroid)({
            type: 'MultiPoint',
            coordinates: face
          })
          return (0, _d3Geo.geoGnomonic)().scale(1).translate([0, 0]).rotate([-c[0], -c[1]])
        }

        var faces = _octahedron2.default.map(function (face) {
          return {
            face: face,
            project: faceProjection(face)
          }
        });

        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
          var node = faces[d]
          node && (node.children || (node.children = [])).push(faces[i])
        })

        return (0, _index2.default)(faces[0], function (lambda, phi) {
          return faces[lambda < -_math.pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math.pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5]
        }).scale(101.858).center([0, 45])
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _index = __webpack_require__(60)

      var _index2 = _interopRequireDefault(_index)

      var _octahedron = __webpack_require__(92)

      var _octahedron2 = _interopRequireDefault(_octahedron)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 388 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (faceProjection) {
        faceProjection = faceProjection || function (face) {
          var c = (0, _d3Geo.geoCentroid)({
            type: 'MultiPoint',
            coordinates: face
          })
          return (0, _d3Geo.geoProjection)(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180])
        }

        var faces = _octahedron2.default.map(function (face) {
          return {
            face: face,
            project: faceProjection(face)
          }
        });

        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
          var node = faces[d]
          node && (node.children || (node.children = [])).push(faces[i])
        })

        return (0, _index2.default)(faces[0], function (lambda, phi) {
          return faces[lambda < -_math.pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math.pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5]
        }).scale(121.906).center([0, 48.5904])
      }

      var _d3Geo = __webpack_require__(0)

      var _collignon = __webpack_require__(90)

      var _math = __webpack_require__(1)

      var _index = __webpack_require__(60)

      var _index2 = _interopRequireDefault(_index)

      var _octahedron = __webpack_require__(92)

      var _octahedron2 = _interopRequireDefault(_octahedron)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var kx = 2 / (0, _math.sqrt)(3)

      function collignonK(a, b) {
        var p = (0, _collignon.collignonRaw)(a, b)
        return [p[0] * kx, p[1]]
      }

      collignonK.invert = function (x, y) {
        return _collignon.collignonRaw.invert(x / kx, y)
      }
      /***/
    },
    /* 389 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (faceProjection) {
        faceProjection = faceProjection || function (face) {
          var c = face.length === 6 ? (0, _d3Geo.geoCentroid)({
            type: 'MultiPoint',
            coordinates: face
          }) : face[0]
          return (0, _d3Geo.geoGnomonic)().scale(1).translate([0, 0]).rotate([-c[0], -c[1]])
        }

        var w5 = _octahedron2.default.map(function (face) {
          var xyz = face.map(cartesian),
            n = xyz.length,
            a = xyz[n - 1],
            b,
            hexagon = []
          for (var i = 0; i < n; ++i) {
            b = xyz[i]
            hexagon.push(spherical([a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794, a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794, a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794]), spherical([b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794, b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794, b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794]))
            a = b
          }
          return hexagon
        })

        var cornerNormals = []

        var parents = [-1, 0, 0, 1, 0, 1, 4, 5]

        w5.forEach(function (hexagon, j) {
          var face = _octahedron2.default[j],
            n = face.length,
            normals = cornerNormals[j] = []
          for (var i = 0; i < n; ++i) {
            w5.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]])
            parents.push(j)
            normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])))
          }
        })

        var faces = w5.map(function (face) {
          return {
            project: faceProjection(face),
            face: face
          }
        })

        parents.forEach(function (d, i) {
          var parent = faces[d]
          parent && (parent.children || (parent.children = [])).push(faces[i])
        })

        function face(lambda, phi) {
          var cosphi = (0, _math.cos)(phi),
            p = [cosphi * (0, _math.cos)(lambda), cosphi * (0, _math.sin)(lambda), (0, _math.sin)(phi)]

          var hexagon = lambda < -_math.pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math.pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5

          var n = cornerNormals[hexagon]

          return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon]
        }

        return (0, _index2.default)(faces[0], face).scale(110.625).center([0, 45])
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _index = __webpack_require__(60)

      var _index2 = _interopRequireDefault(_index)

      var _octahedron = __webpack_require__(92)

      var _octahedron2 = _interopRequireDefault(_octahedron)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function dot(a, b) {
        for (var i = 0, n = a.length, s = 0; i < n; ++i) {
          s += a[i] * b[i]
        }
        return s
      }

      function cross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
      }

      // Converts 3D Cartesian to spherical coordinates (degrees).
      function spherical(cartesian) {
        return [(0, _math.atan2)(cartesian[1], cartesian[0]) * _math.degrees, (0, _math.asin)((0, _math.max)(-1, (0, _math.min)(1, cartesian[2]))) * _math.degrees]
      }

      // Converts spherical coordinates (degrees) to 3D Cartesian.
      function cartesian(coordinates) {
        var lambda = coordinates[0] * _math.radians,
          phi = coordinates[1] * _math.radians,
          cosphi = (0, _math.cos)(phi)
        return [cosphi * (0, _math.cos)(lambda), cosphi * (0, _math.sin)(lambda), (0, _math.sin)(phi)]
      }
      /***/
    },
    /* 390 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object, projection) {
        var stream = projection.stream,
          project
        if (!stream) throw new Error('invalid projection')
        switch (object && object.type) {
          case 'Feature':
            project = projectFeature;
            break
          case 'FeatureCollection':
            project = projectFeatureCollection;
            break
          default:
            project = projectGeometry;
            break
        }
        return project(object, stream)
      }

      var _d3Geo = __webpack_require__(0)

      var _noop = __webpack_require__(391)

      var _noop2 = _interopRequireDefault(_noop)

      var _clockwise = __webpack_require__(392)

      var _clockwise2 = _interopRequireDefault(_clockwise)

      var _contains = __webpack_require__(393)

      var _contains2 = _interopRequireDefault(_contains)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function projectFeatureCollection(o, stream) {
        return {
          type: 'FeatureCollection',
          features: o.features.map(function (f) {
            return projectFeature(f, stream)
          })
        }
      }

      function projectFeature(o, stream) {
        return {
          type: 'Feature',
          id: o.id,
          properties: o.properties,
          geometry: projectGeometry(o.geometry, stream)
        }
      }

      function projectGeometryCollection(o, stream) {
        return {
          type: 'GeometryCollection',
          geometries: o.geometries.map(function (o) {
            return projectGeometry(o, stream)
          })
        }
      }

      function projectGeometry(o, stream) {
        if (!o) return null
        if (o.type === 'GeometryCollection') return projectGeometryCollection(o, stream)
        var sink
        switch (o.type) {
          case 'Point':
            sink = sinkPoint;
            break
          case 'MultiPoint':
            sink = sinkPoint;
            break
          case 'LineString':
            sink = sinkLine;
            break
          case 'MultiLineString':
            sink = sinkLine;
            break
          case 'Polygon':
            sink = sinkPolygon;
            break
          case 'MultiPolygon':
            sink = sinkPolygon;
            break
          case 'Sphere':
            sink = sinkPolygon;
            break
          default:
            return null
        }
        (0, _d3Geo.geoStream)(o, stream(sink))
        return sink.result()
      }

      var points = [],
        lines = []

      var sinkPoint = {
        point: function point(x, y) {
          points.push([x, y])
        },
        result: function result() {
          var result = !points.length ? null : points.length < 2 ? {
            type: 'Point',
            coordinates: points[0]
          } : {
            type: 'MultiPoint',
            coordinates: points
          }
          points = []
          return result
        }
      }

      var sinkLine = {
        lineStart: _noop2.default,
        point: function point(x, y) {
          points.push([x, y])
        },
        lineEnd: function lineEnd() {
          if (points.length) lines.push(points), points = []
        },
        result: function result() {
          var result = !lines.length ? null : lines.length < 2 ? {
            type: 'LineString',
            coordinates: lines[0]
          } : {
            type: 'MultiLineString',
            coordinates: lines
          }
          lines = []
          return result
        }
      }

      var sinkPolygon = {
        polygonStart: _noop2.default,
        lineStart: _noop2.default,
        point: function point(x, y) {
          points.push([x, y])
        },
        lineEnd: function lineEnd() {
          var n = points.length
          if (n) {
            do {
              points.push(points[0].slice())
            } while (++n < 4)
            lines.push(points), points = []
          }
        },
        polygonEnd: _noop2.default,
        result: function result() {
          if (!lines.length) return null
          var polygons = [],
            holes = []

          // https://github.com/d3/d3/issues/1558
          lines.forEach(function (ring) {
            if ((0, _clockwise2.default)(ring)) polygons.push([ring]);
            else holes.push(ring)
          })

          holes.forEach(function (hole) {
            var point = hole[0]
            polygons.some(function (polygon) {
              if ((0, _contains2.default)(polygon[0], point)) {
                polygon.push(hole)
                return true
              }
            }) || polygons.push([hole])
          })

          lines = []

          return !polygons.length ? null : polygons.length > 1 ? {
            type: 'MultiPolygon',
            coordinates: polygons
          } : {
            type: 'Polygon',
            coordinates: polygons[0]
          }
        }
      }
      /***/
    },
    /* 391 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {}
      /***/
    },
    /* 392 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (ring) {
        if ((n = ring.length) < 4) return false
        var i = 0,
          n,
          area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1]
        while (++i < n) {
          area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1]
        }
        return area <= 0
      }
      /***/
    },
    /* 393 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (ring, point) {
        var x = point[0],
          y = point[1],
          contains = false
        for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
          var pi = ring[i],
            xi = pi[0],
            yi = pi[1],
            pj = ring[j],
            xj = pj[0],
            yj = pj[1]
          if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains
        }
        return contains
      }
      /***/
    },
    /* 394 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_gringorten.gringortenRaw).scale(176.423)
      }

      var _gringorten = __webpack_require__(175)

      var _index = __webpack_require__(93)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 395 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _index2.default)(_guyou.guyouRaw).scale(111.48)
      }

      var _guyou = __webpack_require__(177)

      var _index = __webpack_require__(93)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 396 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (input, digits) {
        if (!((digits = +digits) >= 0 && digits <= 20)) throw new Error('invalid digits')

        function quantizePoint(input) {
          var n = input.length,
            i = 2,
            output = new Array(n)
          output[0] = +input[0].toFixed(digits)
          output[1] = +input[1].toFixed(digits)
          while (i < n) {
            output[i] = input[i], ++i
          }
          return output
        }

        function quantizePoints(input) {
          return input.map(quantizePoint)
        }

        function quantizePolygon(input) {
          return input.map(quantizePoints)
        }

        function quantizeGeometry(input) {
          if (input == null) return input
          var output
          switch (input.type) {
            case 'GeometryCollection':
              output = {
                type: 'GeometryCollection',
                geometries: input.geometries.map(quantizeGeometry)
              };
              break
            case 'Point':
              output = {
                type: 'Point',
                coordinates: quantizePoint(input.coordinates)
              };
              break
            case 'MultiPoint':
            case 'LineString':
              output = {
                type: input.type,
                coordinates: quantizePoints(input.coordinates)
              };
              break
            case 'MultiLineString':
            case 'Polygon':
              output = {
                type: input.type,
                coordinates: quantizePolygon(input.coordinates)
              };
              break
            case 'MultiPolygon':
              output = {
                type: 'MultiPolygon',
                coordinates: input.coordinates.map(quantizePolygon)
              };
              break
            default:
              return input
          }
          if (input.bbox != null) output.bbox = input.bbox
          return output
        }

        function quantizeFeature(input) {
          var output = {
            type: 'Feature',
            properties: input.properties,
            geometry: quantizeGeometry(input.geometry)
          }
          if (input.id != null) output.id = input.id
          if (input.bbox != null) output.bbox = input.bbox
          return output
        }

        if (input != null) {
          switch (input.type) {
            case 'Feature':
              return quantizeFeature(input)
            case 'FeatureCollection':
              {
                var output = {
                  type: 'FeatureCollection',
                  features: input.features.map(quantizeFeature)
                }
                if (input.bbox != null) output.bbox = input.bbox
                return output
              }
            default:
              return quantizeGeometry(input)
          }
        }

        return input
      }
      /***/
    },
    /* 397 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.rectangularPolyconicRaw = rectangularPolyconicRaw

      exports.default = function () {
        return (0, _parallel2.default)(rectangularPolyconicRaw).scale(131.215)
      }

      var _math = __webpack_require__(1)

      var _parallel = __webpack_require__(35)

      var _parallel2 = _interopRequireDefault(_parallel)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function rectangularPolyconicRaw(phi0) {
        var sinPhi0 = (0, _math.sin)(phi0)

        function forward(lambda, phi) {
          var A = sinPhi0 ? (0, _math.tan)(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2
          if (!phi) return [2 * A, -phi0]
          var E = 2 * (0, _math.atan)(A * (0, _math.sin)(phi)),
            cotPhi = 1 / (0, _math.tan)(phi)
          return [(0, _math.sin)(E) * cotPhi, phi + (1 - (0, _math.cos)(E)) * cotPhi - phi0]
        }

        // TODO return null for points outside outline.
        forward.invert = function (x, y) {
          if ((0, _math.abs)(y += phi0) < _math.epsilon) return [sinPhi0 ? 2 * (0, _math.atan)(sinPhi0 * x / 2) / sinPhi0 : x, 0]
          var k = x * x + y * y,
            phi = 0,
            i = 10,
            delta
          do {
            var tanPhi = (0, _math.tan)(phi),
              secPhi = 1 / (0, _math.cos)(phi),
              j = k - 2 * y * phi + phi * phi
            phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi)
          } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0)
          var E = x * (tanPhi = (0, _math.tan)(phi)),
            A = (0, _math.tan)((0, _math.abs)(y) < (0, _math.abs)(phi + 1 / tanPhi) ? (0, _math.asin)(E) * 0.5 : (0, _math.acos)(E) * 0.5 + _math.pi / 4) / (0, _math.sin)(phi)
          return [sinPhi0 ? 2 * (0, _math.atan)(sinPhi0 * A) / sinPhi0 : 2 * A, phi]
        }

        return forward
      }
      /***/
    },
    /* 398 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.robinsonRaw = robinsonRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(robinsonRaw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var K = [
        [0.9986, -0.062],
        [1.0000, 0.0000],
        [0.9986, 0.0620],
        [0.9954, 0.1240],
        [0.9900, 0.1860],
        [0.9822, 0.2480],
        [0.9730, 0.3100],
        [0.9600, 0.3720],
        [0.9427, 0.4340],
        [0.9216, 0.4958],
        [0.8962, 0.5571],
        [0.8679, 0.6176],
        [0.8350, 0.6769],
        [0.7986, 0.7346],
        [0.7597, 0.7903],
        [0.7186, 0.8435],
        [0.6732, 0.8936],
        [0.6213, 0.9394],
        [0.5722, 0.9761],
        [0.5322, 1.0000]
      ]

      K.forEach(function (d) {
        d[1] *= 1.0144
      })

      function robinsonRaw(lambda, phi) {
        var i = (0, _math.min)(18, (0, _math.abs)(phi) * 36 / _math.pi),
          i0 = (0, _math.floor)(i),
          di = i - i0,
          ax = (k = K[i0])[0],
          ay = k[1],
          bx = (k = K[++i0])[0],
          by = k[1],
          cx = (k = K[(0, _math.min)(19, ++i0)])[0],
          cy = k[1],
          k
        return [lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (phi > 0 ? _math.halfPi : -_math.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)]
      }

      robinsonRaw.invert = function (x, y) {
        var yy = y / _math.halfPi,
          phi = yy * 90,
          i = (0, _math.min)(18, (0, _math.abs)(phi / 5)),
          i0 = (0, _math.max)(0, (0, _math.floor)(i))
        do {
          var ay = K[i0][1],
            by = K[i0 + 1][1],
            cy = K[(0, _math.min)(19, i0 + 2)][1],
            u = cy - ay,
            v = cy - 2 * by + ay,
            t = 2 * ((0, _math.abs)(yy) - by) / u,
            c = v / u,
            di = t * (1 - c * t * (1 - 2 * c * t))
          if (di >= 0 || i0 === 1) {
            phi = (y >= 0 ? 5 : -5) * (di + i)
            var j = 50,
              delta
            do {
              i = (0, _math.min)(18, (0, _math.abs)(phi) / 5)
              i0 = (0, _math.floor)(i)
              di = i - i0
              ay = K[i0][1]
              by = K[i0 + 1][1]
              cy = K[(0, _math.min)(19, i0 + 2)][1]
              phi -= (delta = (y >= 0 ? _math.halfPi : -_math.halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math.degrees
            } while ((0, _math.abs)(delta) > _math.epsilon2 && --j > 0)
            break
          }
        } while (--i0 >= 0)
        var ax = K[i0][0],
          bx = K[i0 + 1][0],
          cx = K[(0, _math.min)(19, i0 + 2)][0]
        return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), phi * _math.radians]
      }
      /***/
    },
    /* 399 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.satelliteRaw = satelliteRaw

      exports.default = function () {
        var distance = 2,
          omega = 0,
          m = (0, _d3Geo.geoProjectionMutator)(satelliteRaw),
          p = m(distance, omega)

        // As a multiple of radius.
        p.distance = function (_) {
          if (!arguments.length) return distance
          return m(distance = +_, omega)
        }

        p.tilt = function (_) {
          if (!arguments.length) return omega * _math.degrees
          return m(distance, omega = _ * _math.radians)
        }

        return p.scale(432.147).clipAngle((0, _math.acos)(1 / distance) * _math.degrees - 1e-6)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function satelliteVerticalRaw(P) {
        function forward(lambda, phi) {
          var cosPhi = (0, _math.cos)(phi),
            k = (P - 1) / (P - cosPhi * (0, _math.cos)(lambda))
          return [k * cosPhi * (0, _math.sin)(lambda), k * (0, _math.sin)(phi)]
        }

        forward.invert = function (x, y) {
          var rho2 = x * x + y * y,
            rho = (0, _math.sqrt)(rho2),
            sinc = (P - (0, _math.sqrt)(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1))
          return [(0, _math.atan2)(x * sinc, rho * (0, _math.sqrt)(1 - sinc * sinc)), rho ? (0, _math.asin)(y * sinc / rho) : 0]
        }

        return forward
      }

      function satelliteRaw(P, omega) {
        var vertical = satelliteVerticalRaw(P)
        if (!omega) return vertical
        var cosOmega = (0, _math.cos)(omega),
          sinOmega = (0, _math.sin)(omega)

        function forward(lambda, phi) {
          var coordinates = vertical(lambda, phi),
            y = coordinates[1],
            A = y * sinOmega / (P - 1) + cosOmega
          return [coordinates[0] * cosOmega / A, y / A]
        }

        forward.invert = function (x, y) {
          var k = (P - 1) / (P - 1 - y * sinOmega)
          return vertical.invert(k * x, k * y * cosOmega)
        }

        return forward
      }
      /***/
    },
    /* 400 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (input) {
        if (input == null) return input
        switch (input.type) {
          case 'Feature':
            return stitchFeature(input)
          case 'FeatureCollection':
            {
              var output = {
                type: 'FeatureCollection',
                features: input.features.map(stitchFeature)
              }
              if (input.bbox != null) output.bbox = input.bbox
              return output
            }
          default:
            return stitchGeometry(input)
        }
      }

      var epsilon = 1e-4,
        epsilonInverse = 1e4,
        x0 = -180,
        x0e = x0 + epsilon,
        x1 = 180,
        x1e = x1 - epsilon,
        y0 = -90,
        y0e = y0 + epsilon,
        y1 = 90,
        y1e = y1 - epsilon

      function nonempty(coordinates) {
        return coordinates.length > 0
      }

      function quantize(x) {
        return Math.floor(x * epsilonInverse) / epsilonInverse
      }

      function normalizePoint(y) {
        return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)] // pole or antimeridian?
      }

      function clampPoint(p) {
        var x = p[0],
          y = p[1],
          clamped = false
        if (x <= x0e) x = x0, clamped = true;
        else if (x >= x1e) x = x1, clamped = true
        if (y <= y0e) y = y0, clamped = true;
        else if (y >= y1e) y = y1, clamped = true
        return clamped ? [x, y] : p
      }

      function clampPoints(points) {
        return points.map(clampPoint)
      }

      // For each ring, detect where it crosses the antimeridian or pole.
      function extractFragments(rings, polygon, fragments) {
        for (var j = 0, m = rings.length; j < m; ++j) {
          var ring = rings[j].slice()

          // By default, assume that this ring doesnt need any stitching.
          fragments.push({
            index: -1,
            polygon: polygon,
            ring: ring
          })

          for (var i = 0, n = ring.length; i < n; ++i) {
            var point = ring[i],
              x = point[0],
              y = point[1]

            // If this is an antimeridian or polar point
            if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
              ring[i] = clampPoint(point)

              // Advance through any antimeridian or polar points
              for (var k = i + 1; k < n; ++k) {
                var pointk = ring[k],
                  xk = pointk[0],
                  yk = pointk[1]
                if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break
              }

              // If this was just a single antimeridian or polar point,
              // we dont need to cut this ring into a fragment;
              // we can just leave it as-is.
              if (k === i + 1) continue

              // Otherwise, if this is not the first point in the ring,
              // cut the current fragment so that it ends at the current point.
              // The current point is also normalized for later joining.
              if (i) {
                var fragmentBefore = {
                  index: -1,
                  polygon: polygon,
                  ring: ring.slice(0, i + 1)
                }
                fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y)
                fragments[fragments.length - 1] = fragmentBefore
              }

              // If the ring started with an antimeridian fragment,
              // we can ignore that fragment entirely.
              else fragments.pop()

              // If the remainder of the ring is an antimeridian fragment,
              // move on to the next ring.
              if (k >= n) break

              // Otherwise, add the remaining ring fragment and continue.
              fragments.push({
                index: -1,
                polygon: polygon,
                ring: ring = ring.slice(k - 1)
              })
              ring[0] = normalizePoint(ring[0][1])
              i = -1
              n = ring.length
            }
          }
        }
      }

      // Now stitch the fragments back together into rings.
      function stitchFragments(fragments) {
        var i,
          n = fragments.length

        // To connect the fragments start-to-end, create a simple index by end.
        var fragmentByStart = {},
          fragmentByEnd = {},
          fragment,
          start,
          startFragment,
          end,
          endFragment

        // For each fragment
        for (i = 0; i < n; ++i) {
          fragment = fragments[i]
          start = fragment.ring[0]
          end = fragment.ring[fragment.ring.length - 1]

          // If this fragment is closed, add it as a standalone ring.
          if (start[0] === end[0] && start[1] === end[1]) {
            fragment.polygon.push(fragment.ring)
            fragments[i] = null
            continue
          }

          fragment.index = i
          fragmentByStart[start] = fragmentByEnd[end] = fragment
        }

        // For each open fragment
        for (i = 0; i < n; ++i) {
          fragment = fragments[i]
          if (fragment) {
            start = fragment.ring[0]
            end = fragment.ring[fragment.ring.length - 1]
            startFragment = fragmentByEnd[start]
            endFragment = fragmentByStart[end]

            delete fragmentByStart[start]
            delete fragmentByEnd[end]

            // If this fragment is closed, add it as a standalone ring.
            if (start[0] === end[0] && start[1] === end[1]) {
              fragment.polygon.push(fragment.ring)
              continue
            }

            if (startFragment) {
              delete fragmentByEnd[start]
              delete fragmentByStart[startFragment.ring[0]]
              startFragment.ring.pop() // drop the shared coordinate
              fragments[startFragment.index] = null
              fragment = {
                index: -1,
                polygon: startFragment.polygon,
                ring: startFragment.ring.concat(fragment.ring)
              }

              if (startFragment === endFragment) {
                // Connect both ends to this single fragment to create a ring.
                fragment.polygon.push(fragment.ring)
              } else {
                fragment.index = n++
                  fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment)
              }
            } else if (endFragment) {
              delete fragmentByStart[end]
              delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]]
              fragment.ring.pop() // drop the shared coordinate
              fragment = {
                index: n++,
                polygon: endFragment.polygon,
                ring: fragment.ring.concat(endFragment.ring)
              }
              fragments[endFragment.index] = null
              fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment)
            } else {
              fragment.ring.push(fragment.ring[0]) // close ring
              fragment.polygon.push(fragment.ring)
            }
          }
        }
      }

      function stitchFeature(input) {
        var output = {
          type: 'Feature',
          geometry: stitchGeometry(input.geometry)
        }
        if (input.id != null) output.id = input.id
        if (input.bbox != null) output.bbox = input.bbox
        if (input.properties != null) output.properties = input.properties
        return output
      }

      function stitchGeometry(input) {
        if (input == null) return input
        var output, fragments, i, n
        switch (input.type) {
          case 'GeometryCollection':
            output = {
              type: 'GeometryCollection',
              geometries: input.geometries.map(stitchGeometry)
            };
            break
          case 'Point':
            output = {
              type: 'Point',
              coordinates: clampPoint(input.coordinates)
            };
            break
          case 'MultiPoint':
          case 'LineString':
            output = {
              type: input.type,
              coordinates: clampPoints(input.coordinates)
            };
            break
          case 'MultiLineString':
            output = {
              type: 'MultiLineString',
              coordinates: input.coordinates.map(clampPoints)
            };
            break
          case 'Polygon':
            {
              var polygon = []
              extractFragments(input.coordinates, polygon, fragments = [])
              stitchFragments(fragments)
              output = {
                type: 'Polygon',
                coordinates: polygon
              }
              break
            }
          case 'MultiPolygon':
            {
              fragments = [],
              i = -1,
              n = input.coordinates.length
              var polygons = new Array(n)
              while (++i < n) {
                extractFragments(input.coordinates[i], polygons[i] = [], fragments)
              }
              stitchFragments(fragments)
              output = {
                type: 'MultiPolygon',
                coordinates: polygons.filter(nonempty)
              }
              break
            }
          default:
            return input
        }
        if (input.bbox != null) output.bbox = input.bbox
        return output
      }
      /***/
    },
    /* 401 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.timesRaw = timesRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(timesRaw).scale(146.153)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function timesRaw(lambda, phi) {
        var t = (0, _math.tan)(phi / 2),
          s = (0, _math.sin)(_math.quarterPi * t)
        return [lambda * (0.74482 - 0.34588 * s * s), 1.70711 * t]
      }

      timesRaw.invert = function (x, y) {
        var t = y / 1.70711,
          s = (0, _math.sin)(_math.quarterPi * t)
        return [x / (0.74482 - 0.34588 * s * s), 2 * (0, _math.atan)(t)]
      }
      /***/
    },
    /* 402 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.twoPointAzimuthalRaw = twoPointAzimuthalRaw
      exports.twoPointAzimuthalUsa = twoPointAzimuthalUsa
      exports.default = twoPointAzimuthal

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _twoPoint = __webpack_require__(179)

      var _twoPoint2 = _interopRequireDefault(_twoPoint)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function twoPointAzimuthalRaw(d) {
        var cosd = (0, _math.cos)(d)

        function forward(lambda, phi) {
          var coordinates = (0, _d3Geo.geoGnomonicRaw)(lambda, phi)
          coordinates[0] *= cosd
          return coordinates
        }

        forward.invert = function (x, y) {
          return _d3Geo.geoGnomonicRaw.invert(x / cosd, y)
        }

        return forward
      }

      function twoPointAzimuthalUsa() {
        return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400)
      }

      function twoPointAzimuthal(p0, p1) {
        return (0, _twoPoint2.default)(twoPointAzimuthalRaw, p0, p1)
      }
      /***/
    },
    /* 403 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.twoPointEquidistantRaw = twoPointEquidistantRaw
      exports.twoPointEquidistantUsa = twoPointEquidistantUsa
      exports.default = twoPointEquidistant

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _twoPoint = __webpack_require__(179)

      var _twoPoint2 = _interopRequireDefault(_twoPoint)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      // TODO clip to ellipse
      function twoPointEquidistantRaw(z0) {
        if (!(z0 *= 2)) return _d3Geo.geoAzimuthalEquidistantRaw
        var lambdaa = -z0 / 2,
          lambdab = -lambdaa,
          z02 = z0 * z0,
          tanLambda0 = (0, _math.tan)(lambdab),
          S = 0.5 / (0, _math.sin)(lambdab)

        function forward(lambda, phi) {
          var za = (0, _math.acos)((0, _math.cos)(phi) * (0, _math.cos)(lambda - lambdaa)),
            zb = (0, _math.acos)((0, _math.cos)(phi) * (0, _math.cos)(lambda - lambdab)),
            ys = phi < 0 ? -1 : 1
          za *= za, zb *= zb
          return [(za - zb) / (2 * z0), ys * (0, _math.sqrt)(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)]
        }

        forward.invert = function (x, y) {
          var y2 = y * y,
            cosza = (0, _math.cos)((0, _math.sqrt)(y2 + (t = x + lambdaa) * t)),
            coszb = (0, _math.cos)((0, _math.sqrt)(y2 + (t = x + lambdab) * t)),
            t,
            d
          return [(0, _math.atan2)(d = cosza - coszb, t = (cosza + coszb) * tanLambda0), (y < 0 ? -1 : 1) * (0, _math.acos)((0, _math.sqrt)(t * t + d * d) * S)]
        }

        return forward
      }

      function twoPointEquidistantUsa() {
        return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571)
      }

      function twoPointEquidistant(p0, p1) {
        return (0, _twoPoint2.default)(twoPointEquidistantRaw, p0, p1)
      }
      /***/
    },
    /* 404 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.vanDerGrintenRaw = vanDerGrintenRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(vanDerGrintenRaw).scale(79.4183)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function vanDerGrintenRaw(lambda, phi) {
        if ((0, _math.abs)(phi) < _math.epsilon) return [lambda, 0]
        var sinTheta = (0, _math.abs)(phi / _math.halfPi),
          theta = (0, _math.asin)(sinTheta)
        if ((0, _math.abs)(lambda) < _math.epsilon || (0, _math.abs)((0, _math.abs)(phi) - _math.halfPi) < _math.epsilon) return [0, (0, _math.sign)(phi) * _math.pi * (0, _math.tan)(theta / 2)]
        var cosTheta = (0, _math.cos)(theta),
          A = (0, _math.abs)(_math.pi / lambda - lambda / _math.pi) / 2,
          A2 = A * A,
          G = cosTheta / (sinTheta + cosTheta - 1),
          P = G * (2 / sinTheta - 1),
          P2 = P * P,
          P2_A2 = P2 + A2,
          G_P2 = G - P2,
          Q = A2 + G
        return [(0, _math.sign)(lambda) * _math.pi * (A * G_P2 + (0, _math.sqrt)(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, (0, _math.sign)(phi) * _math.pi * (P * Q - A * (0, _math.sqrt)((A2 + 1) * P2_A2 - Q * Q)) / P2_A2]
      }

      vanDerGrintenRaw.invert = function (x, y) {
        if ((0, _math.abs)(y) < _math.epsilon) return [x, 0]
        if ((0, _math.abs)(x) < _math.epsilon) return [0, _math.halfPi * (0, _math.sin)(2 * (0, _math.atan)(y / _math.pi))]
        var x2 = (x /= _math.pi) * x,
          y2 = (y /= _math.pi) * y,
          x2_y2 = x2 + y2,
          z = x2_y2 * x2_y2,
          c1 = -(0, _math.abs)(y) * (1 + x2_y2),
          c2 = c1 - 2 * y2 + x2,
          c3 = -2 * c1 + 1 + 2 * y2 + z,
          d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27,
          a1 = (c1 - c2 * c2 / (3 * c3)) / c3,
          m1 = 2 * (0, _math.sqrt)(-a1 / 3),
          theta1 = (0, _math.acos)(3 * d / (a1 * m1)) / 3
        return [_math.pi * (x2_y2 - 1 + (0, _math.sqrt)(1 + 2 * (x2 - y2) + z)) / (2 * x), (0, _math.sign)(y) * _math.pi * (-m1 * (0, _math.cos)(theta1 + _math.pi / 3) - c2 / (3 * c3))]
      }
      /***/
    },
    /* 405 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.vanDerGrinten2Raw = vanDerGrinten2Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(vanDerGrinten2Raw).scale(79.4183)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function vanDerGrinten2Raw(lambda, phi) {
        if ((0, _math.abs)(phi) < _math.epsilon) return [lambda, 0]
        var sinTheta = (0, _math.abs)(phi / _math.halfPi),
          theta = (0, _math.asin)(sinTheta)
        if ((0, _math.abs)(lambda) < _math.epsilon || (0, _math.abs)((0, _math.abs)(phi) - _math.halfPi) < _math.epsilon) return [0, (0, _math.sign)(phi) * _math.pi * (0, _math.tan)(theta / 2)]
        var cosTheta = (0, _math.cos)(theta),
          A = (0, _math.abs)(_math.pi / lambda - lambda / _math.pi) / 2,
          A2 = A * A,
          x1 = cosTheta * ((0, _math.sqrt)(1 + A2) - A * cosTheta) / (1 + A2 * sinTheta * sinTheta)
        return [(0, _math.sign)(lambda) * _math.pi * x1, (0, _math.sign)(phi) * _math.pi * (0, _math.sqrt)(1 - x1 * (2 * A + x1))]
      }

      vanDerGrinten2Raw.invert = function (x, y) {
        if (!x) return [0, _math.halfPi * (0, _math.sin)(2 * (0, _math.atan)(y / _math.pi))]
        var x1 = (0, _math.abs)(x / _math.pi),
          A = (1 - x1 * x1 - (y /= _math.pi) * y) / (2 * x1),
          A2 = A * A,
          B = (0, _math.sqrt)(A2 + 1)
        return [(0, _math.sign)(x) * _math.pi * (B - A), (0, _math.sign)(y) * _math.halfPi * (0, _math.sin)(2 * (0, _math.atan2)((0, _math.sqrt)((1 - 2 * A * x1) * (A + B) - x1), (0, _math.sqrt)(B + A + x1)))]
      }
      /***/
    },
    /* 406 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.vanDerGrinten3Raw = vanDerGrinten3Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(vanDerGrinten3Raw).scale(79.4183)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function vanDerGrinten3Raw(lambda, phi) {
        if ((0, _math.abs)(phi) < _math.epsilon) return [lambda, 0]
        var sinTheta = phi / _math.halfPi,
          theta = (0, _math.asin)(sinTheta)
        if ((0, _math.abs)(lambda) < _math.epsilon || (0, _math.abs)((0, _math.abs)(phi) - _math.halfPi) < _math.epsilon) return [0, _math.pi * (0, _math.tan)(theta / 2)]
        var A = (_math.pi / lambda - lambda / _math.pi) / 2,
          y1 = sinTheta / (1 + (0, _math.cos)(theta))
        return [_math.pi * ((0, _math.sign)(lambda) * (0, _math.sqrt)(A * A + 1 - y1 * y1) - A), _math.pi * y1]
      }

      vanDerGrinten3Raw.invert = function (x, y) {
        if (!y) return [x, 0]
        var y1 = y / _math.pi,
          A = (_math.pi * _math.pi * (1 - y1 * y1) - x * x) / (2 * _math.pi * x)
        return [x ? _math.pi * ((0, _math.sign)(x) * (0, _math.sqrt)(A * A + 1) - A) : 0, _math.halfPi * (0, _math.sin)(2 * (0, _math.atan)(y1))]
      }
      /***/
    },
    /* 407 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.vanDerGrinten4Raw = vanDerGrinten4Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(vanDerGrinten4Raw).scale(127.16)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function vanDerGrinten4Raw(lambda, phi) {
        if (!phi) return [lambda, 0]
        var phi0 = (0, _math.abs)(phi)
        if (!lambda || phi0 === _math.halfPi) return [0, phi]
        var B = phi0 / _math.halfPi,
          B2 = B * B,
          C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
          C2 = C * C,
          BC = B * C,
          B_C2 = B2 + C2 + 2 * BC,
          B_3C = B + 3 * C,
          lambda0 = lambda / _math.halfPi,
          lambda1 = lambda0 + 1 / lambda0,
          D = (0, _math.sign)((0, _math.abs)(lambda) - _math.halfPi) * (0, _math.sqrt)(lambda1 * lambda1 - 4),
          D2 = D * D,
          F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2),
          x1 = (D * (B_C2 + C2 - 1) + 2 * (0, _math.sqrt)(F)) / (4 * B_C2 + D2)
        return [(0, _math.sign)(lambda) * _math.halfPi * x1, (0, _math.sign)(phi) * _math.halfPi * (0, _math.sqrt)(1 + D * (0, _math.abs)(x1) - x1 * x1)]
      }

      vanDerGrinten4Raw.invert = function (x, y) {
        var delta
        if (!x || !y) return [x, y]
        y /= _math.pi
        var x1 = (0, _math.sign)(x) * x / _math.halfPi,
          D = (x1 * x1 - 1 + 4 * y * y) / (0, _math.abs)(x1),
          D2 = D * D,
          B = 2 * y,
          i = 50
        do {
          var B2 = B * B,
            C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
            C_ = (3 * B - B2 * B - 10) / (2 * B2 * B),
            C2 = C * C,
            BC = B * C,
            B_C = B + C,
            B_C2 = B_C * B_C,
            B_3C = B + 3 * C,
            F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)),
            F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)),
            sqrtF = (0, _math.sqrt)(F),
            f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2),
            f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2)
          B -= delta = f / f_
        } while (delta > _math.epsilon && --i > 0)
        return [(0, _math.sign)(x) * ((0, _math.sqrt)(D * D + 4) + D) * _math.pi / 4, _math.halfPi * B]
      }
      /***/
    },
    /* 408 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.wagner4Raw = undefined

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(wagner4Raw).scale(176.84)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      var _mollweide = __webpack_require__(22)

      var A = 4 * _math.pi + 3 * (0, _math.sqrt)(3),
        B = 2 * (0, _math.sqrt)(2 * _math.pi * (0, _math.sqrt)(3) / A)

      var wagner4Raw = exports.wagner4Raw = (0, _mollweide.mollweideBromleyRaw)(B * (0, _math.sqrt)(3) / _math.pi, B, A / 6)
      /***/
    },
    /* 409 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.wagner6Raw = wagner6Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(wagner6Raw).scale(152.63)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function wagner6Raw(lambda, phi) {
        return [lambda * (0, _math.sqrt)(1 - 3 * phi * phi / (_math.pi * _math.pi)), phi]
      }

      wagner6Raw.invert = function (x, y) {
        return [x / (0, _math.sqrt)(1 - 3 * y * y / (_math.pi * _math.pi)), y]
      }
      /***/
    },
    /* 410 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.wagner7Raw = wagner7Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(wagner7Raw).scale(172.632)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function wagner7Raw(lambda, phi) {
        var s = 0.90631 * (0, _math.sin)(phi),
          c0 = (0, _math.sqrt)(1 - s * s),
          c1 = (0, _math.sqrt)(2 / (1 + c0 * (0, _math.cos)(lambda /= 3)))
        return [2.66723 * c0 * c1 * (0, _math.sin)(lambda), 1.24104 * s * c1]
      }

      wagner7Raw.invert = function (x, y) {
        var t1 = x / 2.66723,
          t2 = y / 1.24104,
          p = (0, _math.sqrt)(t1 * t1 + t2 * t2),
          c = 2 * (0, _math.asin)(p / 2)
        return [3 * (0, _math.atan2)(x * (0, _math.tan)(c), 2.66723 * p), p && (0, _math.asin)(y * (0, _math.sin)(c) / (1.24104 * 0.90631 * p))]
      }
      /***/
    },
    /* 411 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.wiechelRaw = wiechelRaw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3)
      }

      var _d3Geo = __webpack_require__(0)

      var _math = __webpack_require__(1)

      function wiechelRaw(lambda, phi) {
        var cosPhi = (0, _math.cos)(phi),
          sinPhi = (0, _math.cos)(lambda) * cosPhi,
          sin1_Phi = 1 - sinPhi,
          cosLambda = (0, _math.cos)(lambda = (0, _math.atan2)((0, _math.sin)(lambda) * cosPhi, -(0, _math.sin)(phi))),
          sinLambda = (0, _math.sin)(lambda)
        cosPhi = (0, _math.sqrt)(1 - sinPhi * sinPhi)
        return [sinLambda * cosPhi - cosLambda * sin1_Phi, -cosLambda * cosPhi - sinLambda * sin1_Phi]
      }

      wiechelRaw.invert = function (x, y) {
        var w = (x * x + y * y) / -2,
          k = (0, _math.sqrt)(-w * (2 + w)),
          b = y * w + x * k,
          a = x * w - y * k,
          D = (0, _math.sqrt)(a * a + b * b)
        return [(0, _math.atan2)(k * b, D * (1 + w)), D ? -(0, _math.asin)(k * a / D) : 0]
      }
      /***/
    },
    /* 412 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.winkel3Raw = winkel3Raw

      exports.default = function () {
        return (0, _d3Geo.geoProjection)(winkel3Raw).scale(158.837)
      }

      var _d3Geo = __webpack_require__(0)

      var _aitoff = __webpack_require__(171)

      var _math = __webpack_require__(1)

      function winkel3Raw(lambda, phi) {
        var coordinates = (0, _aitoff.aitoffRaw)(lambda, phi)
        return [(coordinates[0] + lambda / _math.halfPi) / 2, (coordinates[1] + phi) / 2]
      }

      winkel3Raw.invert = function (x, y) {
        var lambda = x,
          phi = y,
          i = 25
        do {
          var cosphi = (0, _math.cos)(phi),
            sinphi = (0, _math.sin)(phi),
            sin_2phi = (0, _math.sin)(2 * phi),
            sin2phi = sinphi * sinphi,
            cos2phi = cosphi * cosphi,
            sinlambda = (0, _math.sin)(lambda),
            coslambda_2 = (0, _math.cos)(lambda / 2),
            sinlambda_2 = (0, _math.sin)(lambda / 2),
            sin2lambda_2 = sinlambda_2 * sinlambda_2,
            C = 1 - cos2phi * coslambda_2 * coslambda_2,
            E = C ? (0, _math.acos)(cosphi * coslambda_2) * (0, _math.sqrt)(F = 1 / C) : F = 0,
            F,
            fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / _math.halfPi) - x,
            fy = 0.5 * (E * sinphi + phi) - y,
            dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / _math.halfPi,
            dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2),
            dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda),
            dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5,
            denominator = dxdphi * dydlambda - dydphi * dxdlambda,
            dlambda = (fy * dxdphi - fx * dydphi) / denominator,
            dphi = (fx * dydlambda - fy * dxdlambda) / denominator
          lambda -= dlambda, phi -= dphi
        } while (((0, _math.abs)(dlambda) > _math.epsilon || (0, _math.abs)(dphi) > _math.epsilon) && --i > 0)
        return [lambda, phi]
      }
      /***/
    },
    /* 413 */
    /***/
    function (module, exports) {
      /**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */
      function listCacheClear() {
        this.__data__ = []
        this.size = 0
      }

      module.exports = listCacheClear
      /***/
    },
    /* 414 */
    /***/
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(62)

      /** Used for built-in method references. */
      var arrayProto = Array.prototype

      /** Built-in value references. */
      var splice = arrayProto.splice

      /**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function listCacheDelete(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key)

        if (index < 0) {
          return false
        }
        var lastIndex = data.length - 1
        if (index == lastIndex) {
          data.pop()
        } else {
          splice.call(data, index, 1)
        }
        --this.size
        return true
      }

      module.exports = listCacheDelete
      /***/
    },
    /* 415 */
    /***/
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(62)

      /**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function listCacheGet(key) {
        var data = this.__data__,
          index = assocIndexOf(data, key)

        return index < 0 ? undefined : data[index][1]
      }

      module.exports = listCacheGet
      /***/
    },
    /* 416 */
    /***/
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(62)

      /**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1
      }

      module.exports = listCacheHas
      /***/
    },
    /* 417 */
    /***/
    function (module, exports, __webpack_require__) {
      var assocIndexOf = __webpack_require__(62)

      /**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */
      function listCacheSet(key, value) {
        var data = this.__data__,
          index = assocIndexOf(data, key)

        if (index < 0) {
          ++this.size
          data.push([key, value])
        } else {
          data[index][1] = value
        }
        return this
      }

      module.exports = listCacheSet
      /***/
    },
    /* 418 */
    /***/
    function (module, exports, __webpack_require__) {
      var ListCache = __webpack_require__(61)

      /**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */
      function stackClear() {
        this.__data__ = new ListCache()
        this.size = 0
      }

      module.exports = stackClear
      /***/
    },
    /* 419 */
    /***/
    function (module, exports) {
      /**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function stackDelete(key) {
        var data = this.__data__,
          result = data['delete'](key)

        this.size = data.size
        return result
      }

      module.exports = stackDelete
      /***/
    },
    /* 420 */
    /***/
    function (module, exports) {
      /**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function stackGet(key) {
        return this.__data__.get(key)
      }

      module.exports = stackGet
      /***/
    },
    /* 421 */
    /***/
    function (module, exports) {
      /**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function stackHas(key) {
        return this.__data__.has(key)
      }

      module.exports = stackHas
      /***/
    },
    /* 422 */
    /***/
    function (module, exports, __webpack_require__) {
      var ListCache = __webpack_require__(61),
        Map = __webpack_require__(95),
        MapCache = __webpack_require__(96)

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200

      /**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */
      function stackSet(key, value) {
        var data = this.__data__
        if (data instanceof ListCache) {
          var pairs = data.__data__
          if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value])
            this.size = ++data.size
            return this
          }
          data = this.__data__ = new MapCache(pairs)
        }
        data.set(key, value)
        this.size = data.size
        return this
      }

      module.exports = stackSet
      /***/
    },
    /* 423 */
    /***/
    function (module, exports, __webpack_require__) {
      var Hash = __webpack_require__(424),
        ListCache = __webpack_require__(61),
        Map = __webpack_require__(95)

      /**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */
      function mapCacheClear() {
        this.size = 0
        this.__data__ = {
          'hash': new Hash(),
          'map': new(Map || ListCache)(),
          'string': new Hash()
        }
      }

      module.exports = mapCacheClear
      /***/
    },
    /* 424 */
    /***/
    function (module, exports, __webpack_require__) {
      var hashClear = __webpack_require__(425),
        hashDelete = __webpack_require__(426),
        hashGet = __webpack_require__(427),
        hashHas = __webpack_require__(428),
        hashSet = __webpack_require__(429)

      /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Hash(entries) {
        var index = -1,
          length = entries == null ? 0 : entries.length

        this.clear()
        while (++index < length) {
          var entry = entries[index]
          this.set(entry[0], entry[1])
        }
      }

      // Add methods to `Hash`.
      Hash.prototype.clear = hashClear
      Hash.prototype['delete'] = hashDelete
      Hash.prototype.get = hashGet
      Hash.prototype.has = hashHas
      Hash.prototype.set = hashSet

      module.exports = Hash
      /***/
    },
    /* 425 */
    /***/
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(63)

      /**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {}
        this.size = 0
      }

      module.exports = hashClear
      /***/
    },
    /* 426 */
    /***/
    function (module, exports) {
      /**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key]
        this.size -= result ? 1 : 0
        return result
      }

      module.exports = hashDelete
      /***/
    },
    /* 427 */
    /***/
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(63)

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__'

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function hashGet(key) {
        var data = this.__data__
        if (nativeCreate) {
          var result = data[key]
          return result === HASH_UNDEFINED ? undefined : result
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined
      }

      module.exports = hashGet
      /***/
    },
    /* 428 */
    /***/
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(63)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function hashHas(key) {
        var data = this.__data__
        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
      }

      module.exports = hashHas
      /***/
    },
    /* 429 */
    /***/
    function (module, exports, __webpack_require__) {
      var nativeCreate = __webpack_require__(63)

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__'

      /**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */
      function hashSet(key, value) {
        var data = this.__data__
        this.size += this.has(key) ? 0 : 1
        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value
        return this
      }

      module.exports = hashSet
      /***/
    },
    /* 430 */
    /***/
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(64)

      /**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key)
        this.size -= result ? 1 : 0
        return result
      }

      module.exports = mapCacheDelete
      /***/
    },
    /* 431 */
    /***/
    function (module, exports) {
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      /**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */
      function isKeyable(value) {
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value)
        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null
      }

      module.exports = isKeyable
      /***/
    },
    /* 432 */
    /***/
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(64)

      /**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function mapCacheGet(key) {
        return getMapData(this, key).get(key)
      }

      module.exports = mapCacheGet
      /***/
    },
    /* 433 */
    /***/
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(64)

      /**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function mapCacheHas(key) {
        return getMapData(this, key).has(key)
      }

      module.exports = mapCacheHas
      /***/
    },
    /* 434 */
    /***/
    function (module, exports, __webpack_require__) {
      var getMapData = __webpack_require__(64)

      /**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */
      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
          size = data.size

        data.set(key, value)
        this.size += data.size == size ? 0 : 1
        return this
      }

      module.exports = mapCacheSet
      /***/
    },
    /* 435 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
          length = array == null ? 0 : array.length

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break
          }
        }
        return array
      }

      module.exports = arrayEach
      /***/
    },
    /* 436 */
    /***/
    function (module, exports, __webpack_require__) {
      var copyObject = __webpack_require__(36),
        keys = __webpack_require__(9)

      /**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object)
      }

      module.exports = baseAssign
      /***/
    },
    /* 437 */
    /***/
    function (module, exports, __webpack_require__) {
      var copyObject = __webpack_require__(36),
        keysIn = __webpack_require__(97)

      /**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object)
      }

      module.exports = baseAssignIn
      /***/
    },
    /* 438 */
    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(12),
        isPrototype = __webpack_require__(56),
        nativeKeysIn = __webpack_require__(439)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object)
        }
        var isProto = isPrototype(object),
          result = []

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key)
          }
        }
        return result
      }

      module.exports = baseKeysIn
      /***/
    },
    /* 439 */
    /***/
    function (module, exports) {
      /**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function nativeKeysIn(object) {
        var result = []
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key)
          }
        }
        return result
      }

      module.exports = nativeKeysIn
      /***/
    },
    /* 440 */
    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (module) {
        var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
          return typeof obj
        } : function (obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
        }

        var root = __webpack_require__(13)

        /** Detect free variable `exports`. */
        var freeExports = (false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports

        /** Detect free variable `module`. */
        var freeModule = freeExports && (false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports

        /** Built-in value references. */
        var Buffer = moduleExports ? root.Buffer : undefined,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice()
          }
          var length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)

          buffer.copy(result)
          return result
        }

        module.exports = cloneBuffer
        /* WEBPACK VAR INJECTION */
      }.call(exports, __webpack_require__(81)(module)))
      /***/
    },
    /* 441 */
    /***/
    function (module, exports) {
      /**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */
      function copyArray(source, array) {
        var index = -1,
          length = source.length

        array || (array = Array(length))
        while (++index < length) {
          array[index] = source[index]
        }
        return array
      }

      module.exports = copyArray
      /***/
    },
    /* 442 */
    /***/
    function (module, exports, __webpack_require__) {
      var copyObject = __webpack_require__(36),
        getSymbols = __webpack_require__(98)

      /**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object)
      }

      module.exports = copySymbols
      /***/
    },
    /* 443 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = []

        while (++index < length) {
          var value = array[index]
          if (predicate(value, index, array)) {
            result[resIndex++] = value
          }
        }
        return result
      }

      module.exports = arrayFilter
      /***/
    },
    /* 444 */
    /***/
    function (module, exports, __webpack_require__) {
      var copyObject = __webpack_require__(36),
        getSymbolsIn = __webpack_require__(184)

      /**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object)
      }

      module.exports = copySymbolsIn
      /***/
    },
    /* 445 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetAllKeys = __webpack_require__(186),
        getSymbolsIn = __webpack_require__(184),
        keysIn = __webpack_require__(97)

      /**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn)
      }

      module.exports = getAllKeysIn
      /***/
    },
    /* 446 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24),
        root = __webpack_require__(13)

      /* Built-in method references that are verified to be native. */
      var DataView = getNative(root, 'DataView')

      module.exports = DataView
      /***/
    },
    /* 447 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24),
        root = __webpack_require__(13)

      /* Built-in method references that are verified to be native. */
      var Promise = getNative(root, 'Promise')

      module.exports = Promise
      /***/
    },
    /* 448 */
    /***/
    function (module, exports, __webpack_require__) {
      var getNative = __webpack_require__(24),
        root = __webpack_require__(13)

      /* Built-in method references that are verified to be native. */
      var WeakMap = getNative(root, 'WeakMap')

      module.exports = WeakMap
      /***/
    },
    /* 449 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */
      function initCloneArray(array) {
        var length = array.length,
          result = array.constructor(length)

        // Add properties assigned by `RegExp#exec`.
        if (length && typeof array[0] === 'string' && hasOwnProperty.call(array, 'index')) {
          result.index = array.index
          result.input = array.input
        }
        return result
      }

      module.exports = initCloneArray
      /***/
    },
    /* 450 */
    /***/
    function (module, exports, __webpack_require__) {
      var cloneArrayBuffer = __webpack_require__(101),
        cloneDataView = __webpack_require__(451),
        cloneMap = __webpack_require__(452),
        cloneRegExp = __webpack_require__(454),
        cloneSet = __webpack_require__(455),
        cloneSymbol = __webpack_require__(457),
        cloneTypedArray = __webpack_require__(458)

      /** `Object#toString` result references. */
      var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]'

      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]'

      /**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {Function} cloneFunc The function to clone values.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneByTag(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object)

          case boolTag:
          case dateTag:
            return new Ctor(+object)

          case dataViewTag:
            return cloneDataView(object, isDeep)

          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep)

          case mapTag:
            return cloneMap(object, isDeep, cloneFunc)

          case numberTag:
          case stringTag:
            return new Ctor(object)

          case regexpTag:
            return cloneRegExp(object)

          case setTag:
            return cloneSet(object, isDeep, cloneFunc)

          case symbolTag:
            return cloneSymbol(object)
        }
      }

      module.exports = initCloneByTag
      /***/
    },
    /* 451 */
    /***/
    function (module, exports, __webpack_require__) {
      var cloneArrayBuffer = __webpack_require__(101)

      /**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
      }

      module.exports = cloneDataView
      /***/
    },
    /* 452 */
    /***/
    function (module, exports, __webpack_require__) {
      var addMapEntry = __webpack_require__(453),
        arrayReduce = __webpack_require__(190),
        mapToArray = __webpack_require__(191)

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1

      /**
       * Creates a clone of `map`.
       *
       * @private
       * @param {Object} map The map to clone.
       * @param {Function} cloneFunc The function to clone values.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned map.
       */
      function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map)
        return arrayReduce(array, addMapEntry, new map.constructor())
      }

      module.exports = cloneMap
      /***/
    },
    /* 453 */
    /***/
    function (module, exports) {
      /**
       * Adds the key-value `pair` to `map`.
       *
       * @private
       * @param {Object} map The map to modify.
       * @param {Array} pair The key-value pair to add.
       * @returns {Object} Returns `map`.
       */
      function addMapEntry(map, pair) {
        // Don't return `map.set` because it's not chainable in IE 11.
        map.set(pair[0], pair[1])
        return map
      }

      module.exports = addMapEntry
      /***/
    },
    /* 454 */
    /***/
    function (module, exports) {
      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/

      /**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))
        result.lastIndex = regexp.lastIndex
        return result
      }

      module.exports = cloneRegExp
      /***/
    },
    /* 455 */
    /***/
    function (module, exports, __webpack_require__) {
      var addSetEntry = __webpack_require__(456),
        arrayReduce = __webpack_require__(190),
        setToArray = __webpack_require__(65)

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1

      /**
       * Creates a clone of `set`.
       *
       * @private
       * @param {Object} set The set to clone.
       * @param {Function} cloneFunc The function to clone values.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned set.
       */
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set)
        return arrayReduce(array, addSetEntry, new set.constructor())
      }

      module.exports = cloneSet
      /***/
    },
    /* 456 */
    /***/
    function (module, exports) {
      /**
       * Adds `value` to `set`.
       *
       * @private
       * @param {Object} set The set to modify.
       * @param {*} value The value to add.
       * @returns {Object} Returns `set`.
       */
      function addSetEntry(set, value) {
        // Don't return `set.add` because it's not chainable in IE 11.
        set.add(value)
        return set
      }

      module.exports = addSetEntry
      /***/
    },
    /* 457 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32)

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

      /**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
      }

      module.exports = cloneSymbol
      /***/
    },
    /* 458 */
    /***/
    function (module, exports, __webpack_require__) {
      var cloneArrayBuffer = __webpack_require__(101)

      /**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
      }

      module.exports = cloneTypedArray
      /***/
    },
    /* 459 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseCreate = __webpack_require__(460),
        getPrototype = __webpack_require__(100),
        isPrototype = __webpack_require__(56)

      /**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneObject(object) {
        return typeof object.constructor === 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {}
      }

      module.exports = initCloneObject
      /***/
    },
    /* 460 */
    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(12)

      /** Built-in value references. */
      var objectCreate = Object.create

      /**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */
      var baseCreate = (function () {
        function object() {}
        return function (proto) {
          if (!isObject(proto)) {
            return {}
          }
          if (objectCreate) {
            return objectCreate(proto)
          }
          object.prototype = proto
          var result = new object()
          object.prototype = undefined
          return result
        }
      }())

      module.exports = baseCreate
      /***/
    },
    /* 461 */
    /***/
    function (module, exports, __webpack_require__) {
      var createFind = __webpack_require__(462),
        findIndex = __webpack_require__(480)

      /**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */
      var find = createFind(findIndex)

      module.exports = find
      /***/
    },
    /* 462 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIteratee = __webpack_require__(66),
        isArrayLike = __webpack_require__(20),
        keys = __webpack_require__(9)

      /**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */
      function createFind(findIndexFunc) {
        return function (collection, predicate, fromIndex) {
          var iterable = Object(collection)
          if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate, 3)
            collection = keys(collection)
            predicate = function predicate(key) {
              return iteratee(iterable[key], key, iterable)
            }
          }
          var index = findIndexFunc(collection, predicate, fromIndex)
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
        }
      }

      module.exports = createFind
      /***/
    },
    /* 463 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsMatch = __webpack_require__(192),
        getMatchData = __webpack_require__(195),
        matchesStrictComparable = __webpack_require__(197)

      /**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */
      function baseMatches(source) {
        var matchData = getMatchData(source)
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1])
        }
        return function (object) {
          return object === source || baseIsMatch(object, source, matchData)
        }
      }

      module.exports = baseMatches
      /***/
    },
    /* 464 */
    /***/
    function (module, exports, __webpack_require__) {
      var Stack = __webpack_require__(94),
        equalArrays = __webpack_require__(194),
        equalByTag = __webpack_require__(468),
        equalObjects = __webpack_require__(469),
        getTag = __webpack_require__(187),
        isArray = __webpack_require__(10),
        isBuffer = __webpack_require__(80),
        isTypedArray = __webpack_require__(143)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]'

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other)

        objTag = objTag == argsTag ? objectTag : objTag
        othTag = othTag == argsTag ? objectTag : othTag

        var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag

        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false
          }
          objIsArr = true
          objIsObj = false
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack())
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__')

          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other

            stack || (stack = new Stack())
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
          }
        }
        if (!isSameTag) {
          return false
        }
        stack || (stack = new Stack())
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack)
      }

      module.exports = baseIsEqualDeep
      /***/
    },
    /* 465 */
    /***/
    function (module, exports) {
      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__'

      /**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED)
        return this
      }

      module.exports = setCacheAdd
      /***/
    },
    /* 466 */
    /***/
    function (module, exports) {
      /**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */
      function setCacheHas(value) {
        return this.__data__.has(value)
      }

      module.exports = setCacheHas
      /***/
    },
    /* 467 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
          length = array == null ? 0 : array.length

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true
          }
        }
        return false
      }

      module.exports = arraySome
      /***/
    },
    /* 468 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32),
        Uint8Array = __webpack_require__(189),
        eq = __webpack_require__(54),
        equalArrays = __webpack_require__(194),
        mapToArray = __webpack_require__(191),
        setToArray = __webpack_require__(65)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2

      /** `Object#toString` result references. */
      var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]'

      var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]'

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined

      /**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false
            }
            object = object.buffer
            other = other.buffer

          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false
            }
            return true

          case boolTag:
          case dateTag:
          case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other)

          case errorTag:
            return object.name == other.name && object.message == other.message

          case regexpTag:
          case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + ''

          case mapTag:
            var convert = mapToArray

          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG
            convert || (convert = setToArray)

            if (object.size != other.size && !isPartial) {
              return false
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object)
            if (stacked) {
              return stacked == other
            }
            bitmask |= COMPARE_UNORDERED_FLAG

            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other)
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack)
            stack['delete'](object)
            return result

          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other)
            }
        }
        return false
      }

      module.exports = equalByTag
      /***/
    },
    /* 469 */
    /***/
    function (module, exports, __webpack_require__) {
      var getAllKeys = __webpack_require__(185)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length

        if (objLength != othLength && !isPartial) {
          return false
        }
        var index = objLength
        while (index--) {
          var key = objProps[index]
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false
          }
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object)
        if (stacked && stack.get(other)) {
          return stacked == other
        }
        var result = true
        stack.set(object, other)
        stack.set(other, object)

        var skipCtor = isPartial
        while (++index < objLength) {
          key = objProps[index]
          var objValue = object[key],
            othValue = other[key]

          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack)
          }
          // Recursively compare objects (susceptible to call stack limits).
          if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false
            break
          }
          skipCtor || (skipCtor = key == 'constructor')
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor,
            othCtor = other.constructor

          // Non `Object` object instances with different constructors are not equal.
          if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor === 'function' && objCtor instanceof objCtor && typeof othCtor === 'function' && othCtor instanceof othCtor)) {
            result = false
          }
        }
        stack['delete'](object)
        stack['delete'](other)
        return result
      }

      module.exports = equalObjects
      /***/
    },
    /* 470 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsEqual = __webpack_require__(193),
        get = __webpack_require__(471),
        hasIn = __webpack_require__(199),
        isKey = __webpack_require__(105),
        isStrictComparable = __webpack_require__(196),
        matchesStrictComparable = __webpack_require__(197),
        toKey = __webpack_require__(44)

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2

      /**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue)
        }
        return function (object) {
          var objValue = get(object, path)
          return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
        }
      }

      module.exports = baseMatchesProperty
      /***/
    },
    /* 471 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGet = __webpack_require__(104)

      /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */
      function get(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path)
        return result === undefined ? defaultValue : result
      }

      module.exports = get
      /***/
    },
    /* 472 */
    /***/
    function (module, exports, __webpack_require__) {
      var memoizeCapped = __webpack_require__(473)

      /** Used to match property names within property paths. */
      var reLeadingDot = /^\./,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g

      /**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */
      var stringToPath = memoizeCapped(function (string) {
        var result = []
        if (reLeadingDot.test(string)) {
          result.push('')
        }
        string.replace(rePropName, function (match, number, quote, string) {
          result.push(quote ? string.replace(reEscapeChar, '$1') : number || match)
        })
        return result
      })

      module.exports = stringToPath
      /***/
    },
    /* 473 */
    /***/
    function (module, exports, __webpack_require__) {
      var memoize = __webpack_require__(474)

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500

      /**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */
      function memoizeCapped(func) {
        var result = memoize(func, function (key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear()
          }
          return key
        })

        var cache = result.cache
        return result
      }

      module.exports = memoizeCapped
      /***/
    },
    /* 474 */
    /***/
    function (module, exports, __webpack_require__) {
      var MapCache = __webpack_require__(96)

      /** Error message constants. */
      var FUNC_ERROR_TEXT = 'Expected a function'

      /**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */
      function memoize(func, resolver) {
        if (typeof func !== 'function' || resolver != null && typeof resolver !== 'function') {
          throw new TypeError(FUNC_ERROR_TEXT)
        }
        var memoized = function memoized() {
          var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache

          if (cache.has(key)) {
            return cache.get(key)
          }
          var result = func.apply(this, args)
          memoized.cache = cache.set(key, result) || cache
          return result
        }
        memoized.cache = new(memoize.Cache || MapCache)()
        return memoized
      }

      // Expose `MapCache`.
      memoize.Cache = MapCache

      module.exports = memoize
      /***/
    },
    /* 475 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32),
        arrayMap = __webpack_require__(68),
        isArray = __webpack_require__(10),
        isSymbol = __webpack_require__(43)

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined

      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value === 'string') {
          return value
        }
        if (isArray(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return arrayMap(value, baseToString) + ''
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : ''
        }
        var result = value + ''
        return result == '0' && 1 / value == -INFINITY ? '-0' : result
      }

      module.exports = baseToString
      /***/
    },
    /* 476 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */
      function baseHasIn(object, key) {
        return object != null && key in Object(object)
      }

      module.exports = baseHasIn
      /***/
    },
    /* 477 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseProperty = __webpack_require__(478),
        basePropertyDeep = __webpack_require__(479),
        isKey = __webpack_require__(105),
        toKey = __webpack_require__(44)

      /**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
      }

      module.exports = property
      /***/
    },
    /* 478 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function (object) {
          return object == null ? undefined : object[key]
        }
      }

      module.exports = baseProperty
      /***/
    },
    /* 479 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGet = __webpack_require__(104)

      /**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyDeep(path) {
        return function (object) {
          return baseGet(object, path)
        }
      }

      module.exports = basePropertyDeep
      /***/
    },
    /* 480 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFindIndex = __webpack_require__(201),
        baseIteratee = __webpack_require__(66),
        toInteger = __webpack_require__(481)

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeMax = Math.max

      /**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length
        if (!length) {
          return -1
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex)
        if (index < 0) {
          index = nativeMax(length + index, 0)
        }
        return baseFindIndex(array, baseIteratee(predicate, 3), index)
      }

      module.exports = findIndex
      /***/
    },
    /* 481 */
    /***/
    function (module, exports, __webpack_require__) {
      var toFinite = __webpack_require__(482)

      /**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */
      function toInteger(value) {
        var result = toFinite(value),
          remainder = result % 1

        return result === result ? remainder ? result - remainder : result : 0
      }

      module.exports = toInteger
      /***/
    },
    /* 482 */
    /***/
    function (module, exports, __webpack_require__) {
      var toNumber = __webpack_require__(483)

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308

      /**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0
        }
        value = toNumber(value)
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1
          return sign * MAX_INTEGER
        }
        return value === value ? value : 0
      }

      module.exports = toFinite
      /***/
    },
    /* 483 */
    /***/
    function (module, exports, __webpack_require__) {
      var isObject = __webpack_require__(12),
        isSymbol = __webpack_require__(43)

      /** Used as references for various `Number` constants. */
      var NAN = 0 / 0

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i

      /** Built-in method references without a dependency on `root`. */
      var freeParseInt = parseInt

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value === 'number') {
          return value
        }
        if (isSymbol(value)) {
          return NAN
        }
        if (isObject(value)) {
          var other = typeof value.valueOf === 'function' ? value.valueOf() : value
          value = isObject(other) ? other + '' : other
        }
        if (typeof value !== 'string') {
          return value === 0 ? value : +value
        }
        value = value.replace(reTrim, '')
        var isBinary = reIsBinary.test(value)
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
      }

      module.exports = toNumber
      /***/
    },
    /* 484 */
    /***/
    function (module, exports) {
      /**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */
      function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
          var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length

          while (length--) {
            var key = props[fromRight ? length : ++index]
            if (iteratee(iterable[key], key, iterable) === false) {
              break
            }
          }
          return object
        }
      }

      module.exports = createBaseFor
      /***/
    },
    /* 485 */
    /***/
    function (module, exports, __webpack_require__) {
      var identity = __webpack_require__(37)

      /**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */
      function castFunction(value) {
        return typeof value === 'function' ? value : identity
      }

      module.exports = castFunction
      /***/
    },
    /* 486 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseIsMatch = __webpack_require__(192),
        getMatchData = __webpack_require__(195)

      /**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source))
      }

      module.exports = isMatch
      /***/
    },
    /* 487 */
    /***/
    function (module, exports, __webpack_require__) {
      var basePickBy = __webpack_require__(488),
        hasIn = __webpack_require__(199)

      /**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */
      function basePick(object, paths) {
        return basePickBy(object, paths, function (value, path) {
          return hasIn(object, path)
        })
      }

      module.exports = basePick
      /***/
    },
    /* 488 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGet = __webpack_require__(104),
        baseSet = __webpack_require__(489),
        castPath = __webpack_require__(67)

      /**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */
      function basePickBy(object, paths, predicate) {
        var index = -1,
          length = paths.length,
          result = {}

        while (++index < length) {
          var path = paths[index],
            value = baseGet(object, path)

          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value)
          }
        }
        return result
      }

      module.exports = basePickBy
      /***/
    },
    /* 489 */
    /***/
    function (module, exports, __webpack_require__) {
      var assignValue = __webpack_require__(53),
        castPath = __webpack_require__(67),
        isIndex = __webpack_require__(55),
        isObject = __webpack_require__(12),
        toKey = __webpack_require__(44)

      /**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object
        }
        path = castPath(path, object)

        var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object

        while (nested != null && ++index < length) {
          var key = toKey(path[index]),
            newValue = value

          if (index != lastIndex) {
            var objValue = nested[key]
            newValue = customizer ? customizer(objValue, key, nested) : undefined
            if (newValue === undefined) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {}
            }
          }
          assignValue(nested, key, newValue)
          nested = nested[key]
        }
        return object
      }

      module.exports = baseSet
      /***/
    },
    /* 490 */
    /***/
    function (module, exports, __webpack_require__) {
      var flatten = __webpack_require__(491),
        overRest = __webpack_require__(139),
        setToString = __webpack_require__(140)

      /**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */
      function flatRest(func) {
        return setToString(overRest(func, undefined, flatten), func + '')
      }

      module.exports = flatRest
      /***/
    },
    /* 491 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFlatten = __webpack_require__(106)

      /**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */
      function flatten(array) {
        var length = array == null ? 0 : array.length
        return length ? baseFlatten(array, 1) : []
      }

      module.exports = flatten
      /***/
    },
    /* 492 */
    /***/
    function (module, exports, __webpack_require__) {
      var _Symbol = __webpack_require__(32),
        isArguments = __webpack_require__(79),
        isArray = __webpack_require__(10)

      /** Built-in value references. */
      var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined

      /**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
      }

      module.exports = isFlattenable
      /***/
    },
    /* 493 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseClone = __webpack_require__(182)

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
        CLONE_SYMBOLS_FLAG = 4

      /**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
      }

      module.exports = cloneDeep
      /***/
    },
    /* 494 */
    /***/
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      };

      // http://geoexamples.com/d3-composite-projections/ Version 1.2.0. Copyright 2017 Roger Veciana i Rovira.
      (function (global, factory) {
        (false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(204), __webpack_require__(29)) : true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(204), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
          __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
            (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.d3 = global.d3 || {}, global.d3, global.d3)
      })(undefined, function (exports, d3Geo, d3Path) {
        'use strict'

        var epsilon = 1e-6

        function noop() {}

        var x0 = Infinity
        var y0 = x0
        var x1 = -x0
        var y1 = x1
        var boundsStream = {
          point: boundsPoint,
          lineStart: noop,
          lineEnd: noop,
          polygonStart: noop,
          polygonEnd: noop,
          result: function result() {
            var bounds = [
              [x0, y0],
              [x1, y1]
            ]
            x1 = y1 = -(y0 = x0 = Infinity)
            return bounds
          }
        }

        function boundsPoint(x, y) {
          if (x < x0) x0 = x
          if (x > x1) x1 = x
          if (y < y0) y0 = y
          if (y > y1) y1 = y
        }

        function fitExtent(projection, extent, object) {
          var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            clip = projection.clipExtent && projection.clipExtent()

          projection.scale(150).translate([0, 0])

          if (clip != null) projection.clipExtent(null)

          d3Geo.geoStream(object, projection.stream(boundsStream))

          var b = boundsStream.result(),
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2

          if (clip != null) projection.clipExtent(clip)

          return projection.scale(k * 150).translate([x, y])
        }

        function fitSize(projection, size, object) {
          return fitExtent(projection, [
            [0, 0], size
          ], object)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for the United States, configured by default for
        // 960500. The projection also works quite well at 960600 if you change the
        // scale to 1285 and adjust the translate accordingly. The set of standard
        // parallels for each region comes from USGS, which is published here:
        // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
        function albersUsa() {
          var cache,
            cacheStream,
            lower48 = d3Geo.geoAlbers(),
            lower48Point,
            alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            alaskaPoint,
            // EPSG:3338
            hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
            hawaiiPoint,
            // ESRI:102007
            _point,
            pointStream = {
              point: function point(x, y) {
                _point = [x, y]
              }
            }

          function albersUsa(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point)
          }

          albersUsa.invert = function (coordinates) {
            var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k
            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates)
          }

          albersUsa.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)])
          }

          albersUsa.precision = function (_) {
            if (!arguments.length) return lower48.precision()
            lower48.precision(_), alaska.precision(_), hawaii.precision(_)
            return reset()
          }

          albersUsa.scale = function (_) {
            if (!arguments.length) return lower48.scale()
            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_)
            return albersUsa.translate(lower48.translate())
          }

          albersUsa.translate = function (_) {
            if (!arguments.length) return lower48.translate()
            var k = lower48.scale(),
              x = +_[0],
              y = +_[1]

            lower48Point = lower48.translate(_).clipExtent([
              [x - 0.455 * k, y - 0.238 * k],
              [x + 0.455 * k, y + 0.238 * k]
            ]).stream(pointStream)

            alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([
              [x - 0.425 * k + epsilon, y + 0.120 * k + epsilon],
              [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]
            ]).stream(pointStream)

            hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([
              [x - 0.214 * k + epsilon, y + 0.166 * k + epsilon],
              [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          albersUsa.fitExtent = function (extent, object) {
            return fitExtent(albersUsa, extent, object)
          }

          albersUsa.fitSize = function (size, object) {
            return fitSize(albersUsa, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return albersUsa
          }

          albersUsa.drawCompositionBorders = function (context) {
            var hawaii1 = lower48([-102.91, 26.3])
            var hawaii2 = lower48([-104.0, 27.5])
            var hawaii3 = lower48([-108.0, 29.1])
            var hawaii4 = lower48([-110.0, 29.1])

            var alaska1 = lower48([-110.0, 26.7])
            var alaska2 = lower48([-112.8, 27.6])
            var alaska3 = lower48([-114.3, 30.6])
            var alaska4 = lower48([-119.3, 30.1])

            context.moveTo(hawaii1[0], hawaii1[1])
            context.lineTo(hawaii2[0], hawaii2[1])
            context.lineTo(hawaii3[0], hawaii3[1])
            context.lineTo(hawaii4[0], hawaii4[1])

            context.moveTo(alaska1[0], alaska1[1])
            context.lineTo(alaska2[0], alaska2[1])
            context.lineTo(alaska3[0], alaska3[1])
            context.lineTo(alaska4[0], alaska4[1])
          }
          albersUsa.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return albersUsa.scale(1070)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$1(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for the United States, configured by default for
        // 960500. Also works quite well at 960600 with scale 1285. The set of
        // standard parallels for each region comes from USGS, which is published here:
        // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
        function albersUsaTerritories() {
          var cache,
            cacheStream,
            lower48 = d3Geo.geoAlbers(),
            lower48Point,
            alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            alaskaPoint,
            // EPSG:3338
            hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
            hawaiiPoint,
            // ESRI:102007
            puertoRico = d3Geo.geoConicEqualArea().rotate([66, 0]).center([0, 18]).parallels([8, 18]),
            puertoRicoPoint,
            // Taken from https://bl.ocks.org/mbostock/5629120
            samoa = d3Geo.geoEquirectangular().rotate([173, 14]),
            samoaPoint,
            // EPSG:4169
            guam = d3Geo.geoEquirectangular().rotate([-145, -16.8]),
            guamPoint,
            _point2,
            pointStream = {
              point: function point(x, y) {
                _point2 = [x, y]
              }
            }

          /*
      var puertoRicoBbox = [[-68.3, 19], [-63.9, 17]];
      var samoaBbox = [[-171, -14], [-168, -14.8]];
      var guamBbox = [[144, 20.8], [146.5, 12.7]];
      */

          function albersUsa(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]

            return _point2 = null, (lower48Point.point(x, y), _point2) || (alaskaPoint.point(x, y), _point2) || (hawaiiPoint.point(x, y), _point2) || (puertoRicoPoint.point(x, y), _point2) || (samoaPoint.point(x, y), _point2) || (guamPoint.point(x, y), _point2)
          }

          albersUsa.invert = function (coordinates) {
            var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k
            /*
        //How are the return values calculated:
        console.info("******");
        var c0 = puertoRico(puertoRicoBbox[0]);
        var x0 = (c0[0] - t[0]) / k;
        var y0 = (c0[1] - t[1]) / k;
         console.info("p0 puertoRico", x0 + ' - ' + y0);
         var c1 = puertoRico(puertoRicoBbox[1]);
        var x1 = (c1[0] - t[0]) / k;
        var y1 = (c1[1] - t[1]) / k;
         console.info("p1 puertoRico", x1 + ' - ' + y1);
         c0 = samoa(samoaBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 samoa", x0 + ' - ' + y0);
         c1 = samoa(samoaBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 samoa", x1 + ' - ' + y1);
         c0 = guam(guamBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 guam", x0 + ' - ' + y0);
         c1 = guam(guamBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 guam", x1 + ' - ' + y1);
        */

            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : y >= 0.2064 && y < 0.2413 && x >= 0.312 && x < 0.385 ? puertoRico : y >= 0.09 && y < 0.1197 && x >= -0.4243 && x < -0.3232 ? samoa : y >= -0.0518 && y < 0.0895 && x >= -0.4243 && x < -0.3824 ? guam : lower48).invert(coordinates)
          }

          albersUsa.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$1([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream), puertoRico.stream(stream), samoa.stream(stream), guam.stream(stream)])
          }

          albersUsa.precision = function (_) {
            if (!arguments.length) {
              return lower48.precision()
            }
            lower48.precision(_)
            alaska.precision(_)
            hawaii.precision(_)
            puertoRico.precision(_)
            samoa.precision(_)
            guam.precision(_)
            return reset()
          }

          albersUsa.scale = function (_) {
            if (!arguments.length) {
              return lower48.scale()
            }
            lower48.scale(_)
            alaska.scale(_ * 0.35)
            hawaii.scale(_)
            puertoRico.scale(_)
            samoa.scale(_ * 2)
            guam.scale(_)
            return albersUsa.translate(lower48.translate())
          }

          albersUsa.translate = function (_) {
            if (!arguments.length) {
              return lower48.translate()
            }
            var k = lower48.scale(),
              x = +_[0],
              y = +_[1]

            /*
        var c0 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
         var c1 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
         console.info('puertoRico: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
         (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
         ' * k + epsilon, y '+
         (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
         ' * k + epsilon],[x '+
         (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
         ' * k - epsilon, y '+
         (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
         ' * k - epsilon]])');
           c0 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[0]);
          x0 = (x - c0[0]) / k;
          y0 = (y - c0[1]) / k;
           c1 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[1]);
          x1 = (x - c1[0]) / k;
          y1 = (y - c1[1]) / k;
          console.info('samoa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
         console.info('.clipExtent([[x '+
          (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
          ' * k + epsilon, y '+
          (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
          ' * k + epsilon],[x '+
          (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
          ' * k - epsilon, y '+
          (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
          ' * k - epsilon]])');
           c0 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[0]);
          x0 = (x - c0[0]) / k;
          y0 = (y - c0[1]) / k;
           c1 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[1]);
          x1 = (x - c1[0]) / k;
          y1 = (y - c1[1]) / k;
          console.info('guam: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
         console.info('.clipExtent([[x '+
          (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
          ' * k + epsilon, y '+
          (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
          ' * k + epsilon],[x '+
          (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
          ' * k - epsilon, y '+
          (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
          ' * k - epsilon]])');
          */

            lower48Point = lower48.translate(_).clipExtent([
              [x - 0.455 * k, y - 0.238 * k],
              [x + 0.455 * k, y + 0.238 * k]
            ]).stream(pointStream)

            alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([
              [x - 0.425 * k + epsilon, y + 0.120 * k + epsilon],
              [x - 0.214 * k - epsilon, y + 0.233 * k - epsilon]
            ]).stream(pointStream)

            hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([
              [x - 0.214 * k + epsilon, y + 0.166 * k + epsilon],
              [x - 0.115 * k - epsilon, y + 0.233 * k - epsilon]
            ]).stream(pointStream)

            puertoRicoPoint = puertoRico.translate([x + 0.350 * k, y + 0.224 * k]).clipExtent([
              [x + 0.312 * k + epsilon, y + 0.2064 * k + epsilon],
              [x + 0.385 * k - epsilon, y + 0.233 * k - epsilon]
            ]).stream(pointStream)

            samoaPoint = samoa.translate([x - 0.492 * k, y + 0.09 * k]).clipExtent([
              [x - 0.4243 * k + epsilon, y + 0.0903 * k + epsilon],
              [x - 0.3233 * k - epsilon, y + 0.1197 * k - epsilon]
            ]).stream(pointStream)

            guamPoint = guam.translate([x - 0.408 * k, y + 0.018 * k]).clipExtent([
              [x - 0.4244 * k + epsilon, y - 0.0519 * k + epsilon],
              [x - 0.3824 * k - epsilon, y + 0.0895 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          albersUsa.fitExtent = function (extent, object) {
            return fitExtent(albersUsa, extent, object)
          }

          albersUsa.fitSize = function (size, object) {
            return fitSize(albersUsa, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return albersUsa
          }

          albersUsa.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT hawaii: ", hawaii.clipExtent());
        console.info("UL BBOX:", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[0][1]]));
        console.info("UR BBOX:", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[0][1]]));
        console.info("LD BBOX:", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[1][1]]));
        console.info("LL BBOX:", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[1][1]]));
         console.info("CLIP EXTENT alaska: ", alaska.clipExtent());
        console.info("UL BBOX:", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[0][1]]));
        console.info("UR BBOX:", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[0][1]]));
        console.info("LD BBOX:", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[1][1]]));
        console.info("LL BBOX:", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[1][1]]));
         console.info("CLIP EXTENT puertoRico: ", puertoRico.clipExtent());
        console.info("UL BBOX:", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[0][1]]));
        console.info("UR BBOX:", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[0][1]]));
        console.info("LD BBOX:", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[1][1]]));
        console.info("LL BBOX:", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[1][1]]));
         console.info("CLIP EXTENT samoa: ", samoa.clipExtent());
        console.info("UL BBOX:", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[0][1]]));
        console.info("UR BBOX:", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[0][1]]));
        console.info("LD BBOX:", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[1][1]]));
        console.info("LL BBOX:", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[1][1]]));
          console.info("CLIP EXTENT guam: ", guam.clipExtent());
        console.info("UL BBOX:", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[0][1]]));
        console.info("UR BBOX:", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[0][1]]));
        console.info("LD BBOX:", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[1][1]]));
        console.info("LL BBOX:", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[1][1]]));
        */

            var ulhawaii = lower48([-110.4641, 28.2805])
            var urhawaii = lower48([-104.0597, 28.9528])
            var ldhawaii = lower48([-103.7049, 25.1031])
            var llhawaii = lower48([-109.8337, 24.4531])

            var ulalaska = lower48([-124.4745, 28.1407])
            var uralaska = lower48([-110.931, 30.8844])
            var ldalaska = lower48([-109.8337, 24.4531])
            var llalaska = lower48([-122.4628, 21.8562])

            var ulpuertoRico = lower48([-76.8579, 25.1544])
            var urpuertoRico = lower48([-72.429, 24.2097])
            var ldpuertoRico = lower48([-72.8265, 22.7056])
            var llpuertoRico = lower48([-77.1852, 23.6392])

            var ulsamoa = lower48([-125.0093, 29.7791])
            var ursamoa = lower48([-118.5193, 31.3262])
            var ldsamoa = lower48([-118.064, 29.6912])
            var llsamoa = lower48([-124.4369, 28.169])

            var ulguam = lower48([-128.1314, 37.4582])
            var urguam = lower48([-125.2132, 38.214])
            var ldguam = lower48([-122.3616, 30.5115])
            var llguam = lower48([-125.0315, 29.8211])

            context.moveTo(ulhawaii[0], ulhawaii[1])
            context.lineTo(urhawaii[0], urhawaii[1])
            context.lineTo(ldhawaii[0], ldhawaii[1])
            context.lineTo(ldhawaii[0], ldhawaii[1])
            context.lineTo(llhawaii[0], llhawaii[1])
            context.closePath()

            context.moveTo(ulalaska[0], ulalaska[1])
            context.lineTo(uralaska[0], uralaska[1])
            context.lineTo(ldalaska[0], ldalaska[1])
            context.lineTo(ldalaska[0], ldalaska[1])
            context.lineTo(llalaska[0], llalaska[1])
            context.closePath()

            context.moveTo(ulpuertoRico[0], ulpuertoRico[1])
            context.lineTo(urpuertoRico[0], urpuertoRico[1])
            context.lineTo(ldpuertoRico[0], ldpuertoRico[1])
            context.lineTo(ldpuertoRico[0], ldpuertoRico[1])
            context.lineTo(llpuertoRico[0], llpuertoRico[1])
            context.closePath()

            context.moveTo(ulsamoa[0], ulsamoa[1])
            context.lineTo(ursamoa[0], ursamoa[1])
            context.lineTo(ldsamoa[0], ldsamoa[1])
            context.lineTo(ldsamoa[0], ldsamoa[1])
            context.lineTo(llsamoa[0], llsamoa[1])
            context.closePath()

            context.moveTo(ulguam[0], ulguam[1])
            context.lineTo(urguam[0], urguam[1])
            context.lineTo(ldguam[0], ldguam[1])
            context.lineTo(ldguam[0], ldguam[1])
            context.lineTo(llguam[0], llguam[1])
            context.closePath()
          }
          albersUsa.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return albersUsa.scale(1070)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$2(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Spain, configured by default for 960500.
        function conicConformalSpain() {
          var cache,
            cacheStream,
            iberianPeninsule = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]),
            iberianPeninsulePoint,
            canaryIslands = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]),
            canaryIslandsPoint,
            _point3,
            pointStream = {
              point: function point(x, y) {
                _point3 = [x, y]
              }
            }

          /*
      var iberianPeninsuleBbox = [[-11, 46], [4, 35]];
      var canaryIslandsBbox = [[-19.0, 28.85], [-12.7, 28.1]];
      */

          function conicConformalSpain(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point3 = null, (iberianPeninsulePoint.point(x, y), _point3) || (canaryIslandsPoint.point(x, y), _point3)
          }

          conicConformalSpain.invert = function (coordinates) {
            var k = iberianPeninsule.scale(),
              t = iberianPeninsule.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            return (y >= 0.05346 && y < 0.0897 && x >= -0.13388 && x < -0.0322 ? canaryIslands : iberianPeninsule).invert(coordinates)
          }

          conicConformalSpain.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$2([iberianPeninsule.stream(cacheStream = stream), canaryIslands.stream(stream)])
          }

          conicConformalSpain.precision = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.precision()
            }
            iberianPeninsule.precision(_)
            canaryIslands.precision(_)
            return reset()
          }

          conicConformalSpain.scale = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.scale()
            }
            iberianPeninsule.scale(_)
            canaryIslands.scale(_)
            return conicConformalSpain.translate(iberianPeninsule.translate())
          }

          conicConformalSpain.translate = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.translate()
            }
            var k = iberianPeninsule.scale(),
              x = +_[0],
              y = +_[1]
            /*
        var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
        var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
        console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        c0 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
        c1 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
        console.info('Canry Islands: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        */
            iberianPeninsulePoint = iberianPeninsule.translate(_).clipExtent([
              [x - 0.06857 * k, y - 0.1288 * k],
              [x + 0.13249 * k, y + 0.06 * k]
            ]).stream(pointStream)

            canaryIslandsPoint = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k]).clipExtent([
              [x - 0.1331 * k + epsilon, y + 0.053457 * k + epsilon],
              [x - 0.0354 * k - epsilon, y + 0.08969 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          conicConformalSpain.fitExtent = function (extent, object) {
            return fitExtent(conicConformalSpain, extent, object)
          }

          conicConformalSpain.fitSize = function (size, object) {
            return fitSize(conicConformalSpain, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return conicConformalSpain
          }

          conicConformalSpain.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT: ", canaryIslands.clipExtent());
        console.info("UL BBOX:", iberianPeninsule.invert([canaryIslands.clipExtent()[0][0], canaryIslands.clipExtent()[0][1]]));
        console.info("UR BBOX:", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[0][1]]));
        console.info("LD BBOX:", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[1][1]]));
        */

            var ulCanaryIslands = iberianPeninsule([-14.0346750, 34.965007])
            var urCanaryIslands = iberianPeninsule([-7.4208899, 35.536988])
            var ldCanaryIslands = iberianPeninsule([-7.3148275, 33.54359])

            context.moveTo(ulCanaryIslands[0], ulCanaryIslands[1])
            context.lineTo(urCanaryIslands[0], urCanaryIslands[1])
            context.lineTo(ldCanaryIslands[0], ldCanaryIslands[1])
          }
          conicConformalSpain.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return conicConformalSpain.scale(2700)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$3(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Portugal, configured by default for 960500.
        function conicConformalPortugal() {
          var cache,
            cacheStream,
            iberianPeninsule = d3Geo.geoConicConformal().rotate([10, -39.3]).parallels([0, 60]),
            iberianPeninsulePoint,
            madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]),
            madeiraPoint,
            azores = d3Geo.geoConicConformal().rotate([27.8, -38.6]).parallels([0, 60]),
            azoresPoint,
            _point4,
            pointStream = {
              point: function point(x, y) {
                _point4 = [x, y]
              }
            }

          /*
      var iberianPeninsuleBbox = [[-11, 46], [4, 34]];
      var madeiraBbox = [[-17.85, 33.6], [-16, 32.02]];
      var azoresBbox = [[-32, 40.529], [-23.98, 35.75]];
      */

          function conicConformalPortugal(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point4 = null, (iberianPeninsulePoint.point(x, y), _point4) || (madeiraPoint.point(x, y), _point4) || (azoresPoint.point(x, y), _point4)
          }

          conicConformalPortugal.invert = function (coordinates) {
            var k = iberianPeninsule.scale(),
              t = iberianPeninsule.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            /*
        //How are the return values calculated:
        console.info("******");
        var c0 = madeira(madeiraBbox[0]);
        var x0 = (c0[0] - t[0]) / k;
        var y0 = (c0[1] - t[1]) / k;
         console.info("p0 madeira", x0 + ' - ' + y0);
         var c1 = madeira(madeiraBbox[1]);
        var x1 = (c1[0] - t[0]) / k;
        var y1 = (c1[1] - t[1]) / k;
         console.info("p1 madeira", x1 + ' - ' + y1);
         c0 = azores(azoresBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 azores", x0 + ' - ' + y0);
         c1 = azores(azoresBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 azores", x1 + ' - ' + y1);
        */

            return (y >= 0.0093 && y < 0.03678 && x >= -0.03875 && x < -0.0116 ? madeira : y >= -0.0412 && y < 0.0091 && x >= -0.07782 && x < -0.01166 ? azores : iberianPeninsule).invert(coordinates)
          }

          conicConformalPortugal.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$3([iberianPeninsule.stream(cacheStream = stream), madeira.stream(stream), azores.stream(stream)])
          }

          conicConformalPortugal.precision = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.precision()
            }
            iberianPeninsule.precision(_)
            madeira.precision(_)
            azores.precision(_)
            return reset()
          }

          conicConformalPortugal.scale = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.scale()
            }
            iberianPeninsule.scale(_)
            madeira.scale(_)
            azores.scale(_ * 0.6)
            return conicConformalPortugal.translate(iberianPeninsule.translate())
          }

          conicConformalPortugal.translate = function (_) {
            if (!arguments.length) {
              return iberianPeninsule.translate()
            }
            var k = iberianPeninsule.scale(),
              x = +_[0],
              y = +_[1]
            /*
        var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
        var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
        console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k]])');
        c0 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
        c1 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
        console.info('Madeira: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k + epsilon, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k + epsilon],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k - epsilon, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k - epsilon]])');
         c0 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
         c1 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
         console.info('Azores: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
         (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
         ' * k + epsilon, y '+
         (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
         ' * k + epsilon],[x '+
         (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
         ' * k - epsilon, y '+
         (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
         ' * k - epsilon]])');
         */
            iberianPeninsulePoint = iberianPeninsule.translate(_).clipExtent([
              [x - 0.0115 * k, y - 0.1138 * k],
              [x + 0.2105 * k, y + 0.0673 * k]
            ]).stream(pointStream)

            madeiraPoint = madeira.translate([x - 0.0265 * k, y + 0.025 * k]).clipExtent([
              [x - 0.0388 * k + epsilon, y + 0.0093 * k + epsilon],
              [x - 0.0116 * k - epsilon, y + 0.0368 * k - epsilon]
            ]).stream(pointStream)

            azoresPoint = azores.translate([x - 0.045 * k, y + -0.02 * k]).clipExtent([
              [x - 0.0778 * k + epsilon, y - 0.0413 * k + epsilon],
              [x - 0.0117 * k - epsilon, y + 0.0091 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          conicConformalPortugal.fitExtent = function (extent, object) {
            return fitExtent(conicConformalPortugal, extent, object)
          }

          conicConformalPortugal.fitSize = function (size, object) {
            return fitSize(conicConformalPortugal, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return conicConformalPortugal
          }

          conicConformalPortugal.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT MADEIRA: ", madeira.clipExtent());
        console.info("UL BBOX:", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[0][1]]));
        console.info("UR BBOX:", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[0][1]]));
        console.info("LD BBOX:", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[1][1]]));
        console.info("LL BBOX:", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[1][1]]));
         console.info("CLIP EXTENT AZORES: ", azores.clipExtent());
        console.info("UL BBOX:", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[0][1]]));
        console.info("UR BBOX:", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[0][1]]));
        console.info("LD BBOX:", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[1][1]]));
        console.info("LL BBOX:", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[1][1]]));
        */

            var ulmadeira = iberianPeninsule([-12.8351, 38.7113])
            var urmadeira = iberianPeninsule([-10.8482, 38.7633])
            var ldmadeira = iberianPeninsule([-10.8181, 37.2072])
            var llmadeira = iberianPeninsule([-12.7345, 37.1573])

            var ulazores = iberianPeninsule([-16.0753, 41.4436])
            var urazores = iberianPeninsule([-10.9168, 41.6861])
            var ldazores = iberianPeninsule([-10.8557, 38.7747])
            var llazores = iberianPeninsule([-15.6728, 38.5505])

            context.moveTo(ulmadeira[0], ulmadeira[1])
            context.lineTo(urmadeira[0], urmadeira[1])
            context.lineTo(ldmadeira[0], ldmadeira[1])
            context.lineTo(ldmadeira[0], ldmadeira[1])
            context.lineTo(llmadeira[0], llmadeira[1])
            context.closePath()

            context.moveTo(ulazores[0], ulazores[1])
            context.lineTo(urazores[0], urazores[1])
            context.lineTo(ldazores[0], ldazores[1])
            context.lineTo(ldazores[0], ldazores[1])
            context.lineTo(llazores[0], llazores[1])
            context.closePath()
          }
          conicConformalPortugal.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return conicConformalPortugal.scale(4200)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$4(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Ecuador, configured by default for 960500.
        function mercatorEcuador() {
          var cache,
            cacheStream,
            mainland = d3Geo.geoMercator().rotate([80, 1.5]),
            mainlandPoint,
            galapagos = d3Geo.geoMercator().rotate([90.73, 1]),
            galapagosPoint,
            _point5,
            pointStream = {
              point: function point(x, y) {
                _point5 = [x, y]
              }
            }

          /*
      var mainlandBbox = [[-81.5, 2.7], [-70.0, -6.0]];
      var galapagosBbox = [[-92.2, 0.58], [-88.8, -1.8]];
      */

          function mercatorEcuador(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point5 = null, (mainlandPoint.point(x, y), _point5) || (galapagosPoint.point(x, y), _point5)
          }

          mercatorEcuador.invert = function (coordinates) {
            var k = mainland.scale(),
              t = mainland.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k
            /*
        //How are the return values calculated:
        var c0 = galapagos(galapagosBbox[0]);
        var x0 = (c0[0] - t[0]) / k;
        var y0 = (c0[1] - t[1]) / k;
         console.info("p0 galapagos", x0 + ' - ' + y0);
          var c1 = galapagos(galapagosBbox[1]);
        var x1 = (c1[0] - t[0]) / k;
        var y1 = (c1[1] - t[1]) / k;
         console.info("p1 galapagos", x1 + ' - ' + y1);
        */
            return (y >= -0.0676 && y < -0.026 && x >= -0.0857 && x < -0.0263 ? galapagos : mainland).invert(coordinates)
          }

          mercatorEcuador.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$4([mainland.stream(cacheStream = stream), galapagos.stream(stream)])
          }

          mercatorEcuador.precision = function (_) {
            if (!arguments.length) {
              return mainland.precision()
            }
            mainland.precision(_)
            galapagos.precision(_)
            return reset()
          }

          mercatorEcuador.scale = function (_) {
            if (!arguments.length) {
              return mainland.scale()
            }
            mainland.scale(_)
            galapagos.scale(_)
            return mercatorEcuador.translate(mainland.translate())
          }

          mercatorEcuador.translate = function (_) {
            if (!arguments.length) {
              return mainland.translate()
            }
            var k = mainland.scale(),
              x = +_[0],
              y = +_[1]
            /*
        var c0 = mainland(mainlandBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
        var c1 = mainland(mainlandBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
        console.info('mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k]])');
        c0 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
        c1 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
        console.info('galapagos: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k + epsilon, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k + epsilon],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k - epsilon, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k - epsilon]])'); */

            mainlandPoint = mainland.translate(_).clipExtent([
              [x - 0.0262 * k, y - 0.0734 * k],
              [x + 0.1741 * k, y + 0.079 * k]
            ]).stream(pointStream)

            galapagosPoint = galapagos.translate([x - 0.06 * k, y - 0.04 * k]).clipExtent([
              [x - 0.0857 * k + epsilon, y - 0.0676 * k + epsilon],
              [x - 0.0263 * k - epsilon, y - 0.026 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          mercatorEcuador.fitExtent = function (extent, object) {
            return fitExtent(mercatorEcuador, extent, object)
          }

          mercatorEcuador.fitSize = function (size, object) {
            return fitSize(mercatorEcuador, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return mercatorEcuador
          }

          mercatorEcuador.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT: ", galapagos.clipExtent());
        console.info("UL BBOX:", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[0][1]]));
        console.info("UR BBOX:", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[0][1]]));
        console.info("LD BBOX:", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[1][1]]));
        console.info("LL BBOX:", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[1][1]]));
        */

            var ulgalapagos = mainland([-84.9032, 2.3757])
            var urgalapagos = mainland([-81.5047, 2.3708])
            var ldgalapagos = mainland([-81.5063, -0.01])
            var llgalapagos = mainland([-84.9086, -0.005])

            context.moveTo(ulgalapagos[0], ulgalapagos[1])
            context.lineTo(urgalapagos[0], urgalapagos[1])
            context.lineTo(ldgalapagos[0], ldgalapagos[1])
            context.lineTo(llgalapagos[0], llgalapagos[1])
            context.closePath()
          }
          mercatorEcuador.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return mercatorEcuador.scale(3500)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$5(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Chile, configured by default for 960500.
        function transverseMercatorChile() {
          var cache,
            cacheStream,
            mainland = d3Geo.geoTransverseMercator().rotate([72, 37]),
            mainlandPoint,
            antarctic = d3Geo.geoStereographic().rotate([72, 0]),
            antarcticPoint,
            juanFernandez = d3Geo.geoMercator().rotate([80, 33.5]),
            juanFernandezPoint,
            pascua = d3Geo.geoMercator().rotate([110, 25]),
            pascuaPoint,
            _point6,
            pointStream = {
              point: function point(x, y) {
                _point6 = [x, y]
              }
            }

          /*
      var mainlandBbox = [[-75.5, -15.0], [-32, -49.0]];
      var antarcticBbox = [[-91.0, -60.0], [-43.0, -90.0]];
      var juanFernandezBbox = [[-81.0, -33.0], [-78.5, -34.0]];
      var pascuaBbox = [[-110, -26.6], [-108.7, -27.5]];
      */

          function transverseMercatorChile(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point6 = null, (mainlandPoint.point(x, y), _point6) || (antarcticPoint.point(x, y), _point6) || (juanFernandezPoint.point(x, y), _point6) || (pascuaPoint.point(x, y), _point6)
          }

          transverseMercatorChile.invert = function (coordinates) {
            var k = mainland.scale(),
              t = mainland.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            /*
        //How are the return values calculated:
        console.info("******");
        var c0 = antarctic(antarcticBbox[0]);
        var x0 = (c0[0] - t[0]) / k;
        var y0 = (c0[1] - t[1]) / k;
         console.info("p0 antarctic", x0 + ' - ' + y0);
         var c1 = antarctic(antarcticBbox[1]);
        var x1 = (c1[0] - t[0]) / k;
        var y1 = (c1[1] - t[1]) / k;
         console.info("p1 antarctic", x1 + ' - ' + y1);
         c0 = juanFernandez(juanFernandezBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 juanFernandez", x0 + ' - ' + y0);
         c1 = juanFernandez(juanFernandezBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 juanFernandez", x1 + ' - ' + y1);
         c0 = pascua(pascuaBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 pascua", x0 + ' - ' + y0);
         c1 = pascua(pascuaBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 pascua", x1 + ' - ' + y1);
        */

            return (y >= 0.2582 && y < 0.32 && x >= -0.1036 && x < -0.087 ? antarctic : y >= -0.01298 && y < 0.0133 && x >= -0.11396 && x < -0.05944 ? juanFernandez : y >= 0.01539 && y < 0.03911 && x >= -0.089 && x < -0.0588 ? pascua : mainland).invert(coordinates)
          }

          transverseMercatorChile.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$5([mainland.stream(cacheStream = stream), antarctic.stream(stream), juanFernandez.stream(stream), pascua.stream(stream)])
          }

          transverseMercatorChile.precision = function (_) {
            if (!arguments.length) {
              return mainland.precision()
            }
            mainland.precision(_)
            antarctic.precision(_)
            juanFernandez.precision(_)
            pascua.precision(_)
            return reset()
          }

          transverseMercatorChile.scale = function (_) {
            if (!arguments.length) {
              return mainland.scale()
            }
            mainland.scale(_)
            antarctic.scale(_ * 0.15)
            juanFernandez.scale(_ * 1.5)
            pascua.scale(_ * 1.5)
            return transverseMercatorChile.translate(mainland.translate())
          }

          transverseMercatorChile.translate = function (_) {
            if (!arguments.length) {
              return mainland.translate()
            }
            var k = mainland.scale(),
              x = +_[0],
              y = +_[1]

            /*
        var c0 = mainland(mainlandBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
        var c1 = mainland(mainlandBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
        console.info('Mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k]])');
        c0 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
        c1 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
        console.info('antarctic: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('Doesn t work due to -90 latitude!' + '.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k + epsilon, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k + epsilon],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k - epsilon, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k - epsilon]])');
         c0 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
         c1 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
         console.info('juanFernandez: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
         (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
         ' * k + epsilon, y '+
         (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
         ' * k + epsilon],[x '+
         (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
         ' * k - epsilon, y '+
         (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
         ' * k - epsilon]])');
          c0 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[0]);
         x0 = (x - c0[0]) / k;
         y0 = (y - c0[1]) / k;
          c1 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[1]);
         x1 = (x - c1[0]) / k;
         y1 = (y - c1[1]) / k;
          console.info('pascua: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
         console.info('.clipExtent([[x '+
          (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
          ' * k + epsilon, y '+
          (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
          ' * k + epsilon],[x '+
          (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
          ' * k - epsilon, y '+
          (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
          ' * k - epsilon]])');
          */
            mainlandPoint = mainland.translate(_).clipExtent([
              [x - 0.059 * k, y - 0.3835 * k],
              [x + 0.4498 * k, y + 0.3375 * k]
            ]).stream(pointStream)

            antarcticPoint = antarctic.translate([x - 0.087 * k, y + 0.17 * k]).clipExtent([
              [x - 0.1166 * k + epsilon, y + 0.2582 * k + epsilon],
              [x - 0.06 * k - epsilon, y + 0.32 * k - epsilon]
            ]).stream(pointStream)

            juanFernandezPoint = juanFernandez.translate([x - 0.092 * k, y - 0 * k]).clipExtent([
              [x - 0.114 * k + epsilon, y - 0.013 * k + epsilon],
              [x - 0.0594 * k - epsilon, y + 0.0133 * k - epsilon]
            ]).stream(pointStream)

            pascuaPoint = pascua.translate([x - 0.089 * k, y - 0.0265 * k]).clipExtent([
              [x - 0.089 * k + epsilon, y + 0.0154 * k + epsilon],
              [x - 0.0588 * k - epsilon, y + 0.0391 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          transverseMercatorChile.fitExtent = function (extent, object) {
            return fitExtent(transverseMercatorChile, extent, object)
          }

          transverseMercatorChile.fitSize = function (size, object) {
            return fitSize(transverseMercatorChile, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return transverseMercatorChile
          }

          transverseMercatorChile.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT antarctic: ", antarctic.clipExtent());
        console.info("UL BBOX:", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[0][1]]));
        console.info("UR BBOX:", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[0][1]]));
        console.info("LD BBOX:", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[1][1]]));
        console.info("LL BBOX:", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[1][1]]));
         console.info("CLIP EXTENT juanFernandez: ", juanFernandez.clipExtent());
        console.info("UL BBOX:", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[0][1]]));
        console.info("UR BBOX:", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[0][1]]));
        console.info("LD BBOX:", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[1][1]]));
        console.info("LL BBOX:", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[1][1]]));
         console.info("CLIP EXTENT pascua: ", pascua.clipExtent());
        console.info("UL BBOX:", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[0][1]]));
        console.info("UR BBOX:", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[0][1]]));
        console.info("LD BBOX:", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[1][1]]));
        console.info("LL BBOX:", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[1][1]]));
        */

            var ulantarctic = mainland([-82.6999, -51.3043])
            var urantarctic = mainland([-77.5442, -51.6631])
            var ldantarctic = mainland([-78.0254, -55.1860])
            var llantarctic = mainland([-83.6106, -54.7785])

            var uljuanFernandez = mainland([-80.0638, -35.9840])
            var urjuanFernandez = mainland([-76.2153, -36.1811])
            var ldjuanFernandez = mainland([-76.2994, -37.6839])
            var lljuanFernandez = mainland([-80.2231, -37.4757])

            var ulpascua = mainland([-78.442, -37.706])
            var urpascua = mainland([-76.263, -37.8054])
            var ldpascua = mainland([-76.344, -39.1595])
            var llpascua = mainland([-78.5638, -39.0559])

            context.moveTo(ulantarctic[0], ulantarctic[1])
            context.lineTo(urantarctic[0], urantarctic[1])
            context.lineTo(ldantarctic[0], ldantarctic[1])
            context.lineTo(ldantarctic[0], ldantarctic[1])
            context.lineTo(llantarctic[0], llantarctic[1])
            context.closePath()

            context.moveTo(uljuanFernandez[0], uljuanFernandez[1])
            context.lineTo(urjuanFernandez[0], urjuanFernandez[1])
            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1])
            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1])
            context.lineTo(lljuanFernandez[0], lljuanFernandez[1])
            context.closePath()

            context.moveTo(ulpascua[0], ulpascua[1])
            context.lineTo(urpascua[0], urpascua[1])
            context.lineTo(ldpascua[0], ldpascua[1])
            context.lineTo(ldpascua[0], ldpascua[1])
            context.lineTo(llpascua[0], llpascua[1])
            context.closePath()
          }
          transverseMercatorChile.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return transverseMercatorChile.scale(700)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$6(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Portugal, configured by default for 960500.
        function conicEquidistantJapan() {
          var cache,
            cacheStream,
            mainland = d3Geo.geoConicEquidistant().rotate([-136, -22]).parallels([40, 34]),
            mainlandPoint,
            // gis.stackexchange.com/a/73135
            hokkaido = d3Geo.geoConicEquidistant().rotate([-146, -26]).parallels([40, 34]),
            hokkaidoPoint,
            okinawa = d3Geo.geoConicEquidistant().rotate([-126, -19]).parallels([40, 34]),
            okinawaPoint,
            _point7,
            pointStream = {
              point: function point(x, y) {
                _point7 = [x, y]
              }
            }

          /*
      var mainlandBbox = [[126.0, 41.606], [142.97, 29.97]];
      var hokkaidoBbox = [[138.7, 45.61], [146.2, 41.2]];
      var okinawaBbox = [[122.6, 29.0], [130, 23.7]];
      */

          function conicEquidistantJapan(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point7 = null, (mainlandPoint.point(x, y), _point7) || (hokkaidoPoint.point(x, y), _point7) || (okinawaPoint.point(x, y), _point7)
          }

          conicEquidistantJapan.invert = function (coordinates) {
            var k = mainland.scale(),
              t = mainland.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            /*
        //How are the return values calculated:
        console.info("******");
        var c0 = hokkaido(hokkaidoBbox[0]);
        var x0 = (c0[0] - t[0]) / k;
        var y0 = (c0[1] - t[1]) / k;
         console.info("p0 hokkaido", x0 + ' - ' + y0);
         var c1 = hokkaido(hokkaidoBbox[1]);
        var x1 = (c1[0] - t[0]) / k;
        var y1 = (c1[1] - t[1]) / k;
         console.info("p1 hokkaido", x1 + ' - ' + y1);
         c0 = okinawa(okinawaBbox[0]);
        x0 = (c0[0] - t[0]) / k;
        y0 = (c0[1] - t[1]) / k;
         console.info("p0 okinawa", x0 + ' - ' + y0);
         c1 = okinawa(okinawaBbox[1]);
        x1 = (c1[0] - t[0]) / k;
        y1 = (c1[1] - t[1]) / k;
         console.info("p1 okinawa", x1 + ' - ' + y1);
        */

            return (y >= -0.10925 && y < -0.02701 && x >= -0.135 && x < -0.0397 ? hokkaido : y >= 0.04713 && y < 0.11138 && x >= -0.03986 && x < 0.051 ? okinawa : mainland).invert(coordinates)
          }

          conicEquidistantJapan.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$6([mainland.stream(cacheStream = stream), hokkaido.stream(stream), okinawa.stream(stream)])
          }

          conicEquidistantJapan.precision = function (_) {
            if (!arguments.length) {
              return mainland.precision()
            }
            mainland.precision(_)
            hokkaido.precision(_)
            okinawa.precision(_)
            return reset()
          }

          conicEquidistantJapan.scale = function (_) {
            if (!arguments.length) {
              return mainland.scale()
            }
            mainland.scale(_)
            hokkaido.scale(_)
            okinawa.scale(_ * 0.7)
            return conicEquidistantJapan.translate(mainland.translate())
          }

          conicEquidistantJapan.translate = function (_) {
            if (!arguments.length) {
              return mainland.translate()
            }
            var k = mainland.scale(),
              x = +_[0],
              y = +_[1]

            /*
        var c0 = mainland(mainlandBbox[0]);
        var x0 = (x - c0[0]) / k;
        var y0 = (y - c0[1]) / k;
        var c1 = mainland(mainlandBbox[1]);
        var x1 = (x - c1[0]) / k;
        var y1 = (y - c1[1]) / k;
        console.info('Main: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k]])');
        c0 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
        c1 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
        console.info('hokkaido: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
        (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
        ' * k + epsilon, y '+
        (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
        ' * k + epsilon],[x '+
        (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
        ' * k - epsilon, y '+
        (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
        ' * k - epsilon]])');
         c0 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[0]);
        x0 = (x - c0[0]) / k;
        y0 = (y - c0[1]) / k;
         c1 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[1]);
        x1 = (x - c1[0]) / k;
        y1 = (y - c1[1]) / k;
         console.info('okinawa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);
        console.info('.clipExtent([[x '+
         (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+
         ' * k + epsilon, y '+
         (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+
         ' * k + epsilon],[x '+
         (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+
         ' * k - epsilon, y '+
         (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+
         ' * k - epsilon]])');
         */

            mainlandPoint = mainland.translate(_).clipExtent([
              [x - 0.1352 * k, y - 0.1091 * k],
              [x + 0.117 * k, y + 0.098 * k]
            ]).stream(pointStream)

            hokkaidoPoint = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k]).clipExtent([
              [x - 0.135 * k + epsilon, y - 0.1093 * k + epsilon],
              [x - 0.0397 * k - epsilon, y - 0.027 * k - epsilon]
            ]).stream(pointStream)

            okinawaPoint = okinawa.translate(_).clipExtent([
              [x - 0.0399 * k + epsilon, y + 0.0471 * k + epsilon],
              [x + 0.051 * k - epsilon, y + 0.1114 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          conicEquidistantJapan.fitExtent = function (extent, object) {
            return fitExtent(conicEquidistantJapan, extent, object)
          }

          conicEquidistantJapan.fitSize = function (size, object) {
            return fitSize(conicEquidistantJapan, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return conicEquidistantJapan
          }

          conicEquidistantJapan.drawCompositionBorders = function (context) {
            /*
        console.info("CLIP EXTENT hokkaido: ", hokkaido.clipExtent());
        console.info("UL BBOX:", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[0][1]]));
        console.info("UR BBOX:", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[0][1]]));
        console.info("LD BBOX:", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[1][1]]));
        console.info("LL BBOX:", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[1][1]]));
        */

            var ulhokkaido = mainland([126.01320483689143, 41.621090310215585])
            var urhokkaido = mainland([133.04304387025903, 42.15087523707186])
            var ldhokkaido = mainland([133.3021766080688, 37.43975444725098])
            var llhokkaido = mainland([126.87889168628224, 36.95488945159779])

            var llokinawa = mainland([132.9, 29.8])
            var lmokinawa = mainland([134, 33])
            var lrokinawa = mainland([139.3, 33.2])
            var llrokinawa = mainland([139.16, 30.5])

            context.moveTo(ulhokkaido[0], ulhokkaido[1])
            context.lineTo(urhokkaido[0], urhokkaido[1])
            context.lineTo(ldhokkaido[0], ldhokkaido[1])
            context.lineTo(llhokkaido[0], llhokkaido[1])
            context.closePath()

            context.moveTo(llokinawa[0], llokinawa[1])
            context.lineTo(lmokinawa[0], lmokinawa[1])
            context.lineTo(lrokinawa[0], lrokinawa[1])
            context.lineTo(llrokinawa[0], llrokinawa[1])
          }
          conicEquidistantJapan.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return conicEquidistantJapan.scale(2200)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$7(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for France, configured by default for 960500.
        function conicConformalFrance() {
          var cache,
            cacheStream,
            europe = d3Geo.geoConicConformal().rotate([-3, -46.2]).parallels([0, 60]),
            europePoint,
            guyane = d3Geo.geoMercator().center([-53.2, 3.9]),
            guyanePoint,
            martinique = d3Geo.geoMercator().center([-61.03, 14.67]),
            martiniquePoint,
            guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]),
            guadeloupePoint,
            saintBarthelemy = d3Geo.geoMercator().center([-62.85, 17.92]),
            saintBarthelemyPoint,
            stPierreMiquelon = d3Geo.geoMercator().center([-56.23, 46.93]),
            stPierreMiquelonPoint,
            mayotte = d3Geo.geoMercator().center([45.16, -12.8]),
            mayottePoint,
            reunion = d3Geo.geoMercator().center([55.52, -21.13]),
            reunionPoint,
            nouvelleCaledonie = d3Geo.geoMercator().center([165.8, -21.07]),
            nouvelleCaledoniePoint,
            wallisFutuna = d3Geo.geoMercator().center([-178.1, -14.3]),
            wallisFutunaPoint,
            polynesie = d3Geo.geoMercator().center([-150.55, -17.11]),
            polynesiePoint,
            polynesie2 = d3Geo.geoMercator().center([-150.55, -17.11]),
            polynesie2Point,
            _point8,
            pointStream = {
              point: function point(x, y) {
                _point8 = [x, y]
              }
            }

          /*
      var europeBbox = [[-6.5, 51], [10, 41]];
      var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];
      */

          function conicConformalFrance(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point8 = null, (europePoint.point(x, y), _point8) || (guyanePoint.point(x, y), _point8) || (martiniquePoint.point(x, y), _point8) || (guadeloupePoint.point(x, y), _point8) || (saintBarthelemyPoint.point(x, y), _point8) || (stPierreMiquelonPoint.point(x, y), _point8) || (mayottePoint.point(x, y), _point8) || (reunionPoint.point(x, y), _point8) || (nouvelleCaledoniePoint.point(x, y), _point8) || (wallisFutunaPoint.point(x, y), _point8) || (polynesiePoint.point(x, y), _point8) || (polynesie2Point.point(x, y), _point8)
          }

          conicConformalFrance.invert = function (coordinates) {
            var k = europe.scale(),
              t = europe.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            return (y >= 0.029 && y < 0.0864 && x >= -0.14 && x < -0.0996 ? guyane : y >= 0 && y < 0.029 && x >= -0.14 && x < -0.0996 ? martinique : y >= -0.032 && y < 0 && x >= -0.14 && x < -0.0996 ? guadeloupe : y >= -0.052 && y < -0.032 && x >= -0.14 && x < -0.0996 ? saintBarthelemy : y >= -0.076 && y < 0.052 && x >= -0.14 && x < -0.0996 ? stPierreMiquelon : y >= -0.076 && y < -0.052 && x >= 0.0967 && x < 0.1371 ? mayotte : y >= -0.052 && y < -0.02 && x >= 0.0967 && x < 0.1371 ? reunion : y >= -0.02 && y < 0.012 && x >= 0.0967 && x < 0.1371 ? nouvelleCaledonie : y >= 0.012 && y < 0.033 && x >= 0.0967 && x < 0.1371 ? wallisFutuna : y >= 0.033 && y < 0.0864 && x >= 0.0967 && x < 0.1371 ? polynesie : europe).invert(coordinates)
          }

          conicConformalFrance.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$7([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), saintBarthelemy.stream(stream), stPierreMiquelon.stream(stream), mayotte.stream(stream), reunion.stream(stream), nouvelleCaledonie.stream(stream), wallisFutuna.stream(stream), polynesie.stream(stream), polynesie2.stream(stream)])
          }

          conicConformalFrance.precision = function (_) {
            if (!arguments.length) {
              return europe.precision()
            }
            europe.precision(_)
            guyane.precision(_)
            martinique.precision(_)
            guadeloupe.precision(_)
            saintBarthelemy.precision(_)
            stPierreMiquelon.precision(_)
            mayotte.precision(_)
            reunion.precision(_)
            nouvelleCaledonie.precision(_)
            wallisFutuna.precision(_)
            polynesie.precision(_)
            polynesie2.precision(_)

            return reset()
          }

          conicConformalFrance.scale = function (_) {
            if (!arguments.length) {
              return europe.scale()
            }
            europe.scale(_)
            guyane.scale(_ * 0.6)
            martinique.scale(_ * 1.6)
            guadeloupe.scale(_ * 1.4)
            saintBarthelemy.scale(_ * 5)
            stPierreMiquelon.scale(_ * 1.3)
            mayotte.scale(_ * 1.6)
            reunion.scale(_ * 1.2)
            nouvelleCaledonie.scale(_ * 0.3)
            wallisFutuna.scale(_ * 2.7)
            polynesie.scale(_ * 0.5)
            polynesie2.scale(_ * 0.06)
            return conicConformalFrance.translate(europe.translate())
          }

          conicConformalFrance.translate = function (_) {
            if (!arguments.length) {
              return europe.translate()
            }
            var k = europe.scale(),
              x = +_[0],
              y = +_[1]

            europePoint = europe.translate(_).clipExtent([
              [x - 0.0996 * k, y - 0.0908 * k],
              [x + 0.0967 * k, y + 0.0864 * k]
            ]).stream(pointStream)

            guyanePoint = guyane.translate([x - 0.12 * k, y + 0.0575 * k]).clipExtent([
              [x - 0.14 * k + epsilon, y + 0.029 * k + epsilon],
              [x - 0.0996 * k - epsilon, y + 0.0864 * k - epsilon]
            ]).stream(pointStream)

            martiniquePoint = martinique.translate([x - 0.12 * k, y + 0.013 * k]).clipExtent([
              [x - 0.14 * k + epsilon, y + 0 * k + epsilon],
              [x - 0.0996 * k - epsilon, y + 0.029 * k - epsilon]
            ]).stream(pointStream)

            guadeloupePoint = guadeloupe.translate([x - 0.12 * k, y - 0.014 * k]).clipExtent([
              [x - 0.14 * k + epsilon, y - 0.032 * k + epsilon],
              [x - 0.0996 * k - epsilon, y + 0 * k - epsilon]
            ]).stream(pointStream)

            saintBarthelemyPoint = saintBarthelemy.translate([x - 0.12 * k, y - 0.044 * k]).clipExtent([
              [x - 0.14 * k + epsilon, y - 0.052 * k + epsilon],
              [x - 0.0996 * k - epsilon, y - 0.032 * k - epsilon]
            ]).stream(pointStream)

            stPierreMiquelonPoint = stPierreMiquelon.translate([x - 0.12 * k, y - 0.065 * k]).clipExtent([
              [x - 0.14 * k + epsilon, y - 0.076 * k + epsilon],
              [x - 0.0996 * k - epsilon, y - 0.052 * k - epsilon]
            ]).stream(pointStream)

            mayottePoint = mayotte.translate([x + 0.117 * k, y - 0.064 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y - 0.076 * k + epsilon],
              [x + 0.1371 * k - epsilon, y - 0.052 * k - epsilon]
            ]).stream(pointStream)

            reunionPoint = reunion.translate([x + 0.116 * k, y - 0.0355 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y - 0.052 * k + epsilon],
              [x + 0.1371 * k - epsilon, y - 0.02 * k - epsilon]
            ]).stream(pointStream)

            nouvelleCaledoniePoint = nouvelleCaledonie.translate([x + 0.116 * k, y - 0.0048 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y - 0.02 * k + epsilon],
              [x + 0.1371 * k - epsilon, y + 0.012 * k - epsilon]
            ]).stream(pointStream)

            wallisFutunaPoint = wallisFutuna.translate([x + 0.116 * k, y + 0.022 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y + 0.012 * k + epsilon],
              [x + 0.1371 * k - epsilon, y + 0.033 * k - epsilon]
            ]).stream(pointStream)

            polynesie2Point = polynesie2.translate([x + 0.11 * k, y + 0.045 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y + 0.033 * k + epsilon],
              [x + 0.1371 * k - epsilon, y + 0.06 * k - epsilon]
            ]).stream(pointStream)

            polynesiePoint = polynesie.translate([x + 0.115 * k, y + 0.075 * k]).clipExtent([
              [x + 0.0967 * k + epsilon, y + 0.06 * k + epsilon],
              [x + 0.1371 * k - epsilon, y + 0.0864 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          conicConformalFrance.fitExtent = function (extent, object) {
            return fitExtent(conicConformalFrance, extent, object)
          }

          conicConformalFrance.fitSize = function (size, object) {
            return fitSize(conicConformalFrance, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return conicConformalFrance
          }

          conicConformalFrance.drawCompositionBorders = function (context) {
            /*
        console.log("var ul, ur, ld, ll;");
        var projs = [guyane, martinique, guadeloupe, saintBarthelemy, stPierreMiquelon, mayotte, reunion, nouvelleCaledonie, wallisFutuna, polynesie, polynesie2];
        for (var i in projs){
          var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);
          var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);
          var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);
          var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);
           console.log("ul = europe(["+ul+"]);");
          console.log("ur = europe(["+ur+"]);");
          console.log("ld = europe(["+ld+"]);");
          console.log("ll = europe(["+ll+"]);");
           console.log("context.moveTo(ul[0], ul[1]);");
          console.log("context.lineTo(ur[0], ur[1]);");
          console.log("context.lineTo(ld[0], ld[1]);");
          console.log("context.lineTo(ll[0], ll[1]);");
          console.log("context.closePath();");
         } */

            var ul, ur, ld, ll
            ul = europe([-7.938886725111036, 43.7219460918835])
            ur = europe([-4.832080896458295, 44.12930268549372])
            ld = europe([-4.205299743793263, 40.98096346967365])
            ll = europe([-7.071796453126152, 40.610037319181444])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([-8.42751373617692, 45.32889452553031])
            ur = europe([-5.18599305777107, 45.7566442062976])
            ld = europe([-4.832080905154431, 44.129302726751426])
            ll = europe([-7.938886737126192, 43.72194613263854])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([-9.012656899657046, 47.127733821030176])
            ur = europe([-5.6105244772793155, 47.579777861410626])
            ld = europe([-5.185993067168585, 45.756644248170346])
            ll = europe([-8.427513749141811, 45.32889456686326])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([-9.405747558985553, 48.26506375557457])
            ur = europe([-5.896175018439575, 48.733352850851624])
            ld = europe([-5.610524487556043, 47.57977790393761])
            ll = europe([-9.012656913808351, 47.127733862971255])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([-9.908436061346974, 49.642448789505856])
            ur = europe([-6.262026716233124, 50.131426841787174])
            ld = europe([-5.896175029331232, 48.73335289377258])
            ll = europe([-9.40574757396393, 48.26506379787767])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([11.996907706504462, 50.16039028163579])
            ur = europe([15.649907879773343, 49.68279246765253])
            ld = europe([15.156712840526632, 48.30371557625831])
            ll = europe([11.64122661754411, 48.761078240546816])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([11.641226606955788, 48.7610781975889])
            ur = europe([15.156712825832164, 48.30371553390465])
            ld = europe([14.549932166241172, 46.4866532486199])
            ll = europe([11.204443787952183, 46.91899233914248])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([11.204443778297161, 46.918992296823646])
            ur = europe([14.549932152815039, 46.486653206856396])
            ld = europe([13.994409796764009, 44.695833444323256])
            ll = europe([10.805306599253848, 45.105133870684924])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([10.805306590412085, 45.10513382903308])
            ur = europe([13.99440978444733, 44.695833403183606])
            ld = europe([13.654633799024392, 43.53552468558152])
            ll = europe([10.561516803980956, 43.930671459798624])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()

            ul = europe([10.561516795617383, 43.93067141859757])
            ur = europe([13.654633787361952, 43.5355246448671])
            ld = europe([12.867691604239901, 40.640701985019405])
            ll = europe([9.997809515987688, 41.00288343254471])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()

            ul = europe([10.8, 42.4])
            ur = europe([12.8, 42.13])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
          }
          conicConformalFrance.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return conicConformalFrance.scale(2700)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$8(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Portugal, configured by default for 960500.
        function conicConformalEurope() {
          var cache,
            cacheStream,
            europe = d3Geo.geoConicConformal().rotate([-10, -53]).parallels([0, 60]),
            europePoint,
            guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]),
            guadeloupePoint,
            guyane = d3Geo.geoMercator().center([-53.2, 3.9]),
            guyanePoint,
            azores = d3Geo.geoConicConformal().rotate([27.8, -38.9]).parallels([0, 60]),
            azoresPoint,
            azores2 = d3Geo.geoConicConformal().rotate([25.43, -37.398]).parallels([0, 60]),
            azores2Point,
            azores3 = d3Geo.geoConicConformal().rotate([31.17, -39.539]).parallels([0, 60]),
            azores3Point,
            madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]),
            madeiraPoint,
            canaryIslands = d3Geo.geoConicConformal().rotate([16, -28.5]).parallels([0, 60]),
            canaryIslandsPoint,
            martinique = d3Geo.geoMercator().center([-61.03, 14.67]),
            martiniquePoint,
            mayotte = d3Geo.geoMercator().center([45.16, -12.8]),
            mayottePoint,
            reunion = d3Geo.geoMercator().center([55.52, -21.13]),
            reunionPoint,
            malta = d3Geo.geoConicConformal().rotate([-14.4, -35.95]).parallels([0, 60]),
            maltaPoint,
            _point9,
            pointStream = {
              point: function point(x, y) {
                _point9 = [x, y]
              }
            }

          /*
      var europeBbox = [[-6.5, 51], [10, 41]];
      var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];
      */

          function conicConformalEurope(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point9 = null, (europePoint.point(x, y), _point9) || (guyanePoint.point(x, y), _point9) || (martiniquePoint.point(x, y), _point9) || (guadeloupePoint.point(x, y), _point9) || (canaryIslandsPoint.point(x, y), _point9) || (madeiraPoint.point(x, y), _point9) || (mayottePoint.point(x, y), _point9) || (reunionPoint.point(x, y), _point9) || (maltaPoint.point(x, y), _point9) || (azoresPoint.point(x, y), _point9) || (azores2Point.point(x, y), _point9) || (azores3Point.point(x, y), _point9)
          }

          conicConformalEurope.invert = function (coordinates) {
            var k = europe.scale(),
              t = europe.translate(),
              x = (coordinates[0] - (t[0] + 0.08 * k)) / k,
              y = (coordinates[1] - t[1]) / k

            return (y >= -0.31 && y < -0.24 && x >= 0.14 && x < 0.24 ? guadeloupe : y >= -0.24 && y < -0.17 && x >= 0.14 && x < 0.24 ? guyane : y >= -0.17 && y < -0.12 && x >= 0.21 && x < 0.24 ? azores2 : y >= -0.17 && y < -0.14 && x >= 0.14 && x < 0.165 ? azores3 : y >= -0.17 && y < -0.1 && x >= 0.14 && x < 0.24 ? azores : y >= -0.1 && y < -0.03 && x >= 0.14 && x < 0.24 ? madeira : y >= -0.03 && y < 0.04 && x >= 0.14 && x < 0.24 ? canaryIslands : y >= -0.31 && y < -0.24 && x >= 0.24 && x < 0.34 ? martinique : y >= -0.24 && y < -0.17 && x >= 0.24 && x < 0.34 ? mayotte : y >= -0.17 && y < -0.1 && x >= 0.24 && x < 0.34 ? reunion : y >= -0.1 && y < -0.03 && x >= 0.24 && x < 0.34 ? malta : europe).invert(coordinates)
          }

          conicConformalEurope.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$8([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), canaryIslands.stream(stream), madeira.stream(stream), mayotte.stream(stream), reunion.stream(stream), malta.stream(stream), azores.stream(stream), azores2.stream(stream), azores3.stream(stream)])
          }

          conicConformalEurope.precision = function (_) {
            if (!arguments.length) {
              return europe.precision()
            }
            europe.precision(_)
            guyane.precision(_)
            martinique.precision(_)
            guadeloupe.precision(_)
            canaryIslands.precision(_)
            madeira.precision(_)
            mayotte.precision(_)
            reunion.precision(_)
            malta.precision(_)

            azores.precision(_)
            azores2.precision(_)
            azores3.precision(_)

            return reset()
          }

          conicConformalEurope.scale = function (_) {
            if (!arguments.length) {
              return europe.scale()
            }
            europe.scale(_)
            guadeloupe.scale(_ * 3)
            guyane.scale(_ * 0.8)
            martinique.scale(_ * 3.5)
            reunion.scale(_ * 2.7)
            azores.scale(_ * 2)
            azores2.scale(_ * 2)
            azores3.scale(_ * 2)
            madeira.scale(_ * 3)
            canaryIslands.scale(_)

            mayotte.scale(_ * 5.5)
            malta.scale(_ * 6)

            return conicConformalEurope.translate(europe.translate())
          }

          conicConformalEurope.translate = function (_) {
            if (!arguments.length) {
              return europe.translate()
            }
            var k = europe.scale(),
              x = +_[0],
              y = +_[1]

            europePoint = europe.translate([x - 0.08 * k, y]).clipExtent([
              [x - 0.51 * k, y - 0.33 * k],
              [x + 0.5 * k, y + 0.33 * k]
            ]).stream(pointStream)

            guadeloupePoint = guadeloupe.translate([x + 0.19 * k, y - 0.275 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.31 * k + epsilon],
              [x + 0.24 * k - epsilon, y - 0.24 * k - epsilon]
            ]).stream(pointStream)

            guyanePoint = guyane.translate([x + 0.19 * k, y - 0.205 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.24 * k + epsilon],
              [x + 0.24 * k - epsilon, y - 0.17 * k - epsilon]
            ]).stream(pointStream)

            azoresPoint = azores.translate([x + 0.19 * k, y - 0.135 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.17 * k + epsilon],
              [x + 0.24 * k - epsilon, y - 0.1 * k - epsilon]
            ]).stream(pointStream)

            azores2Point = azores2.translate([x + 0.225 * k, y - 0.147 * k]).clipExtent([
              [x + 0.21 * k + epsilon, y - 0.17 * k + epsilon],
              [x + 0.24 * k - epsilon, y - 0.12 * k - epsilon]
            ]).stream(pointStream)

            azores3Point = azores3.translate([x + 0.153 * k, y - 0.15 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.17 * k + epsilon],
              [x + 0.165 * k - epsilon, y - 0.14 * k - epsilon]
            ]).stream(pointStream)

            madeiraPoint = madeira.translate([x + 0.19 * k, y - 0.065 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.1 * k + epsilon],
              [x + 0.24 * k - epsilon, y - 0.03 * k - epsilon]
            ]).stream(pointStream)

            canaryIslandsPoint = canaryIslands.translate([x + 0.19 * k, y + 0.005 * k]).clipExtent([
              [x + 0.14 * k + epsilon, y - 0.03 * k + epsilon],
              [x + 0.24 * k - epsilon, y + 0.04 * k - epsilon]
            ]).stream(pointStream)

            martiniquePoint = martinique.translate([x + 0.29 * k, y - 0.275 * k]).clipExtent([
              [x + 0.24 * k + epsilon, y - 0.31 * k + epsilon],
              [x + 0.34 * k - epsilon, y - 0.24 * k - epsilon]
            ]).stream(pointStream)

            mayottePoint = mayotte.translate([x + 0.29 * k, y - 0.205 * k]).clipExtent([
              [x + 0.24 * k + epsilon, y - 0.24 * k + epsilon],
              [x + 0.34 * k - epsilon, y - 0.17 * k - epsilon]
            ]).stream(pointStream)

            reunionPoint = reunion.translate([x + 0.29 * k, y - 0.135 * k]).clipExtent([
              [x + 0.24 * k + epsilon, y - 0.17 * k + epsilon],
              [x + 0.34 * k - epsilon, y - 0.1 * k - epsilon]
            ]).stream(pointStream)

            maltaPoint = malta.translate([x + 0.29 * k, y - 0.065 * k]).clipExtent([
              [x + 0.24 * k + epsilon, y - 0.1 * k + epsilon],
              [x + 0.34 * k - epsilon, y - 0.03 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          conicConformalEurope.fitExtent = function (extent, object) {
            return fitExtent(conicConformalEurope, extent, object)
          }

          conicConformalEurope.fitSize = function (size, object) {
            return fitSize(conicConformalEurope, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return conicConformalEurope
          }

          conicConformalEurope.drawCompositionBorders = function (context) {
            /*
        console.log("var ul, ur, ld, ll;");
        var projs = [guyane, martinique, guadeloupe, canaryIslands, madeira, mayotte, reunion, malta, azores, azores2, azores3];
        for (var i in projs){
          var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);
          var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);
          var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);
          var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);
           console.log("ul = europe(["+ul+"]);");
          console.log("ur = europe(["+ur+"]);");
          console.log("ld = europe(["+ld+"]);");
          console.log("ll = europe(["+ll+"]);");
           console.log("context.moveTo(ul[0], ul[1]);");
          console.log("context.lineTo(ur[0], ur[1]);");
          console.log("context.lineTo(ld[0], ld[1]);");
          console.log("context.lineTo(ll[0], ll[1]);");
          console.log("context.closePath();");
         } */

            var ul, ur, ld, ll
            ul = europe([42.45755610828648, 63.343658547914934])
            ur = europe([52.65837266667029, 59.35045080290929])
            ld = europe([47.19754502247785, 56.12653496548117])
            ll = europe([37.673034273363044, 59.61638268506111])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([59.41110754003403, 62.35069727399336])
            ur = europe([66.75050228640794, 57.11797303636038])
            ld = europe([60.236065725110436, 54.63331433818992])
            ll = europe([52.65837313153311, 59.350450804599355])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([48.81091130080243, 66.93353402634641])
            ur = europe([59.41110730654679, 62.35069740653086])
            ld = europe([52.6583728974441, 59.3504509222445])
            ll = europe([42.45755631675751, 63.34365868805821])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([31.054198418446475, 52.1080673766184])
            ur = europe([39.09869284884117, 49.400700047190554])
            ld = europe([36.0580811499175, 46.02944174908498])
            ll = europe([28.690508588835726, 48.433126979386415])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([33.977877745912025, 55.849945501331])
            ur = europe([42.75328432167726, 52.78455122462353])
            ld = europe([39.09869297540224, 49.400700176148625])
            ll = europe([31.05419851807008, 52.10806751810923])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([52.658372900759296, 59.35045068526415])
            ur = europe([60.23606549583304, 54.63331423800264])
            ld = europe([54.6756370953122, 51.892298789399455])
            ll = europe([47.19754524788189, 56.126534861222794])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([47.19754506082455, 56.126534735591456])
            ur = europe([54.675636900123514, 51.892298681337095])
            ld = europe([49.94448648951486, 48.98775484983285])
            ll = europe([42.75328468716108, 52.78455126060818])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([42.75328453416769, 52.78455113209101])
            ur = europe([49.94448632339758, 48.98775473706457])
            ld = europe([45.912339990394315, 45.99361784987003])
            ll = europe([39.09869317356607, 49.40070009378711])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([37.673034114296634, 59.61638254183119])
            ur = europe([47.197544835420544, 56.126534839849846])
            ld = europe([42.75328447467064, 52.78455135314068])
            ll = europe([33.977877870363905, 55.849945644671145])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([44.56748486446032, 57.26489367845818])
            ld = europe([43.9335791193588, 53.746540942601726])
            ll = europe([43, 56])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = europe([37.673034114296634, 59.61638254183119])
            ur = europe([40.25902691953466, 58.83002044222639])
            ld = europe([38.458270492742024, 57.26232178028002])
            ll = europe([35.97754948030156, 58.00266637992386])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
          }
          conicConformalEurope.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return conicConformalEurope.scale(750)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$9(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Malaysia, configured by default for 960500.
        function mercatorMalaysia() {
          var cache,
            cacheStream,
            peninsular = d3Geo.geoMercator().center([105.25, 4.00]),
            peninsularPoint,
            borneo = d3Geo.geoMercator().center([118.65, 2.86]),
            borneoPoint,
            _point10,
            pointStream = {
              point: function point(x, y) {
                _point10 = [x, y]
              }
            }

          function mercatorMalaysia(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point10 = null, (peninsularPoint.point(x, y), _point10) || (borneoPoint.point(x, y), _point10)
          }

          mercatorMalaysia.invert = function (coordinates) {
            var k = peninsular.scale(),
              t = peninsular.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k

            return (y >= -0.0521 && y < 0.0229 && x >= -0.0111 && x < 0.1000 ? borneo : peninsular).invert(coordinates)
          }

          mercatorMalaysia.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$9([peninsular.stream(cacheStream = stream), borneo.stream(stream)])
          }

          mercatorMalaysia.precision = function (_) {
            if (!arguments.length) {
              return peninsular.precision()
            }
            peninsular.precision(_)
            borneo.precision(_)
            return reset()
          }

          mercatorMalaysia.scale = function (_) {
            if (!arguments.length) {
              return peninsular.scale()
            }
            peninsular.scale(_)
            borneo.scale(_ * 0.615)
            return mercatorMalaysia.translate(peninsular.translate())
          }

          mercatorMalaysia.translate = function (_) {
            if (!arguments.length) {
              return peninsular.translate()
            }
            var k = peninsular.scale(),
              x = +_[0],
              y = +_[1]

            peninsularPoint = peninsular.translate(_).clipExtent([
              [x - 0.1100 * k, y - 0.0521 * k],
              [x - 0.0111 * k, y + 0.0521 * k]
            ]).stream(pointStream)

            borneoPoint = borneo.translate([x + 0.09000 * k, y - 0.00 * k]).clipExtent([
              [x - 0.0111 * k + epsilon, y - 0.0521 * k + epsilon],
              [x + 0.1000 * k - epsilon, y + 0.024 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          mercatorMalaysia.fitExtent = function (extent, object) {
            return fitExtent(mercatorMalaysia, extent, object)
          }

          mercatorMalaysia.fitSize = function (size, object) {
            return fitSize(mercatorMalaysia, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return mercatorMalaysia
          }

          mercatorMalaysia.drawCompositionBorders = function (context) {
            var llbor = peninsular([106.3214, 2.0228])
            var lmbor = peninsular([105.1843, 2.3761])
            var lrbor = peninsular([104.2151, 3.3618])
            var llrbor = peninsular([104.2150, 4.5651])

            context.moveTo(llbor[0], llbor[1])
            context.lineTo(lmbor[0], lmbor[1])
            context.lineTo(lrbor[0], lrbor[1])
            context.lineTo(llrbor[0], llrbor[1])
          }
          mercatorMalaysia.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return mercatorMalaysia.scale(4800)
        }

        // The projections must have mutually exclusive clip regions on the sphere,
        // as this will avoid emitting interleaving lines and polygons.
        function multiplex$10(streams) {
          var n = streams.length
          return {
            point: function point(x, y) {
              var i = -1;
              while (++i < n) {
                streams[i].point(x, y)
              }
            },
            sphere: function sphere() {
              var i = -1;
              while (++i < n) {
                streams[i].sphere()
              }
            },
            lineStart: function lineStart() {
              var i = -1;
              while (++i < n) {
                streams[i].lineStart()
              }
            },
            lineEnd: function lineEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].lineEnd()
              }
            },
            polygonStart: function polygonStart() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonStart()
              }
            },
            polygonEnd: function polygonEnd() {
              var i = -1;
              while (++i < n) {
                streams[i].polygonEnd()
              }
            }
          }
        }

        // A composite projection for Equatorial Guinea, configured by default for 960500.
        function mercatorEquatorialGuinea() {
          var cache,
            cacheStream,
            continent = d3Geo.geoMercator().rotate([-9.5, -1.5]),
            continentPoint,
            bioko = d3Geo.geoMercator().rotate([-8.6, -3.5]),
            biokoPoint,
            annobon = d3Geo.geoMercator().rotate([-5.6, 1.45]),
            annobonPoint,
            _point11,
            pointStream = {
              point: function point(x, y) {
                _point11 = [x, y]
              }
            }

          function mercatorEquatorialGuinea(coordinates) {
            var x = coordinates[0],
              y = coordinates[1]
            return _point11 = null, (continentPoint.point(x, y), _point11) || (biokoPoint.point(x, y), _point11) || (annobonPoint.point(x, y), _point11)
          }

          mercatorEquatorialGuinea.invert = function (coordinates) {
            var k = continent.scale(),
              t = continent.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k
            return (y >= -0.02 && y < 0 && x >= -0.038 && x < -0.005 ? bioko : y >= 0 && y < 0.02 && x >= -0.038 && x < -0.005 ? annobon : continent).invert(coordinates)
          }

          mercatorEquatorialGuinea.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex$10([continent.stream(cacheStream = stream), bioko.stream(stream), annobon.stream(stream)])
          }

          mercatorEquatorialGuinea.precision = function (_) {
            if (!arguments.length) {
              return continent.precision()
            }
            continent.precision(_)
            bioko.precision(_)
            annobon.precision(_)
            return reset()
          }

          mercatorEquatorialGuinea.scale = function (_) {
            if (!arguments.length) {
              return continent.scale()
            }
            continent.scale(_)
            bioko.scale(_ * 1.5)
            annobon.scale(_ * 4)
            return mercatorEquatorialGuinea.translate(continent.translate())
          }

          mercatorEquatorialGuinea.translate = function (_) {
            if (!arguments.length) {
              return continent.translate()
            }
            var k = continent.scale(),
              x = +_[0],
              y = +_[1]
            continentPoint = continent.translate(_).clipExtent([
              [x - 0.005 * k, y - 0.02 * k],
              [x + 0.038 * k, y + 0.02 * k]
            ]).stream(pointStream)

            biokoPoint = bioko.translate([x - 0.025 * k, y - 0.01 * k]).clipExtent([
              [x - 0.038 * k + epsilon, y - 0.02 * k + epsilon],
              [x - 0.005 * k - epsilon, y + 0 * k - epsilon]
            ]).stream(pointStream)

            annobonPoint = annobon.translate([x - 0.025 * k, y + 0.01 * k]).clipExtent([
              [x - 0.038 * k + epsilon, y - 0 * k + epsilon],
              [x - 0.005 * k - epsilon, y + 0.02 * k - epsilon]
            ]).stream(pointStream)

            return reset()
          }

          mercatorEquatorialGuinea.fitExtent = function (extent, object) {
            return fitExtent(mercatorEquatorialGuinea, extent, object)
          }

          mercatorEquatorialGuinea.fitSize = function (size, object) {
            return fitSize(mercatorEquatorialGuinea, size, object)
          }

          function reset() {
            cache = cacheStream = null
            return mercatorEquatorialGuinea
          }

          mercatorEquatorialGuinea.drawCompositionBorders = function (context) {
            /*
        console.log("var ul, ur, ld, ll;");
        var projs = [continent, bioko, annobon];
        for (var i in projs){
          var ul = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);
          var ur = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);
          var ld = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);
          var ll = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);
           console.log("ul = continent(["+ul+"]);");
          console.log("ur = continent(["+ur+"]);");
          console.log("ld = continent(["+ld+"]);");
          console.log("ll = continent(["+ll+"]);");
           console.log("context.moveTo(ul[0], ul[1]);");
          console.log("context.lineTo(ur[0], ur[1]);");
          console.log("context.lineTo(ld[0], ld[1]);");
          console.log("context.lineTo(ll[0], ll[1]);");
          console.log("context.closePath();");
         } */

            var ul, ur, ld, ll
            ul = continent([9.21327272751682, 2.645820439454123])
            ur = continent([11.679126293239872, 2.644755519268689])
            ld = continent([11.676845389029227, 0.35307824637606433])
            ll = continent([9.213572917774014, 0.35414205204417754])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = continent([7.320873711543669, 2.64475551449975])
            ur = continent([9.213272722738658, 2.645820434679803])
            ld = continent([9.213422896480349, 1.4999812505283054])
            ll = continent([7.322014760520787, 1.4989168878985566])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
            ul = continent([7.3220147605302905, 1.4989168783492766])
            ur = continent([9.213422896481598, 1.499981240979021])
            ld = continent([9.213572912999604, 0.354142056817247])
            ll = continent([7.323154615739809, 0.353078251154504])
            context.moveTo(ul[0], ul[1])
            context.lineTo(ur[0], ur[1])
            context.lineTo(ld[0], ld[1])
            context.lineTo(ll[0], ll[1])
            context.closePath()
          }
          mercatorEquatorialGuinea.getCompositionBorders = function () {
            var context = d3Path.path()
            this.drawCompositionBorders(context)
            return context.toString()
          }

          return mercatorEquatorialGuinea.scale(12000)
        }

        exports.geoAlbersUsa = albersUsa
        exports.geoAlbersUsaTerritories = albersUsaTerritories
        exports.geoConicConformalSpain = conicConformalSpain
        exports.geoConicConformalPortugal = conicConformalPortugal
        exports.geoMercatorEcuador = mercatorEcuador
        exports.geoTransverseMercatorChile = transverseMercatorChile
        exports.geoConicEquidistantJapan = conicEquidistantJapan
        exports.geoConicConformalFrance = conicConformalFrance
        exports.geoConicConformalEurope = conicConformalEurope
        exports.geoMercatorMalaysia = mercatorMalaysia
        exports.geoMercatorEquatorialGuinea = mercatorEquatorialGuinea

        Object.defineProperty(exports, '__esModule', {
          value: true
        })
      })
      /***/
    },
    /* 495 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (feature) {
        var i, n, a, b, merged, deltaMax, delta

        phi1 = lambda1 = -(lambda0 = phi0 = Infinity)
        ranges = [];
        (0, _stream2.default)(feature, boundsStream)

        // First, sort ranges by their minimum longitudes.
        if (n = ranges.length) {
          ranges.sort(rangeCompare)

          // Then, merge any ranges that overlap.
          for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
            b = ranges[i]
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
              if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1]
              if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0]
            } else {
              merged.push(a = b)
            }
          }

          // Finally, find the largest gap between the merged ranges.
          // The final bounding box will be the inverse of this gap.
          for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
            b = merged[i]
            if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1]
          }
        }

        ranges = range = null

        return lambda0 === Infinity || phi0 === Infinity ? [
          [NaN, NaN],
          [NaN, NaN]
        ] : [
          [lambda0, phi0],
          [lambda1, phi1]
        ]
      }

      var _adder = __webpack_require__(45)

      var _adder2 = _interopRequireDefault(_adder)

      var _area = __webpack_require__(205)

      var _cartesian = __webpack_require__(46)

      var _math = __webpack_require__(4)

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var lambda0,
        phi0,
        lambda1,
        phi1,
        // bounds
        lambda2,
        // previous lambda-coordinate
        lambda00,
        phi00,
        // first point
        p0,
        // previous 3D point
        deltaSum = (0, _adder2.default)(),
        ranges,
        range

      var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function polygonStart() {
          boundsStream.point = boundsRingPoint
          boundsStream.lineStart = boundsRingStart
          boundsStream.lineEnd = boundsRingEnd
          deltaSum.reset()
          _area.areaStream.polygonStart()
        },
        polygonEnd: function polygonEnd() {
          _area.areaStream.polygonEnd()
          boundsStream.point = boundsPoint
          boundsStream.lineStart = boundsLineStart
          boundsStream.lineEnd = boundsLineEnd
          if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          else if (deltaSum > _math.epsilon) phi1 = 90;
          else if (deltaSum < -_math.epsilon) phi0 = -90
          range[0] = lambda0, range[1] = lambda1
        }
      }

      function boundsPoint(lambda, phi) {
        ranges.push(range = [lambda0 = lambda, lambda1 = lambda])
        if (phi < phi0) phi0 = phi
        if (phi > phi1) phi1 = phi
      }

      function linePoint(lambda, phi) {
        var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians])
        if (p0) {
          var normal = (0, _cartesian.cartesianCross)(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = (0, _cartesian.cartesianCross)(equatorial, normal);
          (0, _cartesian.cartesianNormalizeInPlace)(inflection)
          inflection = (0, _cartesian.spherical)(inflection)
          var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * _math.degrees * sign,
            phii,
            antimeridian = (0, _math.abs)(delta) > 180
          if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = inflection[1] * _math.degrees
            if (phii > phi1) phi1 = phii
          } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
            phii = -inflection[1] * _math.degrees
            if (phii < phi0) phi0 = phii
          } else {
            if (phi < phi0) phi0 = phi
            if (phi > phi1) phi1 = phi
          }
          if (antimeridian) {
            if (lambda < lambda2) {
              if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda
            } else {
              if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda
            }
          } else {
            if (lambda1 >= lambda0) {
              if (lambda < lambda0) lambda0 = lambda
              if (lambda > lambda1) lambda1 = lambda
            } else {
              if (lambda > lambda2) {
                if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda
              } else {
                if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda
              }
            }
          }
        } else {
          boundsPoint(lambda, phi)
        }
        p0 = p, lambda2 = lambda
      }

      function boundsLineStart() {
        boundsStream.point = linePoint
      }

      function boundsLineEnd() {
        range[0] = lambda0, range[1] = lambda1
        boundsStream.point = boundsPoint
        p0 = null
      }

      function boundsRingPoint(lambda, phi) {
        if (p0) {
          var delta = lambda - lambda2
          deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta)
        } else {
          lambda00 = lambda, phi00 = phi
        }
        _area.areaStream.point(lambda, phi)
        linePoint(lambda, phi)
      }

      function boundsRingStart() {
        _area.areaStream.lineStart()
      }

      function boundsRingEnd() {
        boundsRingPoint(lambda00, phi00)
        _area.areaStream.lineEnd()
        if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180)
        range[0] = lambda0, range[1] = lambda1
        p0 = null
      }

      // Finds the left-right distance between two longitudes.
      // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
      // the distance between 180 to be 360.
      function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1
      }

      function rangeCompare(a, b) {
        return a[0] - b[0]
      }

      function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x
      }
      /***/
    },
    /* 496 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (object) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
        (0, _stream2.default)(object, centroidStream)

        var x = X2,
          y = Y2,
          z = Z2,
          m = x * x + y * y + z * z

        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
        if (m < _math.epsilon2) {
          x = X1, y = Y1, z = Z1
          // If the feature has zero length, fall back to arithmetic mean of point vectors.
          if (W1 < _math.epsilon) x = X0, y = Y0, z = Z0
          m = x * x + y * y + z * z
          // If the feature still has an undefined ccentroid, then return.
          if (m < _math.epsilon2) return [NaN, NaN]
        }

        return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.asin)(z / (0, _math.sqrt)(m)) * _math.degrees]
      }

      var _math = __webpack_require__(4)

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
        x0, y0, z0 // previous point

      var centroidStream = {
        sphere: _noop2.default,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function polygonStart() {
          centroidStream.lineStart = centroidRingStart
          centroidStream.lineEnd = centroidRingEnd
        },
        polygonEnd: function polygonEnd() {
          centroidStream.lineStart = centroidLineStart
          centroidStream.lineEnd = centroidLineEnd
        }
      }

      // Arithmetic mean of Cartesian vectors.
      function centroidPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi)
        centroidPointCartesian(cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi))
      }

      function centroidPointCartesian(x, y, z) {
        ++W0
        X0 += (x - X0) / W0
        Y0 += (y - Y0) / W0
        Z0 += (z - Z0) / W0
      }

      function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst
      }

      function centroidLinePointFirst(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi)
        x0 = cosPhi * (0, _math.cos)(lambda)
        y0 = cosPhi * (0, _math.sin)(lambda)
        z0 = (0, _math.sin)(phi)
        centroidStream.point = centroidLinePoint
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidLinePoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi),
          x = cosPhi * (0, _math.cos)(lambda),
          y = cosPhi * (0, _math.sin)(lambda),
          z = (0, _math.sin)(phi),
          w = (0, _math.atan2)((0, _math.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z)
        W1 += w
        X1 += w * (x0 + (x0 = x))
        Y1 += w * (y0 + (y0 = y))
        Z1 += w * (z0 + (z0 = z))
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidLineEnd() {
        centroidStream.point = centroidPoint
      }

      // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
      // J. Applied Mechanics 42, 239 (1975).
      function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst
      }

      function centroidRingEnd() {
        centroidRingPoint(lambda00, phi00)
        centroidStream.point = centroidPoint
      }

      function centroidRingPointFirst(lambda, phi) {
        lambda00 = lambda, phi00 = phi
        lambda *= _math.radians, phi *= _math.radians
        centroidStream.point = centroidRingPoint
        var cosPhi = (0, _math.cos)(phi)
        x0 = cosPhi * (0, _math.cos)(lambda)
        y0 = cosPhi * (0, _math.sin)(lambda)
        z0 = (0, _math.sin)(phi)
        centroidPointCartesian(x0, y0, z0)
      }

      function centroidRingPoint(lambda, phi) {
        lambda *= _math.radians, phi *= _math.radians
        var cosPhi = (0, _math.cos)(phi),
          x = cosPhi * (0, _math.cos)(lambda),
          y = cosPhi * (0, _math.sin)(lambda),
          z = (0, _math.sin)(phi),
          cx = y0 * z - z0 * y,
          cy = z0 * x - x0 * z,
          cz = x0 * y - y0 * x,
          m = (0, _math.sqrt)(cx * cx + cy * cy + cz * cz),
          u = x0 * x + y0 * y + z0 * z,
          v = m && -(0, _math.acos)(u) / m,
          // area weight
          w = (0, _math.atan2)(m, u) // line weight
        X2 += v * cx
        Y2 += v * cy
        Z2 += v * cz
        W1 += w
        X1 += w * (x0 + (x0 = x))
        Y1 += w * (y0 + (y0 = y))
        Z1 += w * (z0 + (z0 = z))
        centroidPointCartesian(x0, y0, z0)
      }
      /***/
    },
    /* 497 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return function () {
          return x
        }
      }
      /***/
    },
    /* 498 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b, x0, y0, x1, y1) {
        var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r

        r = x0 - ax
        if (!dx && r > 0) return
        r /= dx
        if (dx < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dx > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = x1 - ax
        if (!dx && r < 0) return
        r /= dx
        if (dx < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dx > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        r = y0 - ay
        if (!dy && r > 0) return
        r /= dy
        if (dy < 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        } else if (dy > 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        }

        r = y1 - ay
        if (!dy && r < 0) return
        r /= dy
        if (dy < 0) {
          if (r > t1) return
          if (r > t0) t0 = r
        } else if (dy > 0) {
          if (r < t0) return
          if (r < t1) t1 = r
        }

        if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy
        if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy
        return true
      }
      /***/
    },
    /* 499 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        coordinates[0] = a
        coordinates[1] = b
        return (0, _length2.default)(object)
      }

      var _length = __webpack_require__(212)

      var _length2 = _interopRequireDefault(_length)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var coordinates = [null, null],
        object = {
          type: 'LineString',
          coordinates: coordinates
        }
      /***/
    },
    /* 500 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var x1,
          x0,
          X1,
          X0,
          y1,
          y0,
          Y1,
          Y0,
          dx = 10,
          dy = dx,
          DX = 90,
          DY = 360,
          x,
          y,
          X,
          Y,
          precision = 2.5

        function graticule() {
          return {
            type: 'MultiLineString',
            coordinates: lines()
          }
        }

        function lines() {
          return (0, _d3Array.range)((0, _math.ceil)(X0 / DX) * DX, X1, DX).map(X).concat((0, _d3Array.range)((0, _math.ceil)(Y0 / DY) * DY, Y1, DY).map(Y)).concat((0, _d3Array.range)((0, _math.ceil)(x0 / dx) * dx, x1, dx).filter(function (x) {
            return (0, _math.abs)(x % DX) > _math.epsilon
          }).map(x)).concat((0, _d3Array.range)((0, _math.ceil)(y0 / dy) * dy, y1, dy).filter(function (y) {
            return (0, _math.abs)(y % DY) > _math.epsilon
          }).map(y))
        }

        graticule.lines = function () {
          return lines().map(function (coordinates) {
            return {
              type: 'LineString',
              coordinates: coordinates
            }
          })
        }

        graticule.outline = function () {
          return {
            type: 'Polygon',
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          }
        }

        graticule.extent = function (_) {
          if (!arguments.length) return graticule.extentMinor()
          return graticule.extentMajor(_).extentMinor(_)
        }

        graticule.extentMajor = function (_) {
          if (!arguments.length) return [
            [X0, Y0],
            [X1, Y1]
          ]
          X0 = +_[0][0], X1 = +_[1][0]
          Y0 = +_[0][1], Y1 = +_[1][1]
          if (X0 > X1) _ = X0, X0 = X1, X1 = _
          if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _
          return graticule.precision(precision)
        }

        graticule.extentMinor = function (_) {
          if (!arguments.length) return [
            [x0, y0],
            [x1, y1]
          ]
          x0 = +_[0][0], x1 = +_[1][0]
          y0 = +_[0][1], y1 = +_[1][1]
          if (x0 > x1) _ = x0, x0 = x1, x1 = _
          if (y0 > y1) _ = y0, y0 = y1, y1 = _
          return graticule.precision(precision)
        }

        graticule.step = function (_) {
          if (!arguments.length) return graticule.stepMinor()
          return graticule.stepMajor(_).stepMinor(_)
        }

        graticule.stepMajor = function (_) {
          if (!arguments.length) return [DX, DY]
          DX = +_[0], DY = +_[1]
          return graticule
        }

        graticule.stepMinor = function (_) {
          if (!arguments.length) return [dx, dy]
          dx = +_[0], dy = +_[1]
          return graticule
        }

        graticule.precision = function (_) {
          if (!arguments.length) return precision
          precision = +_
          x = graticuleX(y0, y1, 90)
          y = graticuleY(x0, x1, precision)
          X = graticuleX(Y0, Y1, 90)
          Y = graticuleY(X0, X1, precision)
          return graticule
        }

        return graticule.extentMajor([
          [-180, -90 + _math.epsilon],
          [180, 90 - _math.epsilon]
        ]).extentMinor([
          [-180, -80 - _math.epsilon],
          [180, 80 + _math.epsilon]
        ])
      }

      var _d3Array = __webpack_require__(14)

      var _math = __webpack_require__(4)

      function graticuleX(y0, y1, dy) {
        var y = (0, _d3Array.range)(y0, y1 - _math.epsilon, dy).concat(y1)
        return function (x) {
          return y.map(function (y) {
            return [x, y]
          })
        }
      }

      function graticuleY(x0, x1, dx) {
        var x = (0, _d3Array.range)(x0, x1 - _math.epsilon, dx).concat(x1)
        return function (y) {
          return x.map(function (x) {
            return [x, y]
          })
        }
      }
      /***/
    },
    /* 501 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (a, b) {
        var x0 = a[0] * _math.radians,
          y0 = a[1] * _math.radians,
          x1 = b[0] * _math.radians,
          y1 = b[1] * _math.radians,
          cy0 = (0, _math.cos)(y0),
          sy0 = (0, _math.sin)(y0),
          cy1 = (0, _math.cos)(y1),
          sy1 = (0, _math.sin)(y1),
          kx0 = cy0 * (0, _math.cos)(x0),
          ky0 = cy0 * (0, _math.sin)(x0),
          kx1 = cy1 * (0, _math.cos)(x1),
          ky1 = cy1 * (0, _math.sin)(x1),
          d = 2 * (0, _math.asin)((0, _math.sqrt)((0, _math.haversin)(y1 - y0) + cy0 * cy1 * (0, _math.haversin)(x1 - x0))),
          k = (0, _math.sin)(d)

        var interpolate = d ? function (t) {
          var B = (0, _math.sin)(t *= d) / k,
            A = (0, _math.sin)(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1
          return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.atan2)(z, (0, _math.sqrt)(x * x + y * y)) * _math.degrees]
        } : function () {
          return [x0 * _math.degrees, y0 * _math.degrees]
        }

        interpolate.distance = d

        return interpolate
      }

      var _math = __webpack_require__(4)
      /***/
    },
    /* 502 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var pointRadius = 4.5,
          projection,
          projectionStream,
          context,
          contextStream

        function path(object) {
          if (object) {
            if (typeof pointRadius === 'function') contextStream.pointRadius(+pointRadius.apply(this, arguments));
            (0, _stream2.default)(object, projectionStream(contextStream))
          }
          return contextStream.result()
        }

        path.area = function (object) {
          (0, _stream2.default)(object, projectionStream(_area2.default))
          return _area2.default.result()
        }

        path.bounds = function (object) {
          (0, _stream2.default)(object, projectionStream(_bounds2.default))
          return _bounds2.default.result()
        }

        path.centroid = function (object) {
          (0, _stream2.default)(object, projectionStream(_centroid2.default))
          return _centroid2.default.result()
        }

        path.projection = function (_) {
          return arguments.length ? (projectionStream = (projection = _) == null ? _identity2.default : _.stream, path) : projection
        }

        path.context = function (_) {
          if (!arguments.length) return context
          contextStream = (context = _) == null ? new _string2.default() : new _context2.default(_)
          if (typeof pointRadius !== 'function') contextStream.pointRadius(pointRadius)
          return path
        }

        path.pointRadius = function (_) {
          if (!arguments.length) return pointRadius
          pointRadius = typeof _ === 'function' ? _ : (contextStream.pointRadius(+_), +_)
          return path
        }

        return path.projection(null).context(null)
      }

      var _identity = __webpack_require__(213)

      var _identity2 = _interopRequireDefault(_identity)

      var _stream = __webpack_require__(28)

      var _stream2 = _interopRequireDefault(_stream)

      var _area = __webpack_require__(503)

      var _area2 = _interopRequireDefault(_area)

      var _bounds = __webpack_require__(214)

      var _bounds2 = _interopRequireDefault(_bounds)

      var _centroid = __webpack_require__(504)

      var _centroid2 = _interopRequireDefault(_centroid)

      var _context = __webpack_require__(505)

      var _context2 = _interopRequireDefault(_context)

      var _string = __webpack_require__(506)

      var _string2 = _interopRequireDefault(_string)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 503 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _adder = __webpack_require__(45)

      var _adder2 = _interopRequireDefault(_adder)

      var _math = __webpack_require__(4)

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var areaSum = (0, _adder2.default)(),
        areaRingSum = (0, _adder2.default)(),
        x00,
        y00,
        x0,
        y0

      var areaStream = {
        point: _noop2.default,
        lineStart: _noop2.default,
        lineEnd: _noop2.default,
        polygonStart: function polygonStart() {
          areaStream.lineStart = areaRingStart
          areaStream.lineEnd = areaRingEnd
        },
        polygonEnd: function polygonEnd() {
          areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop2.default
          areaSum.add((0, _math.abs)(areaRingSum))
          areaRingSum.reset()
        },
        result: function result() {
          var area = areaSum / 2
          areaSum.reset()
          return area
        }
      }

      function areaRingStart() {
        areaStream.point = areaPointFirst
      }

      function areaPointFirst(x, y) {
        areaStream.point = areaPoint
        x00 = x0 = x, y00 = y0 = y
      }

      function areaPoint(x, y) {
        areaRingSum.add(y0 * x - x0 * y)
        x0 = x, y0 = y
      }

      function areaRingEnd() {
        areaPoint(x00, y00)
      }

      exports.default = areaStream
      /***/
    },
    /* 504 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _math = __webpack_require__(4)

      // TODO Enforce positive area for exterior, negative area for interior?

      var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00,
        y00,
        x0,
        y0

      var centroidStream = {
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function polygonStart() {
          centroidStream.lineStart = centroidRingStart
          centroidStream.lineEnd = centroidRingEnd
        },
        polygonEnd: function polygonEnd() {
          centroidStream.point = centroidPoint
          centroidStream.lineStart = centroidLineStart
          centroidStream.lineEnd = centroidLineEnd
        },
        result: function result() {
          var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN]
          X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0
          return centroid
        }
      }

      function centroidPoint(x, y) {
        X0 += x
        Y0 += y
          ++Z0
      }

      function centroidLineStart() {
        centroidStream.point = centroidPointFirstLine
      }

      function centroidPointFirstLine(x, y) {
        centroidStream.point = centroidPointLine
        centroidPoint(x0 = x, y0 = y)
      }

      function centroidPointLine(x, y) {
        var dx = x - x0,
          dy = y - y0,
          z = (0, _math.sqrt)(dx * dx + dy * dy)
        X1 += z * (x0 + x) / 2
        Y1 += z * (y0 + y) / 2
        Z1 += z
        centroidPoint(x0 = x, y0 = y)
      }

      function centroidLineEnd() {
        centroidStream.point = centroidPoint
      }

      function centroidRingStart() {
        centroidStream.point = centroidPointFirstRing
      }

      function centroidRingEnd() {
        centroidPointRing(x00, y00)
      }

      function centroidPointFirstRing(x, y) {
        centroidStream.point = centroidPointRing
        centroidPoint(x00 = x0 = x, y00 = y0 = y)
      }

      function centroidPointRing(x, y) {
        var dx = x - x0,
          dy = y - y0,
          z = (0, _math.sqrt)(dx * dx + dy * dy)

        X1 += z * (x0 + x) / 2
        Y1 += z * (y0 + y) / 2
        Z1 += z

        z = y0 * x - x0 * y
        X2 += z * (x0 + x)
        Y2 += z * (y0 + y)
        Z2 += z * 3
        centroidPoint(x0 = x, y0 = y)
      }

      exports.default = centroidStream
      /***/
    },
    /* 505 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.default = PathContext

      var _math = __webpack_require__(4)

      var _noop = __webpack_require__(27)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function PathContext(context) {
        this._context = context
      }

      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function pointRadius(_) {
          return this._radius = _, this
        },
        polygonStart: function polygonStart() {
          this._line = 0
        },
        polygonEnd: function polygonEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line === 0) this._context.closePath()
          this._point = NaN
        },
        point: function point(x, y) {
          switch (this._point) {
            case 0:
              {
                this._context.moveTo(x, y)
                this._point = 1
                break
              }
            case 1:
              {
                this._context.lineTo(x, y)
                break
              }
            default:
              {
                this._context.moveTo(x + this._radius, y)
                this._context.arc(x, y, this._radius, 0, _math.tau)
                break
              }
          }
        },
        result: _noop2.default
      }
      /***/
    },
    /* 506 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = PathString

      function PathString() {
        this._string = []
      }

      PathString.prototype = {
        _circle: circle(4.5),
        pointRadius: function pointRadius(_) {
          return this._circle = circle(_), this
        },
        polygonStart: function polygonStart() {
          this._line = 0
        },
        polygonEnd: function polygonEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line === 0) this._string.push('Z')
          this._point = NaN
        },
        point: function point(x, y) {
          switch (this._point) {
            case 0:
              {
                this._string.push('M', x, ',', y)
                this._point = 1
                break
              }
            case 1:
              {
                this._string.push('L', x, ',', y)
                break
              }
            default:
              {
                this._string.push('M', x, ',', y, this._circle)
                break
              }
          }
        },
        result: function result() {
          if (this._string.length) {
            var result = this._string.join('')
            this._string = []
            return result
          }
        }
      }

      function circle(radius) {
        return 'm0,' + radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + -2 * radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + 2 * radius + 'z'
      }
      /***/
    },
    /* 507 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _index = __webpack_require__(216)

      var _index2 = _interopRequireDefault(_index)

      var _math = __webpack_require__(4)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      exports.default = (0, _index2.default)(function () {
        return true
      }, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math.pi, -_math.halfPi])

      // Takes a line and cuts into visible segments. Return values: 0 - there were
      // intersections or the line was empty; 1 - no intersections; 2 - there were
      // intersections, and the first and last segments should be rejoined.

      function clipAntimeridianLine(stream) {
        var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          _clean // no intersections

        return {
          lineStart: function lineStart() {
            stream.lineStart()
            _clean = 1
          },
          point: function point(lambda1, phi1) {
            var sign1 = lambda1 > 0 ? _math.pi : -_math.pi,
              delta = (0, _math.abs)(lambda1 - lambda0)
            if ((0, _math.abs)(delta - _math.pi) < _math.epsilon) {
              // line crosses a pole
              stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math.halfPi : -_math.halfPi)
              stream.point(sign0, phi0)
              stream.lineEnd()
              stream.lineStart()
              stream.point(sign1, phi0)
              stream.point(lambda1, phi0)
              _clean = 0
            } else if (sign0 !== sign1 && delta >= _math.pi) {
              // line crosses antimeridian
              if ((0, _math.abs)(lambda0 - sign0) < _math.epsilon) lambda0 -= sign0 * _math.epsilon // handle degeneracies
              if ((0, _math.abs)(lambda1 - sign1) < _math.epsilon) lambda1 -= sign1 * _math.epsilon
              phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1)
              stream.point(sign0, phi0)
              stream.lineEnd()
              stream.lineStart()
              stream.point(sign1, phi0)
              _clean = 0
            }
            stream.point(lambda0 = lambda1, phi0 = phi1)
            sign0 = sign1
          },
          lineEnd: function lineEnd() {
            stream.lineEnd()
            lambda0 = phi0 = NaN
          },
          clean: function clean() {
            return 2 - _clean // if intersections, rejoin first and last segments
          }
        }
      }

      function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = (0, _math.sin)(lambda0 - lambda1)
        return (0, _math.abs)(sinLambda0Lambda1) > _math.epsilon ? (0, _math.atan)(((0, _math.sin)(phi0) * (cosPhi1 = (0, _math.cos)(phi1)) * (0, _math.sin)(lambda1) - (0, _math.sin)(phi1) * (cosPhi0 = (0, _math.cos)(phi0)) * (0, _math.sin)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2
      }

      function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi
        if (from == null) {
          phi = direction * _math.halfPi
          stream.point(-_math.pi, phi)
          stream.point(0, phi)
          stream.point(_math.pi, phi)
          stream.point(_math.pi, 0)
          stream.point(_math.pi, -phi)
          stream.point(0, -phi)
          stream.point(-_math.pi, -phi)
          stream.point(-_math.pi, 0)
          stream.point(-_math.pi, phi)
        } else if ((0, _math.abs)(from[0] - to[0]) > _math.epsilon) {
          var lambda = from[0] < to[0] ? _math.pi : -_math.pi
          phi = direction * lambda / 2
          stream.point(-lambda, phi)
          stream.point(0, phi)
          stream.point(lambda, phi)
        } else {
          stream.point(to[0], to[1])
        }
      }
      /***/
    },
    /* 508 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (polygon, point) {
        var lambda = point[0],
          phi = point[1],
          normal = [(0, _math.sin)(lambda), -(0, _math.cos)(lambda), 0],
          angle = 0,
          winding = 0

        sum.reset()

        for (var i = 0, n = polygon.length; i < n; ++i) {
          if (!(m = (ring = polygon[i]).length)) continue
          var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = point0[0],
            phi0 = point0[1] / 2 + _math.quarterPi,
            sinPhi0 = (0, _math.sin)(phi0),
            cosPhi0 = (0, _math.cos)(phi0)

          for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
            var point1 = ring[j],
              lambda1 = point1[0],
              phi1 = point1[1] / 2 + _math.quarterPi,
              sinPhi1 = (0, _math.sin)(phi1),
              cosPhi1 = (0, _math.cos)(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > _math.pi,
              k = sinPhi0 * sinPhi1

            sum.add((0, _math.atan2)(k * sign * (0, _math.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0, _math.cos)(absDelta)))
            angle += antimeridian ? delta + sign * _math.tau : delta

            // Are the longitudes either side of the points meridian (lambda),
            // and are the latitudes smaller than the parallel (phi)?
            if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
              var arc = (0, _cartesian.cartesianCross)((0, _cartesian.cartesian)(point0), (0, _cartesian.cartesian)(point1));
              (0, _cartesian.cartesianNormalizeInPlace)(arc)
              var intersection = (0, _cartesian.cartesianCross)(normal, arc);
              (0, _cartesian.cartesianNormalizeInPlace)(intersection)
              var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0, _math.asin)(intersection[2])
              if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                winding += antimeridian ^ delta >= 0 ? 1 : -1
              }
            }
          }
        }

        // First, determine whether the South pole is inside or outside:
        //
        // It is inside if:
        // * the polygon winds around it in a clockwise direction.
        // * the polygon does not (cumulatively) wind around it, but has a negative
        //   (counter-clockwise) area.
        //
        // Second, count the (signed) number of times a segment crosses a lambda
        // from the point to the South pole.  If it is zero, then the point is the
        // same side as the South pole.

        return (angle < -_math.epsilon || angle < _math.epsilon && sum < -_math.epsilon) ^ winding & 1
      }

      var _adder = __webpack_require__(45)

      var _adder2 = _interopRequireDefault(_adder)

      var _cartesian = __webpack_require__(46)

      var _math = __webpack_require__(4)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var sum = (0, _adder2.default)()
      /***/
    },
    /* 509 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (radius, delta) {
        var cr = (0, _math.cos)(radius),
          smallRadius = cr > 0,
          notHemisphere = (0, _math.abs)(cr) > _math.epsilon // TODO optimise for this common case

        function interpolate(from, to, direction, stream) {
          (0, _circle.circleStream)(stream, radius, delta, direction, from, to)
        }

        function visible(lambda, phi) {
          return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr
        }

        // Takes a line and cuts into visible segments. Return values used for polygon
        // clipping: 0 - there were intersections or the line was empty; 1 - no
        // intersections 2 - there were intersections, and the first and last segments
        // should be rejoined.
        function clipLine(stream) {
          var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            _clean // no intersections
          return {
            lineStart: function lineStart() {
              v00 = v0 = false
              _clean = 1
            },
            point: function point(lambda, phi) {
              var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0
              if (!point0 && (v00 = v0 = v)) stream.lineStart()
              // Handle degeneracies.
              // TODO ignore if not clipping polygons.
              if (v !== v0) {
                point2 = intersect(point0, point1)
                if ((0, _pointEqual2.default)(point0, point2) || (0, _pointEqual2.default)(point1, point2)) {
                  point1[0] += _math.epsilon
                  point1[1] += _math.epsilon
                  v = visible(point1[0], point1[1])
                }
              }
              if (v !== v0) {
                _clean = 0
                if (v) {
                  // outside going in
                  stream.lineStart()
                  point2 = intersect(point1, point0)
                  stream.point(point2[0], point2[1])
                } else {
                  // inside going out
                  point2 = intersect(point0, point1)
                  stream.point(point2[0], point2[1])
                  stream.lineEnd()
                }
                point0 = point2
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t
                // If the codes for two points are different, or are both zero,
                // and there this segment intersects with the small circle.
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  _clean = 0
                  if (smallRadius) {
                    stream.lineStart()
                    stream.point(t[0][0], t[0][1])
                    stream.point(t[1][0], t[1][1])
                    stream.lineEnd()
                  } else {
                    stream.point(t[1][0], t[1][1])
                    stream.lineEnd()
                    stream.lineStart()
                    stream.point(t[0][0], t[0][1])
                  }
                }
              }
              if (v && (!point0 || !(0, _pointEqual2.default)(point0, point1))) {
                stream.point(point1[0], point1[1])
              }
              point0 = point1, v0 = v, c0 = c
            },
            lineEnd: function lineEnd() {
              if (v0) stream.lineEnd()
              point0 = null
            },
            // Rejoin first and last segments if there were intersections and the first
            // and last points were visible.
            clean: function clean() {
              return _clean | (v00 && v0) << 1
            }
          }
        }

        // Intersects the great circle between a and b with the clip circle.
        function intersect(a, b, two) {
          var pa = (0, _cartesian.cartesian)(a),
            pb = (0, _cartesian.cartesian)(b)

          // We have two planes, n1.p = d1 and n2.p = d2.
          // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
          var n1 = [1, 0, 0],
            // normal
            n2 = (0, _cartesian.cartesianCross)(pa, pb),
            n2n2 = (0, _cartesian.cartesianDot)(n2, n2),
            n1n2 = n2[0],
            // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2

          // Two polar points.
          if (!determinant) return !two && a

          var c1 = cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),
            A = (0, _cartesian.cartesianScale)(n1, c1),
            B = (0, _cartesian.cartesianScale)(n2, c2);
          (0, _cartesian.cartesianAddInPlace)(A, B)

          // Solve |p(t)|^2 = 1.
          var u = n1xn2,
            w = (0, _cartesian.cartesianDot)(A, u),
            uu = (0, _cartesian.cartesianDot)(u, u),
            t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1)

          if (t2 < 0) return

          var t = (0, _math.sqrt)(t2),
            q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);
          (0, _cartesian.cartesianAddInPlace)(q, A)
          q = (0, _cartesian.spherical)(q)

          if (!two) return q

          // Two intersection points.
          var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z

          if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z

          var delta = lambda1 - lambda0,
            polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,
            meridian = polar || delta < _math.epsilon

          if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z

          // Check that the first point is between a and b.
          if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
            var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);
            (0, _cartesian.cartesianAddInPlace)(q1, A)
            return [q, (0, _cartesian.spherical)(q1)]
          }
        }

        // Generates a 4-bit vector representing the location of a point relative to
        // the small circle's bounding box.
        function code(lambda, phi) {
          var r = smallRadius ? radius : _math.pi - radius,
            code = 0
          if (lambda < -r) code |= 1 // left
          else if (lambda > r) code |= 2 // right
          if (phi < -r) code |= 4 // below
          else if (phi > r) code |= 8 // above
          return code
        }

        return (0, _index2.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi])
      }

      var _cartesian = __webpack_require__(46)

      var _circle = __webpack_require__(206)

      var _math = __webpack_require__(4)

      var _pointEqual = __webpack_require__(211)

      var _pointEqual2 = _interopRequireDefault(_pointEqual)

      var _index = __webpack_require__(216)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 510 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (project, delta2) {
        return +delta2 ? resample(project, delta2) : resampleNone(project)
      }

      var _cartesian = __webpack_require__(46)

      var _math = __webpack_require__(4)

      var _transform = __webpack_require__(111)

      var maxDepth = 16,
        // maximum depth of subdivision
        cosMinDistance = (0, _math.cos)(30 * _math.radians) // cos(minimum angular distance)

      function resampleNone(project) {
        return (0, _transform.transform)({
          point: function point(x, y) {
            x = project(x, y)
            this.stream.point(x[0], x[1])
          }
        })
      }

      function resample(project, delta2) {
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy
          if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = (0, _math.sqrt)(a * a + b * b + c * c),
              phi2 = (0, _math.asin)(c /= m),
              lambda2 = (0, _math.abs)((0, _math.abs)(c) - 1) < _math.epsilon || (0, _math.abs)(lambda0 - lambda1) < _math.epsilon ? (lambda0 + lambda1) / 2 : (0, _math.atan2)(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2
            if (dz * dz / d2 > delta2 || // perpendicular projected distance
              (0, _math.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || // midpoint close to an end
              a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              // angular distance
              resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream)
              stream.point(x2, y2)
              resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream)
            }
          }
        }
        return function (stream) {
          var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0 // previous point

          var resampleStream = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function polygonStart() {
              stream.polygonStart();
              resampleStream.lineStart = ringStart
            },
            polygonEnd: function polygonEnd() {
              stream.polygonEnd();
              resampleStream.lineStart = lineStart
            }
          }

          function point(x, y) {
            x = project(x, y)
            stream.point(x[0], x[1])
          }

          function lineStart() {
            x0 = NaN
            resampleStream.point = linePoint
            stream.lineStart()
          }

          function linePoint(lambda, phi) {
            var c = (0, _cartesian.cartesian)([lambda, phi]),
              p = project(lambda, phi)
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream)
            stream.point(x0, y0)
          }

          function lineEnd() {
            resampleStream.point = point
            stream.lineEnd()
          }

          function ringStart() {
            lineStart()
            resampleStream.point = ringPoint
            resampleStream.lineEnd = ringEnd
          }

          function ringPoint(lambda, phi) {
            linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0
            resampleStream.point = linePoint
          }

          function ringEnd() {
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream)
            resampleStream.lineEnd = lineEnd
            lineEnd()
          }

          return resampleStream
        }
      }
      /***/
    },
    /* 511 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var cache,
          cacheStream,
          lower48 = (0, _albers2.default)(),
          lower48Point,
          alaska = (0, _conicEqualArea2.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
          alaskaPoint,
          // EPSG:3338
          hawaii = (0, _conicEqualArea2.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
          hawaiiPoint,
          // ESRI:102007
          _point,
          pointStream = {
            point: function point(x, y) {
              _point = [x, y]
            }
          }

        function albersUsa(coordinates) {
          var x = coordinates[0],
            y = coordinates[1]
          return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point)
        }

        albersUsa.invert = function (coordinates) {
          var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k
          return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates)
        }

        albersUsa.stream = function (stream) {
          return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)])
        }

        albersUsa.precision = function (_) {
          if (!arguments.length) return lower48.precision()
          lower48.precision(_), alaska.precision(_), hawaii.precision(_)
          return albersUsa
        }

        albersUsa.scale = function (_) {
          if (!arguments.length) return lower48.scale()
          lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_)
          return albersUsa.translate(lower48.translate())
        }

        albersUsa.translate = function (_) {
          if (!arguments.length) return lower48.translate()
          var k = lower48.scale(),
            x = +_[0],
            y = +_[1]

          lower48Point = lower48.translate(_).clipExtent([
            [x - 0.455 * k, y - 0.238 * k],
            [x + 0.455 * k, y + 0.238 * k]
          ]).stream(pointStream)

          alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([
            [x - 0.425 * k + _math.epsilon, y + 0.120 * k + _math.epsilon],
            [x - 0.214 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]
          ]).stream(pointStream)

          hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([
            [x - 0.214 * k + _math.epsilon, y + 0.166 * k + _math.epsilon],
            [x - 0.115 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]
          ]).stream(pointStream)

          return albersUsa
        }

        albersUsa.fitExtent = (0, _fit.fitExtent)(albersUsa)

        albersUsa.fitSize = (0, _fit.fitSize)(albersUsa)

        return albersUsa.scale(1070)
      }

      var _math = __webpack_require__(4)

      var _albers = __webpack_require__(215)

      var _albers2 = _interopRequireDefault(_albers)

      var _conicEqualArea = __webpack_require__(109)

      var _conicEqualArea2 = _interopRequireDefault(_conicEqualArea)

      var _fit = __webpack_require__(217)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      // The projections must have mutually exclusive clip regions on the sphere,
      // as this will avoid emitting interleaving lines and polygons.
      function multiplex(streams) {
        var n = streams.length
        return {
          point: function point(x, y) {
            var i = -1;
            while (++i < n) {
              streams[i].point(x, y)
            }
          },
          sphere: function sphere() {
            var i = -1;
            while (++i < n) {
              streams[i].sphere()
            }
          },
          lineStart: function lineStart() {
            var i = -1;
            while (++i < n) {
              streams[i].lineStart()
            }
          },
          lineEnd: function lineEnd() {
            var i = -1;
            while (++i < n) {
              streams[i].lineEnd()
            }
          },
          polygonStart: function polygonStart() {
            var i = -1;
            while (++i < n) {
              streams[i].polygonStart()
            }
          },
          polygonEnd: function polygonEnd() {
            var i = -1;
            while (++i < n) {
              streams[i].polygonEnd()
            }
          }
        }
      }

      // A composite projection for the United States, configured by default for
      // 960500. The projection also works quite well at 960600 if you change the
      // scale to 1285 and adjust the translate accordingly. The set of standard
      // parallels for each region comes from USGS, which is published here:
      // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
      /***/
    },
    /* 512 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalEqualAreaRaw = undefined

      exports.default = function () {
        return (0, _index2.default)(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3)
      }

      var _math = __webpack_require__(4)

      var _azimuthal = __webpack_require__(47)

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var azimuthalEqualAreaRaw = exports.azimuthalEqualAreaRaw = (0, _azimuthal.azimuthalRaw)(function (cxcy) {
        return (0, _math.sqrt)(2 / (1 + cxcy))
      })

      azimuthalEqualAreaRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return 2 * (0, _math.asin)(z / 2)
      })
      /***/
    },
    /* 513 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.azimuthalEquidistantRaw = undefined

      exports.default = function () {
        return (0, _index2.default)(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3)
      }

      var _math = __webpack_require__(4)

      var _azimuthal = __webpack_require__(47)

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var azimuthalEquidistantRaw = exports.azimuthalEquidistantRaw = (0, _azimuthal.azimuthalRaw)(function (c) {
        return (c = (0, _math.acos)(c)) && c / (0, _math.sin)(c)
      })

      azimuthalEquidistantRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return z
      })
      /***/
    },
    /* 514 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicConformalRaw = conicConformalRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicConformalRaw).scale(109.5).parallels([30, 30])
      }

      var _math = __webpack_require__(4)

      var _conic = __webpack_require__(110)

      var _mercator = __webpack_require__(112)

      function tany(y) {
        return (0, _math.tan)((_math.halfPi + y) / 2)
      }

      function conicConformalRaw(y0, y1) {
        var cy0 = (0, _math.cos)(y0),
          n = y0 === y1 ? (0, _math.sin)(y0) : (0, _math.log)(cy0 / (0, _math.cos)(y1)) / (0, _math.log)(tany(y1) / tany(y0)),
          f = cy0 * (0, _math.pow)(tany(y0), n) / n

        if (!n) return _mercator.mercatorRaw

        function project(x, y) {
          if (f > 0) {
            if (y < -_math.halfPi + _math.epsilon) y = -_math.halfPi + _math.epsilon
          } else {
            if (y > _math.halfPi - _math.epsilon) y = _math.halfPi - _math.epsilon
          }
          var r = f / (0, _math.pow)(tany(y), n)
          return [r * (0, _math.sin)(n * x), f - r * (0, _math.cos)(n * x)]
        }

        project.invert = function (x, y) {
          var fy = f - y,
            r = (0, _math.sign)(n) * (0, _math.sqrt)(x * x + fy * fy)
          return [(0, _math.atan2)(x, fy) / n, 2 * (0, _math.atan)((0, _math.pow)(f / r, 1 / n)) - _math.halfPi]
        }

        return project
      }
      /***/
    },
    /* 515 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.conicEquidistantRaw = conicEquidistantRaw

      exports.default = function () {
        return (0, _conic.conicProjection)(conicEquidistantRaw).scale(131.154).center([0, 13.9389])
      }

      var _math = __webpack_require__(4)

      var _conic = __webpack_require__(110)

      var _equirectangular = __webpack_require__(218)

      function conicEquidistantRaw(y0, y1) {
        var cy0 = (0, _math.cos)(y0),
          n = y0 === y1 ? (0, _math.sin)(y0) : (cy0 - (0, _math.cos)(y1)) / (y1 - y0),
          g = cy0 / n + y0

        if ((0, _math.abs)(n) < _math.epsilon) return _equirectangular.equirectangularRaw

        function project(x, y) {
          var gy = g - y,
            nx = n * x
          return [gy * (0, _math.sin)(nx), g - gy * (0, _math.cos)(nx)]
        }

        project.invert = function (x, y) {
          var gy = g - y
          return [(0, _math.atan2)(x, gy) / n, g - (0, _math.sign)(n) * (0, _math.sqrt)(x * x + gy * gy)]
        }

        return project
      }
      /***/
    },
    /* 516 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.gnomonicRaw = gnomonicRaw

      exports.default = function () {
        return (0, _index2.default)(gnomonicRaw).scale(144.049).clipAngle(60)
      }

      var _math = __webpack_require__(4)

      var _azimuthal = __webpack_require__(47)

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function gnomonicRaw(x, y) {
        var cy = (0, _math.cos)(y),
          k = (0, _math.cos)(x) * cy
        return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k]
      }

      gnomonicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.atan)
      /***/
    },
    /* 517 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.orthographicRaw = orthographicRaw

      exports.default = function () {
        return (0, _index2.default)(orthographicRaw).scale(249.5).clipAngle(90 + _math.epsilon)
      }

      var _math = __webpack_require__(4)

      var _azimuthal = __webpack_require__(47)

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function orthographicRaw(x, y) {
        return [(0, _math.cos)(y) * (0, _math.sin)(x), (0, _math.sin)(y)]
      }

      orthographicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.asin)
      /***/
    },
    /* 518 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.stereographicRaw = stereographicRaw

      exports.default = function () {
        return (0, _index2.default)(stereographicRaw).scale(250).clipAngle(142)
      }

      var _math = __webpack_require__(4)

      var _azimuthal = __webpack_require__(47)

      var _index = __webpack_require__(17)

      var _index2 = _interopRequireDefault(_index)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function stereographicRaw(x, y) {
        var cy = (0, _math.cos)(y),
          k = 1 + (0, _math.cos)(x) * cy
        return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k]
      }

      stereographicRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
        return 2 * (0, _math.atan)(z)
      })
      /***/
    },
    /* 519 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.transverseMercatorRaw = transverseMercatorRaw

      exports.default = function () {
        var m = (0, _mercator.mercatorProjection)(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate

        m.center = function (_) {
          return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]])
        }

        m.rotate = function (_) {
          return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90])
        }

        return rotate([0, 0, 90]).scale(159.155)
      }

      var _math = __webpack_require__(4)

      var _mercator = __webpack_require__(112)

      function transverseMercatorRaw(lambda, phi) {
        return [(0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2)), -lambda]
      }

      transverseMercatorRaw.invert = function (x, y) {
        return [-y, 2 * (0, _math.atan)((0, _math.exp)(x)) - _math.halfPi]
      }
      /***/
    },
    /* 520 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      var pi = Math.PI,
        tau = 2 * pi,
        epsilon = 1e-6,
        tauEpsilon = tau - epsilon

      function Path() {
        this._x0 = this._y0 = // start of current subpath
          this._x1 = this._y1 = null // end of current subpath
        this._ = ''
      }

      function path() {
        return new Path()
      }

      Path.prototype = path.prototype = {
        constructor: Path,
        moveTo: function moveTo(x, y) {
          this._ += 'M' + (this._x0 = this._x1 = +x) + ',' + (this._y0 = this._y1 = +y)
        },
        closePath: function closePath() {
          if (this._x1 !== null) {
            this._x1 = this._x0, this._y1 = this._y0
            this._ += 'Z'
          }
        },
        lineTo: function lineTo(x, y) {
          this._ += 'L' + (this._x1 = +x) + ',' + (this._y1 = +y)
        },
        quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
          this._ += 'Q' + +x1 + ',' + +y1 + ',' + (this._x1 = +x) + ',' + (this._y1 = +y)
        },
        bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
          this._ += 'C' + +x1 + ',' + +y1 + ',' + +x2 + ',' + +y2 + ',' + (this._x1 = +x) + ',' + (this._y1 = +y)
        },
        arcTo: function arcTo(x1, y1, x2, y2, r) {
          x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r
          var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01

          // Is the radius negative? Error.
          if (r < 0) throw new Error('negative radius: ' + r)

          // Is this path empty? Move to (x1,y1).
          if (this._x1 === null) {
            this._ += 'M' + (this._x1 = x1) + ',' + (this._y1 = y1)
          }

          // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
          else if (!(l01_2 > epsilon)) {}

          // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
          // Equivalently, is (x1,y1) coincident with (x2,y2)?
          // Or, is the radius zero? Line to (x1,y1).
          else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
            this._ += 'L' + (this._x1 = x1) + ',' + (this._y1 = y1)
          }

          // Otherwise, draw an arc!
          else {
            var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21

            // If the start tangent is not coincident with (x0,y0), line to.
            if (Math.abs(t01 - 1) > epsilon) {
              this._ += 'L' + (x1 + t01 * x01) + ',' + (y1 + t01 * y01)
            }

            this._ += 'A' + r + ',' + r + ',0,0,' + +(y01 * x20 > x01 * y20) + ',' + (this._x1 = x1 + t21 * x21) + ',' + (this._y1 = y1 + t21 * y21)
          }
        },
        arc: function arc(x, y, r, a0, a1, ccw) {
          x = +x, y = +y, r = +r
          var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0

          // Is the radius negative? Error.
          if (r < 0) throw new Error('negative radius: ' + r)

          // Is this path empty? Move to (x0,y0).
          if (this._x1 === null) {
            this._ += 'M' + x0 + ',' + y0
          }

          // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
          else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
            this._ += 'L' + x0 + ',' + y0
          }

          // Is this arc empty? Were done.
          if (!r) return

          // Does the angle go the wrong way? Flip the direction.
          if (da < 0) da = da % tau + tau

          // Is this a complete circle? Draw two arcs to complete the circle.
          if (da > tauEpsilon) {
            this._ += 'A' + r + ',' + r + ',0,1,' + cw + ',' + (x - dx) + ',' + (y - dy) + 'A' + r + ',' + r + ',0,1,' + cw + ',' + (this._x1 = x0) + ',' + (this._y1 = y0)
          }

          // Is this arc non-empty? Draw an arc!
          else if (da > epsilon) {
            this._ += 'A' + r + ',' + r + ',0,' + +(da >= pi) + ',' + cw + ',' + (this._x1 = x + r * Math.cos(a1)) + ',' + (this._y1 = y + r * Math.sin(a1))
          }
        },
        rect: function rect(x, y, w, h) {
          this._ += 'M' + (this._x0 = this._x1 = +x) + ',' + (this._y0 = this._y1 = +y) + 'h' + +w + 'v' + +h + 'h' + -w + 'Z'
        },
        toString: function toString() {
          return this._
        }
      }

      exports.default = path
      /***/
    },
    /* 521 */
    /***/
    function (module, exports, __webpack_require__) {
      /* eslint-disable no-cond-assign, no-loop-func */
      var assign = __webpack_require__(5)
      var View = __webpack_require__(42)

      assign(View.prototype, {
        getAllNodes: function getAllNodes() {
          var nodes = []
          this.root.each(function (node) {
            nodes.push(node)
          })
          return nodes
        },
        getAllLinks: function getAllLinks() {
          var links = []
          var nodes = [this.root]
          var node = void 0
          while (node = nodes.pop()) {
            var children = node.children
            if (children) {
              children.forEach(function (child) {
                links.push({
                  source: node,
                  target: child
                })
                nodes.push(child)
              })
            }
          }
          return links
        }
      })
      /***/
    },
    /* 522 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var values = __webpack_require__(113)
      var _partition = __webpack_require__(18)
      var View = __webpack_require__(42)

      assign(View.prototype, {
        partition: function partition() {
          var group_by = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []
          var order_by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []

          return _partition(this.rows, group_by, order_by)
        },
        group: function group(group_by, order_by) {
          var groups = this.partition(group_by, order_by)
          return values(groups)
        },
        groups: function groups(group_by, order_by) {
          return this.group(group_by, order_by)
        }
      })
      /***/
    },
    /* 523 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayMap = __webpack_require__(68)

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function (key) {
          return object[key]
        })
      }

      module.exports = baseValues
      /***/
    },
    /* 524 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseAssignValue = __webpack_require__(76),
        createAggregator = __webpack_require__(525)

      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */
      var groupBy = createAggregator(function (result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value)
        } else {
          baseAssignValue(result, key, [value])
        }
      })

      module.exports = groupBy
      /***/
    },
    /* 525 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayAggregator = __webpack_require__(526),
        baseAggregator = __webpack_require__(527),
        baseIteratee = __webpack_require__(66),
        isArray = __webpack_require__(10)

      /**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */
      function createAggregator(setter, initializer) {
        return function (collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {}

          return func(collection, setter, baseIteratee(iteratee, 2), accumulator)
        }
      }

      module.exports = createAggregator
      /***/
    },
    /* 526 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
          length = array == null ? 0 : array.length

        while (++index < length) {
          var value = array[index]
          setter(accumulator, value, iteratee(value), array)
        }
        return accumulator
      }

      module.exports = arrayAggregator
      /***/
    },
    /* 527 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseEach = __webpack_require__(219)

      /**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function (value, key, collection) {
          setter(accumulator, value, iteratee(value), collection)
        })
        return accumulator
      }

      module.exports = baseAggregator
      /***/
    },
    /* 528 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFor = __webpack_require__(202),
        keys = __webpack_require__(9)

      /**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys)
      }

      module.exports = baseForOwn
      /***/
    },
    /* 529 */
    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(20)

      /**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */
      function createBaseEach(eachFunc, fromRight) {
        return function (collection, iteratee) {
          if (collection == null) {
            return collection
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee)
          }
          var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection)

          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break
            }
          }
          return collection
        }
      }

      module.exports = createBaseEach
      /***/
    },
    /* 530 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8)
      var isString = __webpack_require__(7)

      module.exports = function (arr) {
        var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : []

        var comparer = void 0
        if (isFunction(keys)) {
          comparer = keys
        } else if (Array.isArray(keys)) {
          comparer = function comparer(a, b) {
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i]
              if (a[key] < b[key]) {
                return -1
              }
              if (a[key] > b[key]) {
                return 1
              }
            }
            return 0
          }
        } else if (isString(keys)) {
          comparer = function comparer(a, b) {
            if (a[keys] < b[keys]) {
              return -1
            }
            if (a[keys] > b[keys]) {
              return 1
            }
            return 0
          }
        }
        return arr.sort(comparer)
      }
      /***/
    },
    /* 531 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)

      var _require = __webpack_require__(30),
        _max = _require.max,
        _mean = _require.mean,
        _median = _require.median,
        _min = _require.min,
        _mode = _require.mode,
        _quantile = _require.quantile,
        _standardDeviation = _require.standardDeviation,
        _sum = _require.sum,
        _variance = _require.variance

      var View = __webpack_require__(42)
      var pByFraction = __webpack_require__(236)

      assign(View.prototype, {
        // statistics
        max: function max(column) {
          return _max(this.getColumn(column))
        },
        mean: function mean(column) {
          return _mean(this.getColumn(column))
        },
        average: function average(column) {
          // alias
          return this.mean(column)
        },
        median: function median(column) {
          return _median(this.getColumn(column))
        },
        min: function min(column) {
          return _min(this.getColumn(column))
        },
        mode: function mode(column) {
          return _mode(this.getColumn(column))
        },
        quantile: function quantile(column, p) {
          return _quantile(this.getColumn(column), p)
        },
        quantiles: function quantiles(column, pArr) {
          var columnArr = this.getColumn(column)
          return pArr.map(function (p) {
            return _quantile(columnArr, p)
          })
        },
        quantilesByFraction: function quantilesByFraction(column, fraction) {
          return this.quantiles(column, pByFraction(fraction))
        },
        standardDeviation: function standardDeviation(column) {
          return _standardDeviation(this.getColumn(column))
        },
        sum: function sum(column) {
          return _sum(this.getColumn(column))
        },
        variance: function variance(column) {
          return _variance(this.getColumn(column))
        },
        range: function range(column) {
          var me = this
          return [me.min(column), me.max(column)]
        },
        extent: function extent(column) {
          // alias
          return this.range(column)
        }
      })
      /***/
    },
    /* 532 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * [Simple linear regression](http://en.wikipedia.org/wiki/Simple_linear_regression)
       * is a simple way to find a fitted line
       * between a set of coordinates. This algorithm finds the slope and y-intercept of a regression line
       * using the least sum of squares.
       *
       * @param {Array<Array<number>>} data an array of two-element of arrays,
       * like `[[0, 1], [2, 3]]`
       * @returns {Object} object containing slope and intersect of regression line
       * @example
       * linearRegression([[0, 0], [1, 1]]); // => { m: 1, b: 0 }
       */
      function linearRegression(data /*: Array<Array<number>> */ ) /*: { m: number, b: number } */ {
        var m, b

        // Store data length in a local variable to reduce
        // repeated object property lookups
        var dataLength = data.length

        // if there's only one point, arbitrarily choose a slope of 0
        // and a y-intercept of whatever the y of the initial point is
        if (dataLength === 1) {
          m = 0
          b = data[0][1]
        } else {
          // Initialize our sums and scope the `m` and `b`
          // variables that define the line.
          var sumX = 0,
            sumY = 0,
            sumXX = 0,
            sumXY = 0

          // Use local variables to grab point values
          // with minimal object property lookups
          var point, x, y

          // Gather the sum of all x values, the sum of all
          // y values, and the sum of x^2 and (x*y) for each
          // value.
          //
          // In math notation, these would be SS_x, SS_y, SS_xx, and SS_xy
          for (var i = 0; i < dataLength; i++) {
            point = data[i]
            x = point[0]
            y = point[1]

            sumX += x
            sumY += y

            sumXX += x * x
            sumXY += x * y
          }

          // `m` is the slope of the regression line
          m = (dataLength * sumXY - sumX * sumY) / (dataLength * sumXX - sumX * sumX)

          // `b` is the y-intercept of the line.
          b = sumY / dataLength - m * sumX / dataLength
        }

        // Return both values as an object.
        return {
          m: m,
          b: b
        }
      }

      module.exports = linearRegression
      /***/
    },
    /* 533 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * Given the output of `linearRegression`: an object
       * with `m` and `b` values indicating slope and intercept,
       * respectively, generate a line function that translates
       * x values into y values.
       *
       * @param {Object} mb object with `m` and `b` members, representing
       * slope and intersect of desired line
       * @returns {Function} method that computes y-value at any given
       * x-value on the line.
       * @example
       * var l = linearRegressionLine(linearRegression([[0, 0], [1, 1]]));
       * l(0) // = 0
       * l(2) // = 2
       * linearRegressionLine({ b: 0, m: 1 })(1); // => 1
       * linearRegressionLine({ b: 1, m: 1 })(1); // => 2
       */
      function linearRegressionLine(mb /*: { b: number, m: number } */ ) /*: Function */ {
        // Return a function that computes a `y` value for each
        // x value it is given, based on the values of `b` and `a`
        // that we just computed.
        return function (x) {
          return mb.b + mb.m * x
        }
      }

      module.exports = linearRegressionLine
      /***/
    },
    /* 534 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [R Squared](http://en.wikipedia.org/wiki/Coefficient_of_determination)
       * value of data compared with a function `f`
       * is the sum of the squared differences between the prediction
       * and the actual value.
       *
       * @param {Array<Array<number>>} x input data: this should be doubly-nested
       * @param {Function} func function called on `[i][0]` values within the dataset
       * @returns {number} r-squared value
       * @example
       * var samples = [[0, 0], [1, 1]];
       * var regressionLine = linearRegressionLine(linearRegression(samples));
       * rSquared(samples, regressionLine); // = 1 this line is a perfect fit
       */
      function rSquared(x /*: Array<Array<number>> */ , func /*: Function */ ) /*: number */ {
        if (x.length < 2) {
          return 1
        }

        // Compute the average y value for the actual
        // data set in order to compute the
        // _total sum of squares_
        var sum = 0,
          average
        for (var i = 0; i < x.length; i++) {
          sum += x[i][1]
        }
        average = sum / x.length

        // Compute the total sum of squares - the
        // squared difference between each point
        // and the average of all points.
        var sumOfSquares = 0
        for (var j = 0; j < x.length; j++) {
          sumOfSquares += Math.pow(average - x[j][1], 2)
        }

        // Finally estimate the error: the squared
        // difference between the estimate and the actual data
        // value at each point.
        var err = 0
        for (var k = 0; k < x.length; k++) {
          err += Math.pow(x[k][1] - func(x[k][0]), 2)
        }

        // As the error grows larger, its ratio to the
        // sum of squares increases and the r squared
        // value grows lower.
        return 1 - err / sumOfSquares
      }

      module.exports = rSquared
      /***/
    },
    /* 535 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var numericSort = __webpack_require__(223),
        modeSorted = __webpack_require__(224)

      /**
       * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
       * There can be multiple modes in a list: in the event of a tie, this
       * algorithm will return the most recently seen mode.
       *
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * This runs on `O(nlog(n))` because it needs to sort the array internally
       * before running an `O(n)` search to find the mode.
       *
       * @param {Array<number>} x input
       * @returns {number} mode
       * @example
       * mode([0, 0, 1]); // => 0
       */
      function mode(x /*: Array<number> */ ) /*: number */ {
        // Sorting the array lets us iterate through it below and be sure
        // that every time we see a new number it's new and we'll never
        // see the same number twice
        return modeSorted(numericSort(x))
      }

      module.exports = mode
      /***/
    },
    /* 536 */
    /***/
    function (module, exports) {
      /* @flow */
      /* globals Map: false */

      /**
       * The [mode](http://bit.ly/W5K4Yt) is the number that appears in a list the highest number of times.
       * There can be multiple modes in a list: in the event of a tie, this
       * algorithm will return the most recently seen mode.
       *
       * modeFast uses a Map object to keep track of the mode, instead of the approach
       * used with `mode`, a sorted array. As a result, it is faster
       * than `mode` and supports any data type that can be compared with `==`.
       * It also requires a
       * [JavaScript environment with support for Map](https://kangax.github.io/compat-table/es6/#test-Map),
       * and will throw an error if Map is not available.
       *
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * @param {Array<*>} x a sample of one or more data points
       * @returns {?*} mode
       * @throws {ReferenceError} if the JavaScript environment doesn't support Map
       * @throws {Error} if x is empty
       * @example
       * modeFast(['rabbits', 'rabbits', 'squirrels']); // => 'rabbits'
       */
      function modeFast /*: :<T> */ (x /*: Array<T> */ ) /*: ?T */ {
        // This index will reflect the incidence of different values, indexing
        // them like
        // { value: count }
        var index = new Map()

        // A running `mode` and the number of times it has been encountered.
        var mode
        var modeCount = 0

        for (var i = 0; i < x.length; i++) {
          var newCount = index.get(x[i])
          if (newCount === undefined) {
            newCount = 1
          } else {
            newCount++
          }
          if (newCount > modeCount) {
            mode = x[i]
            modeCount = newCount
          }
          index.set(x[i], newCount)
        }

        if (modeCount === 0) {
          throw new Error('mode requires at last one data point')
        }

        return mode
      }

      module.exports = modeFast
      /***/
    },
    /* 537 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The minimum is the lowest number in the array. With a sorted array,
       * the first element in the array is always the smallest, so this calculation
       * can be done in one step, or constant time.
       *
       * @param {Array<number>} x input
       * @returns {number} minimum value
       * @example
       * minSorted([-100, -10, 1, 2, 5]); // => -100
       */
      function minSorted(x /*: Array<number> */ ) /*: number */ {
        return x[0]
      }

      module.exports = minSorted
      /***/
    },
    /* 538 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The maximum is the highest number in the array. With a sorted array,
       * the last element in the array is always the largest, so this calculation
       * can be done in one step, or constant time.
       *
       * @param {Array<number>} x input
       * @returns {number} maximum value
       * @example
       * maxSorted([-100, -10, 1, 2, 5]); // => 5
       */
      function maxSorted(x /*: Array<number> */ ) /*: number */ {
        return x[x.length - 1]
      }

      module.exports = maxSorted
      /***/
    },
    /* 539 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The simple [sum](https://en.wikipedia.org/wiki/Summation) of an array
       * is the result of adding all numbers together, starting from zero.
       *
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x input
       * @return {number} sum of all input numbers
       * @example
       * sumSimple([1, 2, 3]); // => 6
       */
      function sumSimple(x /*: Array<number> */ ) /*: number */ {
        var value = 0
        for (var i = 0; i < x.length; i++) {
          value += x[i]
        }
        return value
      }

      module.exports = sumSimple
      /***/
    },
    /* 540 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [product](https://en.wikipedia.org/wiki/Product_(mathematics)) of an array
       * is the result of multiplying all numbers together, starting using one as the multiplicative identity.
       *
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x input
       * @return {number} product of all input numbers
       * @example
       * product([1, 2, 3, 4]); // => 24
       */
      function product(x /*: Array<number> */ ) /*: number */ {
        var value = 1
        for (var i = 0; i < x.length; i++) {
          value *= x[i]
        }
        return value
      }

      module.exports = product
      /***/
    },
    /* 541 */
    /***/
    function (module, exports) {
      /* @flow */

      module.exports = quickselect

      /**
       * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.
       * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.
       *
       * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
       *
       * @private
       * @param {Array<number>} arr input array
       * @param {number} k pivot index
       * @param {number} left left index
       * @param {number} right right index
       * @returns {undefined}
       * @example
       * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
       * quickselect(arr, 8);
       * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
       */
      function quickselect(arr /*: Array<number> */ , k /*: number */ , left /*: number */ , right /*: number */ ) {
        left = left || 0
        right = right || arr.length - 1

        while (right > left) {
          // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
          if (right - left > 600) {
            var n = right - left + 1
            var m = k - left + 1
            var z = Math.log(n)
            var s = 0.5 * Math.exp(2 * z / 3)
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n)
            if (m - n / 2 < 0) sd *= -1
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd))
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd))
            quickselect(arr, k, newLeft, newRight)
          }

          var t = arr[k]
          var i = left
          var j = right

          swap(arr, left, k)
          if (arr[right] > t) swap(arr, left, right)

          while (i < j) {
            swap(arr, i, j)
            i++
            j--
            while (arr[i] < t) {
              i++
            }
            while (arr[j] > t) {
              j--
            }
          }

          if (arr[left] === t) swap(arr, left, j);
          else {
            j++
            swap(arr, j, right)
          }

          if (j <= k) left = j + 1
          if (k <= j) right = j - 1
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i]
        arr[i] = arr[j]
        arr[j] = tmp
      }
      /***/
    },
    /* 542 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var quantile = __webpack_require__(115)

      /**
       * The [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) is
       * a measure of statistical dispersion, or how scattered, spread, or
       * concentrated a distribution is. It's computed as the difference between
       * the third quartile and first quartile.
       *
       * @param {Array<number>} x sample of one or more numbers
       * @returns {number} interquartile range: the span between lower and upper quartile,
       * 0.25 and 0.75
       * @example
       * interquartileRange([0, 1, 2, 3]); // => 2
       */
      function interquartileRange(x /*: Array<number> */ ) {
        // Interquartile range is the span between the upper quartile,
        // at `0.75`, and lower quartile, `0.25`
        var q1 = quantile(x, 0.75),
          q2 = quantile(x, 0.25)

        if (typeof q1 === 'number' && typeof q2 === 'number') {
          return q1 - q2
        }
      }

      module.exports = interquartileRange
      /***/
    },
    /* 543 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var median = __webpack_require__(227)

      /**
       * The [Median Absolute Deviation](http://en.wikipedia.org/wiki/Median_absolute_deviation) is
       * a robust measure of statistical
       * dispersion. It is more resilient to outliers than the standard deviation.
       *
       * @param {Array<number>} x input array
       * @returns {number} median absolute deviation
       * @example
       * medianAbsoluteDeviation([1, 1, 2, 2, 4, 6, 9]); // => 1
       */
      function medianAbsoluteDeviation(x /*: Array<number> */ ) {
        // The mad of nothing is null
        var medianValue = median(x),
          medianAbsoluteDeviations = []

        // Make a list of absolute deviations from the median
        for (var i = 0; i < x.length; i++) {
          medianAbsoluteDeviations.push(Math.abs(x[i] - medianValue))
        }

        // Find the median value of that list
        return median(medianAbsoluteDeviations)
      }

      module.exports = medianAbsoluteDeviation
      /***/
    },
    /* 544 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * Split an array into chunks of a specified size. This function
       * has the same behavior as [PHP's array_chunk](http://php.net/manual/en/function.array-chunk.php)
       * function, and thus will insert smaller-sized chunks at the end if
       * the input size is not divisible by the chunk size.
       *
       * `x` is expected to be an array, and `chunkSize` a number.
       * The `x` array can contain any kind of data.
       *
       * @param {Array} x a sample
       * @param {number} chunkSize size of each output array. must be a positive integer
       * @returns {Array<Array>} a chunked array
       * @throws {Error} if chunk size is less than 1 or not an integer
       * @example
       * chunk([1, 2, 3, 4, 5, 6], 2);
       * // => [[1, 2], [3, 4], [5, 6]]
       */
      function chunk(x /*: Array<any> */ , chunkSize /*: number */ ) /*: ?Array<Array<any>> */ {
        // a list of result chunks, as arrays in an array
        var output = []

        // `chunkSize` must be zero or higher - otherwise the loop below,
        // in which we call `start += chunkSize`, will loop infinitely.
        // So, we'll detect and throw in that case to indicate
        // invalid input.
        if (chunkSize < 1) {
          throw new Error('chunk size must be a positive number')
        }

        if (Math.floor(chunkSize) !== chunkSize) {
          throw new Error('chunk size must be an integer')
        }

        // `start` is the index at which `.slice` will start selecting
        // new array elements
        for (var start = 0; start < x.length; start += chunkSize) {
          // for each chunk, slice that part of the array and add it
          // to the output. The `.slice` function does not change
          // the original array.
          output.push(x.slice(start, start + chunkSize))
        }
        return output
      }

      module.exports = chunk
      /***/
    },
    /* 545 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * Sampling with replacement is a type of sampling that allows the same
       * item to be picked out of a population more than once.
       *
       * @param {Array<*>} x an array of any kind of value
       * @param {number} n count of how many elements to take
       * @param {Function} [randomSource=Math.random] an optional entropy source that
       * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
       * @return {Array} n sampled items from the population
       * @example
       * var sample = sampleWithReplacement([1, 2, 3, 4], 2);
       * sampleWithReplacement; // = [2, 4] or any other random sample of 2 items
       */
      function sampleWithReplacement /*: :<T> */ (x /*: Array<T> */ , n /*: number */ , randomSource /*: Function */ ) {
        if (x.length === 0) {
          return []
        }

        // a custom random number source can be provided if you want to use
        // a fixed seed or another random number generator, like
        // [random-js](https://www.npmjs.org/package/random-js)
        randomSource = randomSource || Math.random

        var length = x.length
        var sample = []

        for (var i = 0; i < n; i++) {
          var index = Math.floor(randomSource() * length)

          sample.push(x[index])
        }

        return sample
      }

      module.exports = sampleWithReplacement
      /***/
    },
    /* 546 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var shuffle = __webpack_require__(228)

      /**
       * Create a [simple random sample](http://en.wikipedia.org/wiki/Simple_random_sample)
       * from a given array of `n` elements.
       *
       * The sampled values will be in any order, not necessarily the order
       * they appear in the input.
       *
       * @param {Array<any>} x input array. can contain any type
       * @param {number} n count of how many elements to take
       * @param {Function} [randomSource=Math.random] an optional entropy source that
       * returns numbers between 0 inclusive and 1 exclusive: the range [0, 1)
       * @return {Array} subset of n elements in original array
       * @example
       * var values = [1, 2, 4, 5, 6, 7, 8, 9];
       * sample(values, 3); // returns 3 random values, like [2, 5, 8];
       */
      function sample /*:: <T> */ (x /*: Array<T> */ , n /*: number */ , randomSource /*: Function */ ) /*: Array<T> */ {
        // shuffle the original array using a fisher-yates shuffle
        var shuffled = shuffle(x, randomSource)

        // and then return a subset of it - the first `n` elements.
        return shuffled.slice(0, n)
      }

      module.exports = sample
      /***/
    },
    /* 547 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var uniqueCountSorted = __webpack_require__(230),
        numericSort = __webpack_require__(223)

      /**
       * Create a new column x row matrix.
       *
       * @private
       * @param {number} columns
       * @param {number} rows
       * @return {Array<Array<number>>} matrix
       * @example
       * makeMatrix(10, 10);
       */
      function makeMatrix(columns, rows) {
        var matrix = []
        for (var i = 0; i < columns; i++) {
          var column = []
          for (var j = 0; j < rows; j++) {
            column.push(0)
          }
          matrix.push(column)
        }
        return matrix
      }

      /**
       * Generates incrementally computed values based on the sums and sums of
       * squares for the data array
       *
       * @private
       * @param {number} j
       * @param {number} i
       * @param {Array<number>} sums
       * @param {Array<number>} sumsOfSquares
       * @return {number}
       * @example
       * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);
       */
      function ssq(j, i, sums, sumsOfSquares) {
        var sji // s(j, i)
        if (j > 0) {
          var muji = (sums[i] - sums[j - 1]) / (i - j + 1) // mu(j, i)
          sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji
        } else {
          sji = sumsOfSquares[i] - sums[i] * sums[i] / (i + 1)
        }
        if (sji < 0) {
          return 0
        }
        return sji
      }

      /**
       * Function that recursively divides and conquers computations
       * for cluster j
       *
       * @private
       * @param {number} iMin Minimum index in cluster to be computed
       * @param {number} iMax Maximum index in cluster to be computed
       * @param {number} cluster Index of the cluster currently being computed
       * @param {Array<Array<number>>} matrix
       * @param {Array<Array<number>>} backtrackMatrix
       * @param {Array<number>} sums
       * @param {Array<number>} sumsOfSquares
       */
      function fillMatrixColumn(iMin, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares) {
        if (iMin > iMax) {
          return
        }

        // Start at midpoint between iMin and iMax
        var i = Math.floor((iMin + iMax) / 2)

        matrix[cluster][i] = matrix[cluster - 1][i - 1]
        backtrackMatrix[cluster][i] = i

        var jlow = cluster // the lower end for j

        if (iMin > cluster) {
          jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0)
        }
        jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0)

        var jhigh = i - 1 // the upper end for j
        if (iMax < matrix.length - 1) {
          jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0)
        }

        var sji
        var sjlowi
        var ssqjlow
        var ssqj
        for (var j = jhigh; j >= jlow; --j) {
          sji = ssq(j, i, sums, sumsOfSquares)

          if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {
            break
          }

          // Examine the lower bound of the cluster border
          sjlowi = ssq(jlow, i, sums, sumsOfSquares)

          ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1]

          if (ssqjlow < matrix[cluster][i]) {
            // Shrink the lower bound
            matrix[cluster][i] = ssqjlow
            backtrackMatrix[cluster][i] = jlow
          }
          jlow++

          ssqj = sji + matrix[cluster - 1][j - 1]
          if (ssqj < matrix[cluster][i]) {
            matrix[cluster][i] = ssqj
            backtrackMatrix[cluster][i] = j
          }
        }

        fillMatrixColumn(iMin, i - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)
        fillMatrixColumn(i + 1, iMax, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)
      }

      /**
       * Initializes the main matrices used in Ckmeans and kicks
       * off the divide and conquer cluster computation strategy
       *
       * @private
       * @param {Array<number>} data sorted array of values
       * @param {Array<Array<number>>} matrix
       * @param {Array<Array<number>>} backtrackMatrix
       */
      function fillMatrices(data, matrix, backtrackMatrix) {
        var nValues = matrix[0].length

        // Shift values by the median to improve numeric stability
        var shift = data[Math.floor(nValues / 2)]

        // Cumulative sum and cumulative sum of squares for all values in data array
        var sums = []
        var sumsOfSquares = []

        // Initialize first column in matrix & backtrackMatrix
        for (var i = 0, shiftedValue; i < nValues; ++i) {
          shiftedValue = data[i] - shift
          if (i === 0) {
            sums.push(shiftedValue)
            sumsOfSquares.push(shiftedValue * shiftedValue)
          } else {
            sums.push(sums[i - 1] + shiftedValue)
            sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue)
          }

          // Initialize for cluster = 0
          matrix[0][i] = ssq(0, i, sums, sumsOfSquares)
          backtrackMatrix[0][i] = 0
        }

        // Initialize the rest of the columns
        var iMin
        for (var cluster = 1; cluster < matrix.length; ++cluster) {
          if (cluster < matrix.length - 1) {
            iMin = cluster
          } else {
            // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]
            iMin = nValues - 1
          }

          fillMatrixColumn(iMin, nValues - 1, cluster, matrix, backtrackMatrix, sums, sumsOfSquares)
        }
      }

      /**
       * Ckmeans clustering is an improvement on heuristic-based clustering
       * approaches like Jenks. The algorithm was developed in
       * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
       * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach
       * to the problem of clustering numeric data into groups with the least
       * within-group sum-of-squared-deviations.
       *
       * Minimizing the difference within groups - what Wang & Song refer to as
       * `withinss`, or within sum-of-squares, means that groups are optimally
       * homogenous within and the data is split into representative groups.
       * This is very useful for visualization, where you may want to represent
       * a continuous variable in discrete color or style groups. This function
       * can provide groups that emphasize differences between data.
       *
       * Being a dynamic approach, this algorithm is based on two matrices that
       * store incrementally-computed values for squared deviations and backtracking
       * indexes.
       *
       * This implementation is based on Ckmeans 3.4.6, which introduced a new divide
       * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).
       *
       * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),
       * this implementation does not include any code to automatically determine
       * the optimal number of clusters: this information needs to be explicitly
       * provided.
       *
       * ### References
       * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic
       * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859
       *
       * from The R Journal Vol. 3/2, December 2011
       * @param {Array<number>} x input data, as an array of number values
       * @param {number} nClusters number of desired classes. This cannot be
       * greater than the number of values in the data array.
       * @returns {Array<Array<number>>} clustered input
       * @throws {Error} if the number of requested clusters is higher than the size of the data
       * @example
       * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);
       * // The input, clustered into groups of similar numbers.
       * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);
       */
      function ckmeans(x /*: Array<number> */ , nClusters /*: number */ ) /*: Array<Array<number>> */ {
        if (nClusters > x.length) {
          throw new Error('cannot generate more classes than there are data values')
        }

        var sorted = numericSort(x),

          // we'll use this as the maximum number of clusters
          uniqueCount = uniqueCountSorted(sorted)

        // if all of the input values are identical, there's one cluster
        // with all of the input in it.
        if (uniqueCount === 1) {
          return [sorted]
        }

        // named 'S' originally
        var matrix = makeMatrix(nClusters, sorted.length),

          // named 'J' originally
          backtrackMatrix = makeMatrix(nClusters, sorted.length)

        // This is a dynamic programming way to solve the problem of minimizing
        // within-cluster sum of squares. It's similar to linear regression
        // in this way, and this calculation incrementally computes the
        // sum of squares that are later read.
        fillMatrices(sorted, matrix, backtrackMatrix)

        // The real work of Ckmeans clustering happens in the matrix generation:
        // the generated matrices encode all possible clustering combinations, and
        // once they're generated we can solve for the best clustering groups
        // very quickly.
        var clusters = [],
          clusterRight = backtrackMatrix[0].length - 1

        // Backtrack the clusters from the dynamic programming matrix. This
        // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
        // and moves the cluster target with the loop.
        for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
          var clusterLeft = backtrackMatrix[cluster][clusterRight]

          // fill the cluster from the sorted input by taking a slice of the
          // array. the backtrack matrix makes this easy - it stores the
          // indexes where the cluster should start and end.
          clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1)

          if (cluster > 0) {
            clusterRight = clusterLeft - 1
          }
        }

        return clusters
      }

      module.exports = ckmeans
      /***/
    },
    /* 548 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var max = __webpack_require__(226),
        min = __webpack_require__(225)

      /**
       * Given an array of x, this will find the extent of the
       * x and return an array of breaks that can be used
       * to categorize the x into a number of classes. The
       * returned array will always be 1 longer than the number of
       * classes because it includes the minimum value.
       *
       * @param {Array<number>} x an array of number values
       * @param {number} nClasses number of desired classes
       * @returns {Array<number>} array of class break positions
       * @example
       * equalIntervalBreaks([1, 2, 3, 4, 5, 6], 4); //= [1, 2.25, 3.5, 4.75, 6]
       */
      function equalIntervalBreaks(x /*: Array<number> */ , nClasses /*: number */ ) /*: Array<number> */ {
        if (x.length < 2) {
          return x
        }

        var theMin = min(x),
          theMax = max(x)

        // the first break will always be the minimum value
        // in the xset
        var breaks = [theMin]

        // The size of each break is the full range of the x
        // divided by the number of classes requested
        var breakSize = (theMax - theMin) / nClasses

        // In the case of nClasses = 1, this loop won't run
        // and the returned breaks will be [min, max]
        for (var i = 1; i < nClasses; i++) {
          breaks.push(breaks[0] + breakSize * i)
        }

        // the last break will always be the
        // maximum.
        breaks.push(theMax)

        return breaks
      }

      module.exports = equalIntervalBreaks
      /***/
    },
    /* 549 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sampleCovariance = __webpack_require__(231)
      var sampleStandardDeviation = __webpack_require__(232)

      /**
       * The [correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence) is
       * a measure of how correlated two datasets are, between -1 and 1
       *
       * @param {Array<number>} x first input
       * @param {Array<number>} y second input
       * @returns {number} sample correlation
       * @example
       * sampleCorrelation([1, 2, 3, 4, 5, 6], [2, 2, 3, 4, 5, 60]).toFixed(2);
       * // => '0.69'
       */
      function sampleCorrelation(x /*: Array<number> */ , y /*: Array<number> */ ) /*: number */ {
        var cov = sampleCovariance(x, y),
          xstd = sampleStandardDeviation(x),
          ystd = sampleStandardDeviation(y)

        return cov / xstd / ystd
      }

      module.exports = sampleCorrelation
      /***/
    },
    /* 550 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)

      /**
       * [Skewness](http://en.wikipedia.org/wiki/Skewness) is
       * a measure of the extent to which a probability distribution of a
       * real-valued random variable "leans" to one side of the mean.
       * The skewness value can be positive or negative, or even undefined.
       *
       * Implementation is based on the adjusted Fisher-Pearson standardized
       * moment coefficient, which is the version found in Excel and several
       * statistical packages including Minitab, SAS and SPSS.
       *
       * @since 4.1.0
       * @param {Array<number>} x a sample of 3 or more data points
       * @returns {number} sample skewness
       * @throws {Error} if x has length less than 3
       * @example
       * sampleSkewness([2, 4, 6, 3, 1]); // => 0.590128656384365
       */
      function sampleSkewness(x /*: Array<number> */ ) /*: number */ {
        if (x.length < 3) {
          throw new Error('sampleSkewness requires at least three data points')
        }

        var meanValue = mean(x)
        var tempValue
        var sumSquaredDeviations = 0
        var sumCubedDeviations = 0

        for (var i = 0; i < x.length; i++) {
          tempValue = x[i] - meanValue
          sumSquaredDeviations += tempValue * tempValue
          sumCubedDeviations += tempValue * tempValue * tempValue
        }

        // this is Bessels' Correction: an adjustment made to sample statistics
        // that allows for the reduced degree of freedom entailed in calculating
        // values from samples rather than complete populations.
        var besselsCorrection = x.length - 1

        // Find the mean value of that list
        var theSampleStandardDeviation = Math.sqrt(sumSquaredDeviations / besselsCorrection)

        var n = x.length,
          cubedS = Math.pow(theSampleStandardDeviation, 3)

        return n * sumCubedDeviations / ((n - 1) * (n - 2) * cubedS)
      }

      module.exports = sampleSkewness
      /***/
    },
    /* 551 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)

      /**
       * [Kurtosis](http://en.wikipedia.org/wiki/Kurtosis) is
       * a measure of the heaviness of a distribution's tails relative to its
       * variance. The kurtosis value can be positive or negative, or even undefined.
       *
       * Implementation is based on Fisher's excess kurtosis definition and uses
       * unbiased moment estimators. This is the version found in Excel and available
       * in several statistical packages, including SAS and SciPy.
       *
       * @param {Array<number>} x a sample of 4 or more data points
       * @returns {number} sample kurtosis
       * @throws {Error} if x has length less than 4
       * @example
       * sampleKurtosis([1, 2, 2, 3, 5]); // => 1.4555765595463122
       */
      function sampleKurtosis(x /*: Array<number> */ ) /*: number */ {
        var n = x.length

        if (n < 4) {
          throw new Error('sampleKurtosis requires at least four data points')
        }

        var meanValue = mean(x)
        var tempValue
        var secondCentralMoment = 0
        var fourthCentralMoment = 0

        for (var i = 0; i < n; i++) {
          tempValue = x[i] - meanValue
          secondCentralMoment += tempValue * tempValue
          fourthCentralMoment += tempValue * tempValue * tempValue * tempValue
        }

        return (n - 1) / ((n - 2) * (n - 3)) * (n * (n + 1) * fourthCentralMoment / (secondCentralMoment * secondCentralMoment) - 3 * (n - 1))
      }

      module.exports = sampleKurtosis
      /***/
    },
    /* 552 */
    /***/
    function (module, exports) {
      /**
       * Implementation of [Heap's Algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm)
       * for generating permutations.
       *
       * @param {Array} elements any type of data
       * @returns {Array<Array>} array of permutations
       */
      function permutationsHeap /*:: <T> */ (elements /*: Array<T> */ ) /*: Array<Array<T>> */ {
        var indexes = new Array(elements.length)
        var permutations = [elements.slice()]

        for (var i = 0; i < elements.length; i++) {
          indexes[i] = 0
        }

        for (i = 0; i < elements.length;) {
          if (indexes[i] < i) {
            // At odd indexes, swap from indexes[i] instead
            // of from the beginning of the array
            var swapFrom = 0
            if (i % 2 !== 0) {
              swapFrom = indexes[i]
            }

            // swap between swapFrom and i, using
            // a temporary variable as storage.
            var temp = elements[swapFrom]
            elements[swapFrom] = elements[i]
            elements[i] = temp

            permutations.push(elements.slice())
            indexes[i]++
              i = 0
          } else {
            indexes[i] = 0
            i++
          }
        }

        return permutations
      }

      module.exports = permutationsHeap
      /***/
    },
    /* 553 */
    /***/
    function (module, exports) {
      /**
       * Implementation of Combinations
       * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
       * https://en.wikipedia.org/wiki/Combination
       * @param {Array} x any type of data
       * @param {int} k the number of objects in each group (without replacement)
       * @returns {Array<Array>} array of permutations
       * @example
       * combinations([1, 2, 3], 2); // => [[1,2], [1,3], [2,3]]
       */

      function combinations(x /*: Array<any> */ , k /*: number */ ) {
        var i
        var subI
        var combinationList = []
        var subsetCombinations
        var next

        for (i = 0; i < x.length; i++) {
          if (k === 1) {
            combinationList.push([x[i]])
          } else {
            subsetCombinations = combinations(x.slice(i + 1, x.length), k - 1)
            for (subI = 0; subI < subsetCombinations.length; subI++) {
              next = subsetCombinations[subI]
              next.unshift(x[i])
              combinationList.push(next)
            }
          }
        }
        return combinationList
      }

      module.exports = combinations
      /***/
    },
    /* 554 */
    /***/
    function (module, exports) {
      /**
       * Implementation of [Combinations](https://en.wikipedia.org/wiki/Combination) with replacement
       * Combinations are unique subsets of a collection - in this case, k x from a collection at a time.
       * 'With replacement' means that a given element can be chosen multiple times.
       * Unlike permutation, order doesn't matter for combinations.
       *
       * @param {Array} x any type of data
       * @param {int} k the number of objects in each group (without replacement)
       * @returns {Array<Array>} array of permutations
       * @example
       * combinationsReplacement([1, 2], 2); // => [[1, 1], [1, 2], [2, 2]]
       */
      function combinationsReplacement(x /*: Array<any> */ , k /*: number */ ) {
        var combinationList = []

        for (var i = 0; i < x.length; i++) {
          if (k === 1) {
            // If we're requested to find only one element, we don't need
            // to recurse: just push `x[i]` onto the list of combinations.
            combinationList.push([x[i]])
          } else {
            // Otherwise, recursively find combinations, given `k - 1`. Note that
            // we request `k - 1`, so if you were looking for k=3 combinations, we're
            // requesting k=2. This -1 gets reversed in the for loop right after this
            // code, since we concatenate `x[i]` onto the selected combinations,
            // bringing `k` back up to your requested level.
            // This recursion may go many levels deep, since it only stops once
            // k=1.
            var subsetCombinations = combinationsReplacement(x.slice(i, x.length), k - 1)

            for (var j = 0; j < subsetCombinations.length; j++) {
              combinationList.push([x[i]].concat(subsetCombinations[j]))
            }
          }
        }

        return combinationList
      }

      module.exports = combinationsReplacement
      /***/
    },
    /* 555 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * When adding a new value to a list, one does not have to necessary
       * recompute the mean of the list in linear time. They can instead use
       * this function to compute the new mean by providing the current mean,
       * the number of elements in the list that produced it and the new
       * value to add.
       *
       * @since 2.5.0
       * @param {number} mean current mean
       * @param {number} n number of items in the list
       * @param {number} newValue the added value
       * @returns {number} the new mean
       *
       * @example
       * addToMean(14, 5, 53); // => 20.5
       */
      function addToMean(mean /*: number */ , n /*: number */ , newValue /*: number */ ) /*: number */ {
        return mean + (newValue - mean) / (n + 1)
      }

      module.exports = addToMean
      /***/
    },
    /* 556 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var combineMeans = __webpack_require__(233)

      /**
       * When combining two lists of values for which one already knows the variances,
       * one does not have to necessary recompute the variance of the combined lists
       * in linear time. They can instead use this function to compute the combined
       * variance by providing the variance, mean & number of values of the first list
       * and the variance, mean & number of values of the second list.
       *
       * @since 3.0.0
       * @param {number} variance1 variance of the first list
       * @param {number} mean1 mean of the first list
       * @param {number} n1 number of items in the first list
       * @param {number} variance2 variance of the second list
       * @param {number} mean2 mean of the second list
       * @param {number} n2 number of items in the second list
       * @returns {number} the combined mean
       *
       * @example
       * combineVariances(14 / 3, 5, 3, 8 / 3, 4, 3); // => 47 / 12
       */
      function combineVariances(variance1 /*: number */ , mean1 /*: number */ , n1 /*: number */ , variance2 /*: number */ , mean2 /*: number */ , n2 /*: number */ ) /*: number */ {
        var newMean = combineMeans(mean1, n1, mean2, n2)

        return (n1 * (variance1 + Math.pow(mean1 - newMean, 2)) + n2 * (variance2 + Math.pow(mean2 - newMean, 2))) / (n1 + n2)
      }

      module.exports = combineVariances
      /***/
    },
    /* 557 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [Geometric Mean](https://en.wikipedia.org/wiki/Geometric_mean) is
       * a mean function that is more useful for numbers in different
       * ranges.
       *
       * This is the nth root of the input numbers multiplied by each other.
       *
       * The geometric mean is often useful for
       * **[proportional growth](https://en.wikipedia.org/wiki/Geometric_mean#Proportional_growth)**: given
       * growth rates for multiple years, like _80%, 16.66% and 42.85%_, a simple
       * mean will incorrectly estimate an average growth rate, whereas a geometric
       * mean will correctly estimate a growth rate that, over those years,
       * will yield the same end value.
       *
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x sample of one or more data points
       * @returns {number} geometric mean
       * @throws {Error} if x is empty
       * @throws {Error} if x contains a negative number
       * @example
       * var growthRates = [1.80, 1.166666, 1.428571];
       * var averageGrowth = geometricMean(growthRates);
       * var averageGrowthRates = [averageGrowth, averageGrowth, averageGrowth];
       * var startingValue = 10;
       * var startingValueMean = 10;
       * growthRates.forEach(function(rate) {
       *   startingValue *= rate;
       * });
       * averageGrowthRates.forEach(function(rate) {
       *   startingValueMean *= rate;
       * });
       * startingValueMean === startingValue;
       */
      function geometricMean(x /*: Array<number> */ ) {
        // The mean of no numbers is null
        if (x.length === 0) {
          throw new Error('geometricMean requires at least one data point')
        }

        // the starting value.
        var value = 1

        for (var i = 0; i < x.length; i++) {
          // the geometric mean is only valid for positive numbers
          if (x[i] <= 0) {
            throw new Error('geometricMean requires only positive numbers as input')
          }

          // repeatedly multiply the value by each number
          value *= x[i]
        }

        return Math.pow(value, 1 / x.length)
      }

      module.exports = geometricMean
      /***/
    },
    /* 558 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [Harmonic Mean](https://en.wikipedia.org/wiki/Harmonic_mean) is
       * a mean function typically used to find the average of rates.
       * This mean is calculated by taking the reciprocal of the arithmetic mean
       * of the reciprocals of the input numbers.
       *
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * This runs on `O(n)`, linear time in respect to the array.
       *
       * @param {Array<number>} x sample of one or more data points
       * @returns {number} harmonic mean
       * @throws {Error} if x is empty
       * @throws {Error} if x contains a negative number
       * @example
       * harmonicMean([2, 3]).toFixed(2) // => '2.40'
       */
      function harmonicMean(x /*: Array<number> */ ) {
        // The mean of no numbers is null
        if (x.length === 0) {
          throw new Error('harmonicMean requires at least one data point')
        }

        var reciprocalSum = 0

        for (var i = 0; i < x.length; i++) {
          // the harmonic mean is only valid for positive numbers
          if (x[i] <= 0) {
            throw new Error('harmonicMean requires only positive numbers as input')
          }

          reciprocalSum += 1 / x[i]
        }

        // divide n by the the reciprocal sum
        return x.length / reciprocalSum
      }

      module.exports = harmonicMean
      /***/
    },
    /* 559 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var quantileSorted = __webpack_require__(116)

      /**
       * The [median](http://en.wikipedia.org/wiki/Median) is
       * the middle number of a list. This is often a good indicator of 'the middle'
       * when there are outliers that skew the `mean()` value.
       * This is a [measure of central tendency](https://en.wikipedia.org/wiki/Central_tendency):
       * a method of finding a typical or central value of a set of numbers.
       *
       * The median isn't necessarily one of the elements in the list: the value
       * can be the average of two elements if the list has an even length
       * and the two central values are different.
       *
       * @param {Array<number>} sorted input
       * @returns {number} median value
       * @example
       * medianSorted([10, 2, 5, 100, 2, 1]); // => 52.5
       */
      function medianSorted(sorted /*: Array<number> */ ) /*: number */ {
        return quantileSorted(sorted, 0.5)
      }

      module.exports = medianSorted
      /***/
    },
    /* 560 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * When removing a value from a list, one does not have to necessary
       * recompute the mean of the list in linear time. They can instead use
       * this function to compute the new mean by providing the current mean,
       * the number of elements in the list that produced it and the value to remove.
       *
       * @since 3.0.0
       * @param {number} mean current mean
       * @param {number} n number of items in the list
       * @param {number} value the value to remove
       * @returns {number} the new mean
       *
       * @example
       * subtractFromMean(20.5, 6, 53); // => 14
       */
      function subtractFromMean(mean /*: number */ , n /*: number */ , value /*: number */ ) /*: number */ {
        return (mean * n - value) / (n - 1)
      }

      module.exports = subtractFromMean
      /***/
    },
    /* 561 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The Root Mean Square (RMS) is
       * a mean function used as a measure of the magnitude of a set
       * of numbers, regardless of their sign.
       * This is the square root of the mean of the squares of the
       * input numbers.
       * This runs on `O(n)`, linear time in respect to the array
       *
       * @param {Array<number>} x a sample of one or more data points
       * @returns {number} root mean square
       * @throws {Error} if x is empty
       * @example
       * rootMeanSquare([-1, 1, -1, 1]); // => 1
       */
      function rootMeanSquare(x /*: Array<number> */ ) /*: number */ {
        if (x.length === 0) {
          throw new Error('rootMeanSquare requires at least one data point')
        }

        var sumOfSquares = 0
        for (var i = 0; i < x.length; i++) {
          sumOfSquares += Math.pow(x[i], 2)
        }

        return Math.sqrt(sumOfSquares / x.length)
      }

      module.exports = rootMeanSquare
      /***/
    },
    /* 562 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var standardDeviation = __webpack_require__(220)
      var mean = __webpack_require__(23)

      /**
       * This is to compute [a one-sample t-test](https://en.wikipedia.org/wiki/Student%27s_t-test#One-sample_t-test), comparing the mean
       * of a sample to a known value, x.
       *
       * in this case, we're trying to determine whether the
       * population mean is equal to the value that we know, which is `x`
       * here. usually the results here are used to look up a
       * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
       * a certain level of significance, will let you determine that the
       * null hypothesis can or cannot be rejected.
       *
       * @param {Array<number>} x sample of one or more numbers
       * @param {number} expectedValue expected value of the population mean
       * @returns {number} value
       * @example
       * tTest([1, 2, 3, 4, 5, 6], 3.385).toFixed(2); // => '0.16'
       */
      function tTest(x /*: Array<number> */ , expectedValue /*: number */ ) /*: number */ {
        // The mean of the sample
        var sampleMean = mean(x)

        // The standard deviation of the sample
        var sd = standardDeviation(x)

        // Square root the length of the sample
        var rootN = Math.sqrt(x.length)

        // returning the t value
        return (sampleMean - expectedValue) / (sd / rootN)
      }

      module.exports = tTest
      /***/
    },
    /* 563 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)
      var sampleVariance = __webpack_require__(117)

      /**
       * This is to compute [two sample t-test](http://en.wikipedia.org/wiki/Student's_t-test).
       * Tests whether "mean(X)-mean(Y) = difference", (
       * in the most common case, we often have `difference == 0` to test if two samples
       * are likely to be taken from populations with the same mean value) with
       * no prior knowledge on standard deviations of both samples
       * other than the fact that they have the same standard deviation.
       *
       * Usually the results here are used to look up a
       * [p-value](http://en.wikipedia.org/wiki/P-value), which, for
       * a certain level of significance, will let you determine that the
       * null hypothesis can or cannot be rejected.
       *
       * `diff` can be omitted if it equals 0.
       *
       * [This is used to confirm or deny](http://www.monarchlab.org/Lab/Research/Stats/2SampleT.aspx)
       * a null hypothesis that the two populations that have been sampled into
       * `sampleX` and `sampleY` are equal to each other.
       *
       * @param {Array<number>} sampleX a sample as an array of numbers
       * @param {Array<number>} sampleY a sample as an array of numbers
       * @param {number} [difference=0]
       * @returns {number} test result
       * @example
       * ss.tTestTwoSample([1, 2, 3, 4], [3, 4, 5, 6], 0); //= -2.1908902300206643
       */
      function tTestTwoSample(sampleX /*: Array<number> */ , sampleY /*: Array<number> */ , difference /*: number */ ) {
        var n = sampleX.length,
          m = sampleY.length

        // If either sample doesn't actually have any values, we can't
        // compute this at all, so we return `null`.
        if (!n || !m) {
          return null
        }

        // default difference (mu) is zero
        if (!difference) {
          difference = 0
        }

        var meanX = mean(sampleX),
          meanY = mean(sampleY),
          sampleVarianceX = sampleVariance(sampleX),
          sampleVarianceY = sampleVariance(sampleY)

        if (typeof meanX === 'number' && typeof meanY === 'number' && typeof sampleVarianceX === 'number' && typeof sampleVarianceY === 'number') {
          var weightedVariance = ((n - 1) * sampleVarianceX + (m - 1) * sampleVarianceY) / (n + m - 2)

          return (meanX - meanY - difference) / Math.sqrt(weightedVariance * (1 / n + 1 / m))
        }
      }

      module.exports = tTestTwoSample
      /***/
    },
    /* 564 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * [Bayesian Classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier)
       *
       * This is a nave bayesian classifier that takes
       * singly-nested objects.
       *
       * @class
       * @example
       * var bayes = new BayesianClassifier();
       * bayes.train({
       *   species: 'Cat'
       * }, 'animal');
       * var result = bayes.score({
       *   species: 'Cat'
       * })
       * // result
       * // {
       * //   animal: 1
       * // }
       */
      function BayesianClassifier() {
        // The number of items that are currently
        // classified in the model
        this.totalCount = 0
        // Every item classified in the model
        this.data = {}
      }

      /**
       * Train the classifier with a new item, which has a single
       * dimension of Javascript literal keys and values.
       *
       * @param {Object} item an object with singly-deep properties
       * @param {string} category the category this item belongs to
       * @return {undefined} adds the item to the classifier
       */
      BayesianClassifier.prototype.train = function (item, category) {
        // If the data object doesn't have any values
        // for this category, create a new object for it.
        if (!this.data[category]) {
          this.data[category] = {}
        }

        // Iterate through each key in the item.
        for (var k in item) {
          var v = item[k]
          // Initialize the nested object `data[category][k][item[k]]`
          // with an object of keys that equal 0.
          if (this.data[category][k] === undefined) {
            this.data[category][k] = {}
          }
          if (this.data[category][k][v] === undefined) {
            this.data[category][k][v] = 0
          }

          // And increment the key for this key/value combination.
          this.data[category][k][v]++
        }

        // Increment the number of items classified
        this.totalCount++
      }

      /**
       * Generate a score of how well this item matches all
       * possible categories based on its attributes
       *
       * @param {Object} item an item in the same format as with train
       * @returns {Object} of probabilities that this item belongs to a
       * given category.
       */
      BayesianClassifier.prototype.score = function (item) {
        // Initialize an empty array of odds per category.
        var odds = {},
          category
        // Iterate through each key in the item,
        // then iterate through each category that has been used
        // in previous calls to `.train()`
        for (var k in item) {
          var v = item[k]
          for (category in this.data) {
            // Create an empty object for storing key - value combinations
            // for this category.
            odds[category] = {}

            // If this item doesn't even have a property, it counts for nothing,
            // but if it does have the property that we're looking for from
            // the item to categorize, it counts based on how popular it is
            // versus the whole population.
            if (this.data[category][k]) {
              odds[category][k + '_' + v] = (this.data[category][k][v] || 0) / this.totalCount
            } else {
              odds[category][k + '_' + v] = 0
            }
          }
        }

        // Set up a new object that will contain sums of these odds by category
        var oddsSums = {}

        for (category in odds) {
          // Tally all of the odds for each category-combination pair -
          // the non-existence of a category does not add anything to the
          // score.
          oddsSums[category] = 0
          for (var combination in odds[category]) {
            oddsSums[category] += odds[category][combination]
          }
        }

        return oddsSums
      }

      module.exports = BayesianClassifier
      /***/
    },
    /* 565 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * This is a single-layer [Perceptron Classifier](http://en.wikipedia.org/wiki/Perceptron) that takes
       * arrays of numbers and predicts whether they should be classified
       * as either 0 or 1 (negative or positive examples).
       * @class
       * @example
       * // Create the model
       * var p = new PerceptronModel();
       * // Train the model with input with a diagonal boundary.
       * for (var i = 0; i < 5; i++) {
       *     p.train([1, 1], 1);
       *     p.train([0, 1], 0);
       *     p.train([1, 0], 0);
       *     p.train([0, 0], 0);
       * }
       * p.predict([0, 0]); // 0
       * p.predict([0, 1]); // 0
       * p.predict([1, 0]); // 0
       * p.predict([1, 1]); // 1
       */
      function PerceptronModel() {
        // The weights, or coefficients of the model;
        // weights are only populated when training with data.
        this.weights = []
        // The bias term, or intercept; it is also a weight but
        // it's stored separately for convenience as it is always
        // multiplied by one.
        this.bias = 0
      }

      /**
       * **Predict**: Use an array of features with the weight array and bias
       * to predict whether an example is labeled 0 or 1.
       *
       * @param {Array<number>} features an array of features as numbers
       * @returns {number} 1 if the score is over 0, otherwise 0
       */
      PerceptronModel.prototype.predict = function (features) {
        // Only predict if previously trained
        // on the same size feature array(s).
        if (features.length !== this.weights.length) {
          return null
        }

        // Calculate the sum of features times weights,
        // with the bias added (implicitly times one).
        var score = 0
        for (var i = 0; i < this.weights.length; i++) {
          score += this.weights[i] * features[i]
        }
        score += this.bias

        // Classify as 1 if the score is over 0, otherwise 0.
        if (score > 0) {
          return 1
        } else {
          return 0
        }
      }

      /**
       * **Train** the classifier with a new example, which is
       * a numeric array of features and a 0 or 1 label.
       *
       * @param {Array<number>} features an array of features as numbers
       * @param {number} label either 0 or 1
       * @returns {PerceptronModel} this
       */
      PerceptronModel.prototype.train = function (features, label) {
        // Require that only labels of 0 or 1 are considered.
        if (label !== 0 && label !== 1) {
          return null
        }
        // The length of the feature array determines
        // the length of the weight array.
        // The perceptron will continue learning as long as
        // it keeps seeing feature arrays of the same length.
        // When it sees a new data shape, it initializes.
        if (features.length !== this.weights.length) {
          this.weights = features
          this.bias = 1
        }
        // Make a prediction based on current weights.
        var prediction = this.predict(features)
        // Update the weights if the prediction is wrong.
        if (prediction !== label) {
          var gradient = label - prediction
          for (var i = 0; i < this.weights.length; i++) {
            this.weights[i] += gradient * features[i]
          }
          this.bias += gradient
        }
        return this
      }

      module.exports = PerceptronModel
      /***/
    },
    /* 566 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * A [Factorial](https://en.wikipedia.org/wiki/Factorial), usually written n!, is the product of all positive
       * integers less than or equal to n. Often factorial is implemented
       * recursively, but this iterative approach is significantly faster
       * and simpler.
       *
       * @param {number} n input, must be an integer number 1 or greater
       * @returns {number} factorial: n!
       * @throws {Error} if n is less than 0 or not an integer
       * @example
       * factorial(5); // => 120
       */
      function factorial(n /*: number */ ) /*: number */ {
        // factorial is mathematically undefined for negative numbers
        if (n < 0) {
          throw new Error('factorial requires a non-negative value')
        }

        if (Math.floor(n) !== n) {
          throw new Error('factorial requires an integer input')
        }

        // typically you'll expand the factorial function going down, like
        // 5! = 5 * 4 * 3 * 2 * 1. This is going in the opposite direction,
        // counting from 2 up to the number in question, and since anything
        // multiplied by 1 is itself, the loop only needs to start at 2.
        var accumulator = 1
        for (var i = 2; i <= n; i++) {
          // for each number up to and including the number `n`, multiply
          // the accumulator my that number.
          accumulator *= i
        }
        return accumulator
      }

      module.exports = factorial
      /***/
    },
    /* 567 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [Bernoulli distribution](http://en.wikipedia.org/wiki/Bernoulli_distribution)
       * is the probability discrete
       * distribution of a random variable which takes value 1 with success
       * probability `p` and value 0 with failure
       * probability `q` = 1 - `p`. It can be used, for example, to represent the
       * toss of a coin, where "1" is defined to mean "heads" and "0" is defined
       * to mean "tails" (or vice versa). It is
       * a special case of a Binomial Distribution
       * where `n` = 1.
       *
       * @param {number} p input value, between 0 and 1 inclusive
       * @returns {number[]} values of bernoulli distribution at this point
       * @throws {Error} if p is outside 0 and 1
       * @example
       * bernoulliDistribution(0.3); // => [0.7, 0.3]
       */
      function bernoulliDistribution(p /*: number */ ) /*: number[] */ {
        // Check that `p` is a valid probability (0  p  1)
        if (p < 0 || p > 1) {
          throw new Error('bernoulliDistribution requires probability to be between 0 and 1 inclusive')
        }

        return [1 - p, p]
      }

      module.exports = bernoulliDistribution
      /***/
    },
    /* 568 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var epsilon = __webpack_require__(70)

      /**
       * The [Binomial Distribution](http://en.wikipedia.org/wiki/Binomial_distribution) is the discrete probability
       * distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields
       * success with probability `probability`. Such a success/failure experiment is also called a Bernoulli experiment or
       * Bernoulli trial; when trials = 1, the Binomial Distribution is a Bernoulli Distribution.
       *
       * @param {number} trials number of trials to simulate
       * @param {number} probability
       * @returns {number[]} output
       */
      function binomialDistribution(trials /*: number */ , probability /*: number */ ) /*: ?number[] */ {
        // Check that `p` is a valid probability (0  p  1),
        // that `n` is an integer, strictly positive.
        if (probability < 0 || probability > 1 || trials <= 0 || trials % 1 !== 0) {
          return undefined
        }

        // We initialize `x`, the random variable, and `accumulator`, an accumulator
        // for the cumulative distribution function to 0. `distribution_functions`
        // is the object we'll return with the `probability_of_x` and the
        // `cumulativeProbability_of_x`, as well as the calculated mean &
        // variance. We iterate until the `cumulativeProbability_of_x` is
        // within `epsilon` of 1.0.
        var x = 0,
          cumulativeProbability = 0,
          cells = [],
          binomialCoefficient = 1

        // This algorithm iterates through each potential outcome,
        // until the `cumulativeProbability` is very close to 1, at
        // which point we've defined the vast majority of outcomes
        do {
          // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
          cells[x] = binomialCoefficient * Math.pow(probability, x) * Math.pow(1 - probability, trials - x)
          cumulativeProbability += cells[x]
          x++
          binomialCoefficient = binomialCoefficient * (trials - x + 1) / x
          // when the cumulativeProbability is nearly 1, we've calculated
          // the useful range of this distribution
        } while (cumulativeProbability < 1 - epsilon)

        return cells
      }

      module.exports = binomialDistribution
      /***/
    },
    /* 569 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var epsilon = __webpack_require__(70)

      /**
       * The [Poisson Distribution](http://en.wikipedia.org/wiki/Poisson_distribution)
       * is a discrete probability distribution that expresses the probability
       * of a given number of events occurring in a fixed interval of time
       * and/or space if these events occur with a known average rate and
       * independently of the time since the last event.
       *
       * The Poisson Distribution is characterized by the strictly positive
       * mean arrival or occurrence rate, ``.
       *
       * @param {number} lambda location poisson distribution
       * @returns {number[]} values of poisson distribution at that point
       */
      function poissonDistribution(lambda /*: number */ ) /*: ?number[] */ {
        // Check that lambda is strictly positive
        if (lambda <= 0) {
          return undefined
        }

        // our current place in the distribution
        var x = 0,

          // and we keep track of the current cumulative probability, in
          // order to know when to stop calculating chances.
          cumulativeProbability = 0,

          // the calculated cells to be returned
          cells = [],
          factorialX = 1

        // This algorithm iterates through each potential outcome,
        // until the `cumulativeProbability` is very close to 1, at
        // which point we've defined the vast majority of outcomes
        do {
          // a [probability mass function](https://en.wikipedia.org/wiki/Probability_mass_function)
          cells[x] = Math.exp(-lambda) * Math.pow(lambda, x) / factorialX
          cumulativeProbability += cells[x]
          x++
          factorialX *= x
          // when the cumulativeProbability is nearly 1, we've calculated
          // the useful range of this distribution
        } while (cumulativeProbability < 1 - epsilon)

        return cells
      }

      module.exports = poissonDistribution
      /***/
    },
    /* 570 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var mean = __webpack_require__(23)
      var chiSquaredDistributionTable = __webpack_require__(571)

      /**
       * The [2 (Chi-Squared) Goodness-of-Fit Test](http://en.wikipedia.org/wiki/Goodness_of_fit#Pearson.27s_chi-squared_test)
       * uses a measure of goodness of fit which is the sum of differences between observed and expected outcome frequencies
       * (that is, counts of observations), each squared and divided by the number of observations expected given the
       * hypothesized distribution. The resulting 2 statistic, `chiSquared`, can be compared to the chi-squared distribution
       * to determine the goodness of fit. In order to determine the degrees of freedom of the chi-squared distribution, one
       * takes the total number of observed frequencies and subtracts the number of estimated parameters. The test statistic
       * follows, approximately, a chi-square distribution with (k  c) degrees of freedom where `k` is the number of non-empty
       * cells and `c` is the number of estimated parameters for the distribution.
       *
       * @param {Array<number>} data
       * @param {Function} distributionType a function that returns a point in a distribution:
       * for instance, binomial, bernoulli, or poisson
       * @param {number} significance
       * @returns {number} chi squared goodness of fit
       * @example
       * // Data from Poisson goodness-of-fit example 10-19 in William W. Hines & Douglas C. Montgomery,
       * // "Probability and Statistics in Engineering and Management Science", Wiley (1980).
       * var data1019 = [
       *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       *     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       *     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       *     2, 2, 2, 2, 2, 2, 2, 2, 2,
       *     3, 3, 3, 3
       * ];
       * ss.chiSquaredGoodnessOfFit(data1019, ss.poissonDistribution, 0.05)); //= false
       */
      function chiSquaredGoodnessOfFit(data /*: Array<number> */ , distributionType /*: Function */ , significance /*: number */ ) /*: boolean */ {
        // Estimate from the sample data, a weighted mean.
        var inputMean = mean(data),

          // Calculated value of the 2 statistic.
          chiSquared = 0,

          // Degrees of freedom, calculated as (number of class intervals -
          // number of hypothesized distribution parameters estimated - 1)
          degreesOfFreedom,

          // Number of hypothesized distribution parameters estimated, expected to be supplied in the distribution test.
          // Lose one degree of freedom for estimating `lambda` from the sample data.
          c = 1,

          // The hypothesized distribution.
          // Generate the hypothesized distribution.
          hypothesizedDistribution = distributionType(inputMean),
          observedFrequencies = [],
          expectedFrequencies = [],
          k

        // Create an array holding a histogram from the sample data, of
        // the form `{ value: numberOfOcurrences }`
        for (var i = 0; i < data.length; i++) {
          if (observedFrequencies[data[i]] === undefined) {
            observedFrequencies[data[i]] = 0
          }
          observedFrequencies[data[i]]++
        }

        // The histogram we created might be sparse - there might be gaps
        // between values. So we iterate through the histogram, making
        // sure that instead of undefined, gaps have 0 values.
        for (i = 0; i < observedFrequencies.length; i++) {
          if (observedFrequencies[i] === undefined) {
            observedFrequencies[i] = 0
          }
        }

        // Create an array holding a histogram of expected data given the
        // sample size and hypothesized distribution.
        for (k in hypothesizedDistribution) {
          if (k in observedFrequencies) {
            expectedFrequencies[+k] = hypothesizedDistribution[k] * data.length
          }
        }

        // Working backward through the expected frequencies, collapse classes
        // if less than three observations are expected for a class.
        // This transformation is applied to the observed frequencies as well.
        for (k = expectedFrequencies.length - 1; k >= 0; k--) {
          if (expectedFrequencies[k] < 3) {
            expectedFrequencies[k - 1] += expectedFrequencies[k]
            expectedFrequencies.pop()

            observedFrequencies[k - 1] += observedFrequencies[k]
            observedFrequencies.pop()
          }
        }

        // Iterate through the squared differences between observed & expected
        // frequencies, accumulating the `chiSquared` statistic.
        for (k = 0; k < observedFrequencies.length; k++) {
          chiSquared += Math.pow(observedFrequencies[k] - expectedFrequencies[k], 2) / expectedFrequencies[k]
        }

        // Calculate degrees of freedom for this test and look it up in the
        // `chiSquaredDistributionTable` in order to
        // accept or reject the goodness-of-fit of the hypothesized distribution.
        degreesOfFreedom = observedFrequencies.length - c - 1
        return chiSquaredDistributionTable[degreesOfFreedom][significance] < chiSquared
      }

      module.exports = chiSquaredGoodnessOfFit
      /***/
    },
    /* 571 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * **Percentage Points of the 2 (Chi-Squared) Distribution**
       *
       * The [2 (Chi-Squared) Distribution](http://en.wikipedia.org/wiki/Chi-squared_distribution) is used in the common
       * chi-squared tests for goodness of fit of an observed distribution to a theoretical one, the independence of two
       * criteria of classification of qualitative data, and in confidence interval estimation for a population standard
       * deviation of a normal distribution from a sample standard deviation.
       *
       * Values from Appendix 1, Table III of William W. Hines & Douglas C. Montgomery, "Probability and Statistics in
       * Engineering and Management Science", Wiley (1980).
       */
      var chiSquaredDistributionTable = {
        '1': {
          '0.995': 0,
          '0.99': 0,
          '0.975': 0,
          '0.95': 0,
          '0.9': 0.02,
          '0.5': 0.45,
          '0.1': 2.71,
          '0.05': 3.84,
          '0.025': 5.02,
          '0.01': 6.63,
          '0.005': 7.88
        },
        '2': {
          '0.995': 0.01,
          '0.99': 0.02,
          '0.975': 0.05,
          '0.95': 0.1,
          '0.9': 0.21,
          '0.5': 1.39,
          '0.1': 4.61,
          '0.05': 5.99,
          '0.025': 7.38,
          '0.01': 9.21,
          '0.005': 10.6
        },
        '3': {
          '0.995': 0.07,
          '0.99': 0.11,
          '0.975': 0.22,
          '0.95': 0.35,
          '0.9': 0.58,
          '0.5': 2.37,
          '0.1': 6.25,
          '0.05': 7.81,
          '0.025': 9.35,
          '0.01': 11.34,
          '0.005': 12.84
        },
        '4': {
          '0.995': 0.21,
          '0.99': 0.3,
          '0.975': 0.48,
          '0.95': 0.71,
          '0.9': 1.06,
          '0.5': 3.36,
          '0.1': 7.78,
          '0.05': 9.49,
          '0.025': 11.14,
          '0.01': 13.28,
          '0.005': 14.86
        },
        '5': {
          '0.995': 0.41,
          '0.99': 0.55,
          '0.975': 0.83,
          '0.95': 1.15,
          '0.9': 1.61,
          '0.5': 4.35,
          '0.1': 9.24,
          '0.05': 11.07,
          '0.025': 12.83,
          '0.01': 15.09,
          '0.005': 16.75
        },
        '6': {
          '0.995': 0.68,
          '0.99': 0.87,
          '0.975': 1.24,
          '0.95': 1.64,
          '0.9': 2.2,
          '0.5': 5.35,
          '0.1': 10.65,
          '0.05': 12.59,
          '0.025': 14.45,
          '0.01': 16.81,
          '0.005': 18.55
        },
        '7': {
          '0.995': 0.99,
          '0.99': 1.25,
          '0.975': 1.69,
          '0.95': 2.17,
          '0.9': 2.83,
          '0.5': 6.35,
          '0.1': 12.02,
          '0.05': 14.07,
          '0.025': 16.01,
          '0.01': 18.48,
          '0.005': 20.28
        },
        '8': {
          '0.995': 1.34,
          '0.99': 1.65,
          '0.975': 2.18,
          '0.95': 2.73,
          '0.9': 3.49,
          '0.5': 7.34,
          '0.1': 13.36,
          '0.05': 15.51,
          '0.025': 17.53,
          '0.01': 20.09,
          '0.005': 21.96
        },
        '9': {
          '0.995': 1.73,
          '0.99': 2.09,
          '0.975': 2.7,
          '0.95': 3.33,
          '0.9': 4.17,
          '0.5': 8.34,
          '0.1': 14.68,
          '0.05': 16.92,
          '0.025': 19.02,
          '0.01': 21.67,
          '0.005': 23.59
        },
        '10': {
          '0.995': 2.16,
          '0.99': 2.56,
          '0.975': 3.25,
          '0.95': 3.94,
          '0.9': 4.87,
          '0.5': 9.34,
          '0.1': 15.99,
          '0.05': 18.31,
          '0.025': 20.48,
          '0.01': 23.21,
          '0.005': 25.19
        },
        '11': {
          '0.995': 2.6,
          '0.99': 3.05,
          '0.975': 3.82,
          '0.95': 4.57,
          '0.9': 5.58,
          '0.5': 10.34,
          '0.1': 17.28,
          '0.05': 19.68,
          '0.025': 21.92,
          '0.01': 24.72,
          '0.005': 26.76
        },
        '12': {
          '0.995': 3.07,
          '0.99': 3.57,
          '0.975': 4.4,
          '0.95': 5.23,
          '0.9': 6.3,
          '0.5': 11.34,
          '0.1': 18.55,
          '0.05': 21.03,
          '0.025': 23.34,
          '0.01': 26.22,
          '0.005': 28.3
        },
        '13': {
          '0.995': 3.57,
          '0.99': 4.11,
          '0.975': 5.01,
          '0.95': 5.89,
          '0.9': 7.04,
          '0.5': 12.34,
          '0.1': 19.81,
          '0.05': 22.36,
          '0.025': 24.74,
          '0.01': 27.69,
          '0.005': 29.82
        },
        '14': {
          '0.995': 4.07,
          '0.99': 4.66,
          '0.975': 5.63,
          '0.95': 6.57,
          '0.9': 7.79,
          '0.5': 13.34,
          '0.1': 21.06,
          '0.05': 23.68,
          '0.025': 26.12,
          '0.01': 29.14,
          '0.005': 31.32
        },
        '15': {
          '0.995': 4.6,
          '0.99': 5.23,
          '0.975': 6.27,
          '0.95': 7.26,
          '0.9': 8.55,
          '0.5': 14.34,
          '0.1': 22.31,
          '0.05': 25,
          '0.025': 27.49,
          '0.01': 30.58,
          '0.005': 32.8
        },
        '16': {
          '0.995': 5.14,
          '0.99': 5.81,
          '0.975': 6.91,
          '0.95': 7.96,
          '0.9': 9.31,
          '0.5': 15.34,
          '0.1': 23.54,
          '0.05': 26.3,
          '0.025': 28.85,
          '0.01': 32,
          '0.005': 34.27
        },
        '17': {
          '0.995': 5.7,
          '0.99': 6.41,
          '0.975': 7.56,
          '0.95': 8.67,
          '0.9': 10.09,
          '0.5': 16.34,
          '0.1': 24.77,
          '0.05': 27.59,
          '0.025': 30.19,
          '0.01': 33.41,
          '0.005': 35.72
        },
        '18': {
          '0.995': 6.26,
          '0.99': 7.01,
          '0.975': 8.23,
          '0.95': 9.39,
          '0.9': 10.87,
          '0.5': 17.34,
          '0.1': 25.99,
          '0.05': 28.87,
          '0.025': 31.53,
          '0.01': 34.81,
          '0.005': 37.16
        },
        '19': {
          '0.995': 6.84,
          '0.99': 7.63,
          '0.975': 8.91,
          '0.95': 10.12,
          '0.9': 11.65,
          '0.5': 18.34,
          '0.1': 27.2,
          '0.05': 30.14,
          '0.025': 32.85,
          '0.01': 36.19,
          '0.005': 38.58
        },
        '20': {
          '0.995': 7.43,
          '0.99': 8.26,
          '0.975': 9.59,
          '0.95': 10.85,
          '0.9': 12.44,
          '0.5': 19.34,
          '0.1': 28.41,
          '0.05': 31.41,
          '0.025': 34.17,
          '0.01': 37.57,
          '0.005': 40
        },
        '21': {
          '0.995': 8.03,
          '0.99': 8.9,
          '0.975': 10.28,
          '0.95': 11.59,
          '0.9': 13.24,
          '0.5': 20.34,
          '0.1': 29.62,
          '0.05': 32.67,
          '0.025': 35.48,
          '0.01': 38.93,
          '0.005': 41.4
        },
        '22': {
          '0.995': 8.64,
          '0.99': 9.54,
          '0.975': 10.98,
          '0.95': 12.34,
          '0.9': 14.04,
          '0.5': 21.34,
          '0.1': 30.81,
          '0.05': 33.92,
          '0.025': 36.78,
          '0.01': 40.29,
          '0.005': 42.8
        },
        '23': {
          '0.995': 9.26,
          '0.99': 10.2,
          '0.975': 11.69,
          '0.95': 13.09,
          '0.9': 14.85,
          '0.5': 22.34,
          '0.1': 32.01,
          '0.05': 35.17,
          '0.025': 38.08,
          '0.01': 41.64,
          '0.005': 44.18
        },
        '24': {
          '0.995': 9.89,
          '0.99': 10.86,
          '0.975': 12.4,
          '0.95': 13.85,
          '0.9': 15.66,
          '0.5': 23.34,
          '0.1': 33.2,
          '0.05': 36.42,
          '0.025': 39.36,
          '0.01': 42.98,
          '0.005': 45.56
        },
        '25': {
          '0.995': 10.52,
          '0.99': 11.52,
          '0.975': 13.12,
          '0.95': 14.61,
          '0.9': 16.47,
          '0.5': 24.34,
          '0.1': 34.28,
          '0.05': 37.65,
          '0.025': 40.65,
          '0.01': 44.31,
          '0.005': 46.93
        },
        '26': {
          '0.995': 11.16,
          '0.99': 12.2,
          '0.975': 13.84,
          '0.95': 15.38,
          '0.9': 17.29,
          '0.5': 25.34,
          '0.1': 35.56,
          '0.05': 38.89,
          '0.025': 41.92,
          '0.01': 45.64,
          '0.005': 48.29
        },
        '27': {
          '0.995': 11.81,
          '0.99': 12.88,
          '0.975': 14.57,
          '0.95': 16.15,
          '0.9': 18.11,
          '0.5': 26.34,
          '0.1': 36.74,
          '0.05': 40.11,
          '0.025': 43.19,
          '0.01': 46.96,
          '0.005': 49.65
        },
        '28': {
          '0.995': 12.46,
          '0.99': 13.57,
          '0.975': 15.31,
          '0.95': 16.93,
          '0.9': 18.94,
          '0.5': 27.34,
          '0.1': 37.92,
          '0.05': 41.34,
          '0.025': 44.46,
          '0.01': 48.28,
          '0.005': 50.99
        },
        '29': {
          '0.995': 13.12,
          '0.99': 14.26,
          '0.975': 16.05,
          '0.95': 17.71,
          '0.9': 19.77,
          '0.5': 28.34,
          '0.1': 39.09,
          '0.05': 42.56,
          '0.025': 45.72,
          '0.01': 49.59,
          '0.005': 52.34
        },
        '30': {
          '0.995': 13.79,
          '0.99': 14.95,
          '0.975': 16.79,
          '0.95': 18.49,
          '0.9': 20.6,
          '0.5': 29.34,
          '0.1': 40.26,
          '0.05': 43.77,
          '0.025': 46.98,
          '0.01': 50.89,
          '0.005': 53.67
        },
        '40': {
          '0.995': 20.71,
          '0.99': 22.16,
          '0.975': 24.43,
          '0.95': 26.51,
          '0.9': 29.05,
          '0.5': 39.34,
          '0.1': 51.81,
          '0.05': 55.76,
          '0.025': 59.34,
          '0.01': 63.69,
          '0.005': 66.77
        },
        '50': {
          '0.995': 27.99,
          '0.99': 29.71,
          '0.975': 32.36,
          '0.95': 34.76,
          '0.9': 37.69,
          '0.5': 49.33,
          '0.1': 63.17,
          '0.05': 67.5,
          '0.025': 71.42,
          '0.01': 76.15,
          '0.005': 79.49
        },
        '60': {
          '0.995': 35.53,
          '0.99': 37.48,
          '0.975': 40.48,
          '0.95': 43.19,
          '0.9': 46.46,
          '0.5': 59.33,
          '0.1': 74.4,
          '0.05': 79.08,
          '0.025': 83.3,
          '0.01': 88.38,
          '0.005': 91.95
        },
        '70': {
          '0.995': 43.28,
          '0.99': 45.44,
          '0.975': 48.76,
          '0.95': 51.74,
          '0.9': 55.33,
          '0.5': 69.33,
          '0.1': 85.53,
          '0.05': 90.53,
          '0.025': 95.02,
          '0.01': 100.42,
          '0.005': 104.22
        },
        '80': {
          '0.995': 51.17,
          '0.99': 53.54,
          '0.975': 57.15,
          '0.95': 60.39,
          '0.9': 64.28,
          '0.5': 79.33,
          '0.1': 96.58,
          '0.05': 101.88,
          '0.025': 106.63,
          '0.01': 112.33,
          '0.005': 116.32
        },
        '90': {
          '0.995': 59.2,
          '0.99': 61.75,
          '0.975': 65.65,
          '0.95': 69.13,
          '0.9': 73.29,
          '0.5': 89.33,
          '0.1': 107.57,
          '0.05': 113.14,
          '0.025': 118.14,
          '0.01': 124.12,
          '0.005': 128.3
        },
        '100': {
          '0.995': 67.33,
          '0.99': 70.06,
          '0.975': 74.22,
          '0.95': 77.93,
          '0.9': 82.36,
          '0.5': 99.33,
          '0.1': 118.5,
          '0.05': 124.34,
          '0.025': 129.56,
          '0.01': 135.81,
          '0.005': 140.17
        }
      }

      module.exports = chiSquaredDistributionTable
      /***/
    },
    /* 572 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * The [Z-Score, or Standard Score](http://en.wikipedia.org/wiki/Standard_score).
       *
       * The standard score is the number of standard deviations an observation
       * or datum is above or below the mean. Thus, a positive standard score
       * represents a datum above the mean, while a negative standard score
       * represents a datum below the mean. It is a dimensionless quantity
       * obtained by subtracting the population mean from an individual raw
       * score and then dividing the difference by the population standard
       * deviation.
       *
       * The z-score is only defined if one knows the population parameters;
       * if one only has a sample set, then the analogous computation with
       * sample mean and sample standard deviation yields the
       * Student's t-statistic.
       *
       * @param {number} x
       * @param {number} mean
       * @param {number} standardDeviation
       * @return {number} z score
       * @example
       * zScore(78, 80, 5); // => -0.4
       */
      function zScore(x /*: number */ , mean /*: number */ , standardDeviation /*: number */ ) /*: number */ {
        return (x - mean) / standardDeviation
      }

      module.exports = zScore
      /***/
    },
    /* 573 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var standardNormalTable = __webpack_require__(234)

      /**
       * **[Cumulative Standard Normal Probability](http://en.wikipedia.org/wiki/Standard_normal_table)**
       *
       * Since probability tables cannot be
       * printed for every normal distribution, as there are an infinite variety
       * of normal distributions, it is common practice to convert a normal to a
       * standard normal and then use the standard normal table to find probabilities.
       *
       * You can use `.5 + .5 * errorFunction(x / Math.sqrt(2))` to calculate the probability
       * instead of looking it up in a table.
       *
       * @param {number} z
       * @returns {number} cumulative standard normal probability
       */
      function cumulativeStdNormalProbability(z /*: number */ ) /*: number */ {
        // Calculate the position of this value.
        var absZ = Math.abs(z),

          // Each row begins with a different
          // significant digit: 0.5, 0.6, 0.7, and so on. Each value in the table
          // corresponds to a range of 0.01 in the input values, so the value is
          // multiplied by 100.
          index = Math.min(Math.round(absZ * 100), standardNormalTable.length - 1)

        // The index we calculate must be in the table as a positive value,
        // but we still pay attention to whether the input is positive
        // or negative, and flip the output value as a last step.
        if (z >= 0) {
          return standardNormalTable[index]
        } else {
          // due to floating-point arithmetic, values in the table with
          // 4 significant figures can nevertheless end up as repeating
          // fractions when they're computed here.
          return +(1 - standardNormalTable[index]).toFixed(4)
        }
      }

      module.exports = cumulativeStdNormalProbability
      /***/
    },
    /* 574 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * **[Gaussian error function](http://en.wikipedia.org/wiki/Error_function)**
       *
       * The `errorFunction(x/(sd * Math.sqrt(2)))` is the probability that a value in a
       * normal distribution with standard deviation sd is within x of the mean.
       *
       * This function returns a numerical approximation to the exact value.
       *
       * @param {number} x input
       * @return {number} error estimation
       * @example
       * errorFunction(1).toFixed(2); // => '0.84'
       */
      function errorFunction(x /*: number */ ) /*: number */ {
        var t = 1 / (1 + 0.5 * Math.abs(x))
        var tau = t * Math.exp(-Math.pow(x, 2) - 1.26551223 + 1.00002368 * t + 0.37409196 * Math.pow(t, 2) + 0.09678418 * Math.pow(t, 3) - 0.18628806 * Math.pow(t, 4) + 0.27886807 * Math.pow(t, 5) - 1.13520398 * Math.pow(t, 6) + 1.48851587 * Math.pow(t, 7) - 0.82215223 * Math.pow(t, 8) + 0.17087277 * Math.pow(t, 9))
        if (x >= 0) {
          return 1 - tau
        } else {
          return tau - 1
        }
      }

      module.exports = errorFunction
      /***/
    },
    /* 575 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var epsilon = __webpack_require__(70)
      var inverseErrorFunction = __webpack_require__(235)

      /**
       * The [Probit](http://en.wikipedia.org/wiki/Probit)
       * is the inverse of cumulativeStdNormalProbability(),
       * and is also known as the normal quantile function.
       *
       * It returns the number of standard deviations from the mean
       * where the p'th quantile of values can be found in a normal distribution.
       * So, for example, probit(0.5 + 0.6827/2)  1 because 68.27% of values are
       * normally found within 1 standard deviation above or below the mean.
       *
       * @param {number} p
       * @returns {number} probit
       */
      function probit(p /*: number */ ) /*: number */ {
        if (p === 0) {
          p = epsilon
        } else if (p >= 1) {
          p = 1 - epsilon
        }
        return Math.sqrt(2) * inverseErrorFunction(2 * p - 1)
      }

      module.exports = probit
      /***/
    },
    /* 576 */
    /***/
    function (module, exports, __webpack_require__) {
      /* @flow */

      var sign = __webpack_require__(577)
      /**
       * [Bisection method](https://en.wikipedia.org/wiki/Bisection_method) is a root-finding
       * method that repeatedly bisects an interval to find the root.
       *
       * This function returns a numerical approximation to the exact value.
       *
       * @param {Function} func input function
       * @param {Number} start - start of interval
       * @param {Number} end - end of interval
       * @param {Number} maxIterations - the maximum number of iterations
       * @param {Number} errorTolerance - the error tolerance
       * @returns {Number} estimated root value
       * @throws {TypeError} Argument func must be a function
       *
       * @example
       * bisect(Math.cos,0,4,100,0.003); // => 1.572265625
       */
      function bisect(func /*: (x: any) => number */ , start /*: number */ , end /*: number */ , maxIterations /*: number */ , errorTolerance /*: number */ ) /*: number */ {
        if (typeof func !== 'function') throw new TypeError('func must be a function')

        for (var i = 0; i < maxIterations; i++) {
          var output = (start + end) / 2

          if (func(output) === 0 || Math.abs((end - start) / 2) < errorTolerance) {
            return output
          }

          if (sign(func(output)) === sign(func(start))) {
            start = output
          } else {
            end = output
          }
        }

        throw new Error('maximum number of iterations exceeded')
      }

      module.exports = bisect
      /***/
    },
    /* 577 */
    /***/
    function (module, exports) {
      /* @flow */

      /**
       * [Sign](https://en.wikipedia.org/wiki/Sign_function) is a function
       * that extracts the sign of a real number
       *
       * @param {Number} x input value
       * @returns {Number} sign value either 1, 0 or -1
       * @throws {TypeError} if the input argument x is not a number
       * @private
       *
       * @example
       * sign(2); // => 1
       */
      function sign(x /*: number */ ) /*: number */ {
        if (typeof x === 'number') {
          if (x < 0) {
            return -1
          } else if (x === 0) {
            return 0
          } else {
            return 1
          }
        } else {
          throw new TypeError('not a number')
        }
      }

      module.exports = sign
      /***/
    },
    /* 578 */
    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(7)
      var cloneItems = __webpack_require__(107)

      var _require = __webpack_require__(2),
        registerConnector = _require.registerConnector

      registerConnector('default', function (dataView, dataSet) {
        if (isString(dataView)) {
          dataView = dataSet.getView(dataView)
        }
        if (!dataView) {
          throw new TypeError('Invalid dataView')
        }
        return cloneItems(dataView.rows)
      })
      /***/
    },
    /* 579 */
    /***/
    function (module, exports, __webpack_require__) {
      var toString = __webpack_require__(198)

      /** Used to generate unique IDs. */
      var idCounter = 0

      /**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */
      function uniqueId(prefix) {
        var id = ++idCounter
        return toString(prefix) + id
      }

      module.exports = uniqueId
      /***/
    },
    /* 580 */
    /***/
    function (module, exports) {
      module.exports = {
        HIERARCHY: 'hierarchy',
        GEO: 'geo',
        GRAPH: 'graph',
        TABLE: 'table',
        GEO_GRATICULE: 'geo-graticule'
      }
      /***/
    },
    /* 581 */
    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(582),
        dsvFormat = _require.dsvFormat,
        csvParse = _require.csvParse,
        tsvParse = _require.tsvParse

      var _require2 = __webpack_require__(2),
        registerConnector = _require2.registerConnector

      registerConnector('dsv', function (str) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var delimiter = options.delimiter || ','
        if (!isString(delimiter)) {
          throw new TypeError('Invalid delimiter: must be a string!')
        }
        return dsvFormat(delimiter).parse(str)
      })

      registerConnector('csv', function (str) {
        return csvParse(str)
      })

      registerConnector('tsv', function (str) {
        return tsvParse(str)
      })
      /***/
    },
    /* 582 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _dsv = __webpack_require__(119)

      Object.defineProperty(exports, 'dsvFormat', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_dsv).default
        }
      })

      var _csv = __webpack_require__(583)

      Object.defineProperty(exports, 'csvParse', {
        enumerable: true,
        get: function get() {
          return _csv.csvParse
        }
      })
      Object.defineProperty(exports, 'csvParseRows', {
        enumerable: true,
        get: function get() {
          return _csv.csvParseRows
        }
      })
      Object.defineProperty(exports, 'csvFormat', {
        enumerable: true,
        get: function get() {
          return _csv.csvFormat
        }
      })
      Object.defineProperty(exports, 'csvFormatRows', {
        enumerable: true,
        get: function get() {
          return _csv.csvFormatRows
        }
      })

      var _tsv = __webpack_require__(584)

      Object.defineProperty(exports, 'tsvParse', {
        enumerable: true,
        get: function get() {
          return _tsv.tsvParse
        }
      })
      Object.defineProperty(exports, 'tsvParseRows', {
        enumerable: true,
        get: function get() {
          return _tsv.tsvParseRows
        }
      })
      Object.defineProperty(exports, 'tsvFormat', {
        enumerable: true,
        get: function get() {
          return _tsv.tsvFormat
        }
      })
      Object.defineProperty(exports, 'tsvFormatRows', {
        enumerable: true,
        get: function get() {
          return _tsv.tsvFormatRows
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 583 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.csvFormatRows = exports.csvFormat = exports.csvParseRows = exports.csvParse = undefined

      var _dsv = __webpack_require__(119)

      var _dsv2 = _interopRequireDefault(_dsv)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var csv = (0, _dsv2.default)(',')

      var csvParse = exports.csvParse = csv.parse
      var csvParseRows = exports.csvParseRows = csv.parseRows
      var csvFormat = exports.csvFormat = csv.format
      var csvFormatRows = exports.csvFormatRows = csv.formatRows
      /***/
    },
    /* 584 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.tsvFormatRows = exports.tsvFormat = exports.tsvParseRows = exports.tsvParse = undefined

      var _dsv = __webpack_require__(119)

      var _dsv2 = _interopRequireDefault(_dsv)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var tsv = (0, _dsv2.default)('\t')

      var tsvParse = exports.tsvParse = tsv.parse
      var tsvParseRows = exports.tsvParseRows = tsv.parseRows
      var tsvFormat = exports.tsvFormat = tsv.format
      var tsvFormatRows = exports.tsvFormatRows = tsv.formatRows
      /***/
    },
    /* 585 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(0),
        geoGraticule = _require.geoGraticule

      var _require2 = __webpack_require__(2),
        registerConnector = _require2.registerConnector

      function connector(options, dataView) {
        dataView.dataType = 'geo-graticule'
        var data = geoGraticule().lines()

        data.map(function (row, index) {
          row.index = '' + index
          return row
        })

        dataView.rows = data
        return data
      }

      registerConnector('geo-graticule', connector)

      module.exports = connector
      /***/
    },
    /* 586 */
    /***/
    function (module, exports) {
      module.exports = parse

      /**
       * expected argument lengths
       * @type {Object}
       */

      var length = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0

        /**
         * segment pattern
         * @type {RegExp}
         */

      };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

      /**
       * parse an svg path data string. Generates an Array
       * of commands where each command is an Array of the
       * form `[command, arg1, arg2, ...]`
       *
       * @param {String} path
       * @return {Array}
       */

      function parse(path) {
        var data = []
        path.replace(segment, function (_, command, args) {
          var type = command.toLowerCase()
          args = parseValues(args)

          // overloaded moveTo
          if (type == 'm' && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)))
            type = 'l'
            command = command == 'm' ? 'l' : 'L'
          }

          while (true) {
            if (args.length == length[type]) {
              args.unshift(command)
              return data.push(args)
            }
            if (args.length < length[type]) throw new Error('malformed path data')
            data.push([command].concat(args.splice(0, length[type])))
          }
        })
        return data
      }

      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig

      function parseValues(args) {
        var numbers = args.match(number)
        return numbers ? numbers.map(Number) : []
      }
      /***/
    },
    /* 587 */
    /***/
    function (module, exports) {
      module.exports = Array.isArray || function (arr) {
        return Object.prototype.toString.call(arr) == '[object Array]'
      }
      /***/
    },
    /* 588 */
    /***/
    function (module, exports) {
      module.exports = absolutize

      /**
       * redefine `path` with absolute coordinates
       *
       * @param {Array} path
       * @return {Array}
       */

      function absolutize(path) {
        var startX = 0
        var startY = 0
        var x = 0
        var y = 0

        return path.map(function (seg) {
          seg = seg.slice()
          var type = seg[0]
          var command = type.toUpperCase()

          // is relative
          if (type != command) {
            seg[0] = command
            switch (type) {
              case 'a':
                seg[6] += x
                seg[7] += y
                break
              case 'v':
                seg[1] += y
                break
              case 'h':
                seg[1] += x
                break
              default:
                for (var i = 1; i < seg.length;) {
                  seg[i++] += x
                  seg[i++] += y
                }
            }
          }

          // update cursor state
          switch (command) {
            case 'Z':
              x = startX
              y = startY
              break
            case 'H':
              x = seg[1]
              break
            case 'V':
              y = seg[1]
              break
            case 'M':
              x = startX = seg[1]
              y = startY = seg[2]
              break
            default:
              x = seg[seg.length - 2]
              y = seg[seg.length - 1]
          }

          return seg
        })
      }
      /***/
    },
    /* 589 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var isFunction = __webpack_require__(8)

      var _require = __webpack_require__(2),
        GRAPH = _require.GRAPH,
        registerConnector = _require.registerConnector

      var DEFAULT_OPTIONS = {
        nodes: function nodes(d) {
          // optional
          return d.nodes
        },
        edges: function edges(d) {
          // optional
          return d.edges
        }
      }

      function connector(data, options, dataView) {
        options = assign({}, DEFAULT_OPTIONS, options)
        dataView.dataType = GRAPH
        var _options = options,
          nodes = _options.nodes,
          edges = _options.edges

        if (nodes && !isFunction(nodes)) {
          throw new TypeError('Invalid nodes: must be a function!')
        }
        if (edges && !isFunction(edges)) {
          throw new TypeError('Invalid edges: must be a function!')
        }
        dataView.rows = dataView.graph = {
          nodes: nodes(data),
          edges: edges(data)
        }
        assign(dataView, dataView.graph)
        return dataView.rows
      }

      registerConnector('graph', connector)
      registerConnector('diagram', connector)
      /***/
    },
    /* 590 */
    /***/
    function (module, exports, __webpack_require__) {
      var isFunction = __webpack_require__(8)

      var _require = __webpack_require__(120),
        hierarchy = _require.hierarchy

      var _require2 = __webpack_require__(2),
        HIERARCHY = _require2.HIERARCHY,
        registerConnector = _require2.registerConnector

      /*
       * options: {
       *   children(d) { // optional
       *     return d.children
       *   },
       * }
       */

      function connector(data, options, dataView) {
        dataView.dataType = HIERARCHY
        var children = options && options.children ? options.children : null

        if (children && !isFunction(children)) {
          throw new TypeError('Invalid children: must be a function!')
        }

        dataView.rows = dataView.root = hierarchy(data, children)
        return data
      }

      registerConnector('hierarchy', connector)
      registerConnector('tree', connector)
      /***/
    },
    /* 591 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = false

        function cluster(root) {
          var previousNode,
            x = 0

          // First walk, computing the initial x & y values.
          root.eachAfter(function (node) {
            var children = node.children
            if (children) {
              node.x = meanX(children)
              node.y = maxY(children)
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0
              node.y = 0
              previousNode = node
            }
          })

          var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2

          // Second walk, normalizing x & y to the desired size.
          return root.eachAfter(nodeSize ? function (node) {
            node.x = (node.x - root.x) * dx
            node.y = (root.y - node.y) * dy
          } : function (node) {
            node.x = (node.x - x0) / (x1 - x0) * dx
            node.y = (1 - (root.y ? node.y / root.y : 1)) * dy
          })
        }

        cluster.separation = function (x) {
          return arguments.length ? (separation = x, cluster) : separation
        }

        cluster.size = function (x) {
          return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy]
        }

        cluster.nodeSize = function (x) {
          return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null
        }

        return cluster
      }

      function defaultSeparation(a, b) {
        return a.parent === b.parent ? 1 : 2
      }

      function meanX(children) {
        return children.reduce(meanXReduce, 0) / children.length
      }

      function meanXReduce(x, c) {
        return x + c.x
      }

      function maxY(children) {
        return 1 + children.reduce(maxYReduce, 0)
      }

      function maxYReduce(y, c) {
        return Math.max(y, c.y)
      }

      function leafLeft(node) {
        var children
        while (children = node.children) {
          node = children[0]
        }
        return node
      }

      function leafRight(node) {
        var children
        while (children = node.children) {
          node = children[children.length - 1]
        }
        return node
      }
      /***/
    },
    /* 592 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        return this.eachAfter(count)
      }

      function count(node) {
        var sum = 0,
          children = node.children,
          i = children && children.length
        if (!i) sum = 1;
        else {
          while (--i >= 0) {
            sum += children[i].value
          }
        }
        node.value = sum
      }
      /***/
    },
    /* 593 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (callback) {
        var node = this,
          current,
          next = [node],
          children,
          i,
          n
        do {
          current = next.reverse(), next = []
          while (node = current.pop()) {
            callback(node), children = node.children
            if (children) {
              for (i = 0, n = children.length; i < n; ++i) {
                next.push(children[i])
              }
            }
          }
        } while (next.length)
        return this
      }
      /***/
    },
    /* 594 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (callback) {
        var node = this,
          nodes = [node],
          children,
          i
        while (node = nodes.pop()) {
          callback(node), children = node.children
          if (children) {
            for (i = children.length - 1; i >= 0; --i) {
              nodes.push(children[i])
            }
          }
        }
        return this
      }
      /***/
    },
    /* 595 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (callback) {
        var node = this,
          nodes = [node],
          next = [],
          children,
          i,
          n
        while (node = nodes.pop()) {
          next.push(node), children = node.children
          if (children) {
            for (i = 0, n = children.length; i < n; ++i) {
              nodes.push(children[i])
            }
          }
        }
        while (node = next.pop()) {
          callback(node)
        }
        return this
      }
      /***/
    },
    /* 596 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (value) {
        return this.eachAfter(function (node) {
          var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length
          while (--i >= 0) {
            sum += children[i].value
          }
          node.value = sum
        })
      }
      /***/
    },
    /* 597 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (compare) {
        return this.eachBefore(function (node) {
          if (node.children) {
            node.children.sort(compare)
          }
        })
      }
      /***/
    },
    /* 598 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (end) {
        var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start]
        while (start !== ancestor) {
          start = start.parent
          nodes.push(start)
        }
        var k = nodes.length
        while (end !== ancestor) {
          nodes.splice(k, 0, end)
          end = end.parent
        }
        return nodes
      }

      function leastCommonAncestor(a, b) {
        if (a === b) return a
        var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null
        a = aNodes.pop()
        b = bNodes.pop()
        while (a === b) {
          c = a
          a = aNodes.pop()
          b = bNodes.pop()
        }
        return c
      }
      /***/
    },
    /* 599 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        var node = this,
          nodes = [node]
        while (node = node.parent) {
          nodes.push(node)
        }
        return nodes
      }
      /***/
    },
    /* 600 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        var nodes = []
        this.each(function (node) {
          nodes.push(node)
        })
        return nodes
      }
      /***/
    },
    /* 601 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        var leaves = []
        this.eachBefore(function (node) {
          if (!node.children) {
            leaves.push(node)
          }
        })
        return leaves
      }
      /***/
    },
    /* 602 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function () {
        var root = this,
          links = []
        root.each(function (node) {
          if (node !== root) {
            // Dont include the roots parent, if any.
            links.push({
              source: node.parent,
              target: node
            })
          }
        })
        return links
      }
      /***/
    },
    /* 603 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var radius = null,
          dx = 1,
          dy = 1,
          padding = _constant.constantZero

        function pack(root) {
          root.x = dx / 2, root.y = dy / 2
          if (radius) {
            root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1))
          } else {
            root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(_constant.constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)))
          }
          return root
        }

        pack.radius = function (x) {
          return arguments.length ? (radius = (0, _accessors.optional)(x), pack) : radius
        }

        pack.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy]
        }

        pack.padding = function (x) {
          return arguments.length ? (padding = typeof x === 'function' ? x : (0, _constant2.default)(+x), pack) : padding
        }

        return pack
      }

      var _siblings = __webpack_require__(239)

      var _accessors = __webpack_require__(122)

      var _constant = __webpack_require__(241)

      var _constant2 = _interopRequireDefault(_constant)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function defaultRadius(d) {
        return Math.sqrt(d.value)
      }

      function radiusLeaf(radius) {
        return function (node) {
          if (!node.children) {
            node.r = Math.max(0, +radius(node) || 0)
          }
        }
      }

      function packChildren(padding, k) {
        return function (node) {
          if (children = node.children) {
            var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e

            if (r) {
              for (i = 0; i < n; ++i) {
                children[i].r += r
              }
            }
            e = (0, _siblings.packEnclose)(children)
            if (r) {
              for (i = 0; i < n; ++i) {
                children[i].r -= r
              }
            }
            node.r = e + r
          }
        }
      }

      function translateChild(k) {
        return function (node) {
          var parent = node.parent
          node.r *= k
          if (parent) {
            node.x = parent.x + k * node.x
            node.y = parent.y + k * node.y
          }
        }
      }
      /***/
    },
    /* 604 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.shuffle = shuffle
      var slice = exports.slice = Array.prototype.slice

      function shuffle(array) {
        var m = array.length,
          t,
          i

        while (m) {
          i = Math.random() * m-- | 0
          t = array[m]
          array[m] = array[i]
          array[i] = t
        }

        return array
      }
      /***/
    },
    /* 605 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var dx = 1,
          dy = 1,
          padding = 0,
          round = false

        function partition(root) {
          var n = root.height + 1
          root.x0 = root.y0 = padding
          root.x1 = dx
          root.y1 = dy / n
          root.eachBefore(positionNode(dy, n))
          if (round) root.eachBefore(_round2.default)
          return root
        }

        function positionNode(dy, n) {
          return function (node) {
            if (node.children) {
              (0, _dice2.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n)
            }
            var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2
            node.x0 = x0
            node.y0 = y0
            node.x1 = x1
            node.y1 = y1
          }
        }

        partition.round = function (x) {
          return arguments.length ? (round = !!x, partition) : round
        }

        partition.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy]
        }

        partition.padding = function (x) {
          return arguments.length ? (padding = +x, partition) : padding
        }

        return partition
      }

      var _round = __webpack_require__(242)

      var _round2 = _interopRequireDefault(_round)

      var _dice = __webpack_require__(48)

      var _dice2 = _interopRequireDefault(_dice)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 606 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var id = defaultId,
          parentId = defaultParentId

        function stratify(data) {
          var d,
            i,
            n = data.length,
            root,
            parent,
            node,
            nodes = new Array(n),
            nodeId,
            nodeKey,
            nodeByKey = {}

          for (i = 0; i < n; ++i) {
            d = data[i], node = nodes[i] = new _index.Node(d)
            if ((nodeId = id(d, i, data)) != null && (nodeId += '')) {
              nodeKey = keyPrefix + (node.id = nodeId)
              nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node
            }
          }

          for (i = 0; i < n; ++i) {
            node = nodes[i], nodeId = parentId(data[i], i, data)
            if (nodeId == null || !(nodeId += '')) {
              if (root) throw new Error('multiple roots')
              root = node
            } else {
              parent = nodeByKey[keyPrefix + nodeId]
              if (!parent) throw new Error('missing: ' + nodeId)
              if (parent === ambiguous) throw new Error('ambiguous: ' + nodeId)
              if (parent.children) parent.children.push(node);
              else parent.children = [node]
              node.parent = parent
            }
          }

          if (!root) throw new Error('no root')
          root.parent = preroot
          root.eachBefore(function (node) {
            node.depth = node.parent.depth + 1;
            --n
          }).eachBefore(_index.computeHeight)
          root.parent = null
          if (n > 0) throw new Error('cycle')

          return root
        }

        stratify.id = function (x) {
          return arguments.length ? (id = (0, _accessors.required)(x), stratify) : id
        }

        stratify.parentId = function (x) {
          return arguments.length ? (parentId = (0, _accessors.required)(x), stratify) : parentId
        }

        return stratify
      }

      var _accessors = __webpack_require__(122)

      var _index = __webpack_require__(121)

      var keyPrefix = '$',
        // Protect against keys like __proto__.
        preroot = {
          depth: -1
        },
        ambiguous = {}

      function defaultId(d) {
        return d.id
      }

      function defaultParentId(d) {
        return d.parentId
      }
      /***/
    },
    /* 607 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null

        function tree(root) {
          var t = treeRoot(root)

          // Compute the layout using Buchheim et al.s algorithm.
          t.eachAfter(firstWalk), t.parent.m = -t.z
          t.eachBefore(secondWalk)

          // If a fixed node size is specified, scale x and y.
          if (nodeSize) root.eachBefore(sizeNode)

          // If a fixed tree size is specified, scale x and y based on the extent.
          // Compute the left-most, right-most, and depth-most nodes for extents.
          else {
            var left = root,
              right = root,
              bottom = root
            root.eachBefore(function (node) {
              if (node.x < left.x) left = node
              if (node.x > right.x) right = node
              if (node.depth > bottom.depth) bottom = node
            })
            var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1)
            root.eachBefore(function (node) {
              node.x = (node.x + tx) * kx
              node.y = node.depth * ky
            })
          }

          return root
        }

        // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
        // applied recursively to the children of v, as well as the function
        // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
        // node v is placed to the midpoint of its outermost children.
        function firstWalk(v) {
          var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null
          if (children) {
            executeShifts(v)
            var midpoint = (children[0].z + children[children.length - 1].z) / 2
            if (w) {
              v.z = w.z + separation(v._, w._)
              v.m = v.z - midpoint
            } else {
              v.z = midpoint
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._)
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0])
        }

        // Computes all real x-coordinates by summing up the modifiers recursively.
        function secondWalk(v) {
          v._.x = v.z + v.parent.m
          v.m += v.parent.m
        }

        // The core of the algorithm. Here, a new subtree is combined with the
        // previous subtrees. Threads are used to traverse the inside and outside
        // contours of the left and right subtree up to the highest common level. The
        // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
        // superscript o means outside and i means inside, the subscript - means left
        // subtree and + means right subtree. For summing up the modifiers along the
        // contour, we use respective variables si+, si-, so-, and so+. Whenever two
        // nodes of the inside contours conflict, we compute the left one of the
        // greatest uncommon ancestors using the function ANCESTOR and call MOVE
        // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
        // Finally, we add a new thread (if necessary).
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift
            while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
              vom = nextLeft(vom)
              vop = nextRight(vop)
              vop.a = v
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._)
              if (shift > 0) {
                moveSubtree(nextAncestor(vim, v, ancestor), v, shift)
                sip += shift
                sop += shift
              }
              sim += vim.m
              sip += vip.m
              som += vom.m
              sop += vop.m
            }
            if (vim && !nextRight(vop)) {
              vop.t = vim
              vop.m += sim - sop
            }
            if (vip && !nextLeft(vom)) {
              vom.t = vip
              vom.m += sip - som
              ancestor = v
            }
          }
          return ancestor
        }

        function sizeNode(node) {
          node.x *= dx
          node.y = node.depth * dy
        }

        tree.separation = function (x) {
          return arguments.length ? (separation = x, tree) : separation
        }

        tree.size = function (x) {
          return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy]
        }

        tree.nodeSize = function (x) {
          return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null
        }

        return tree
      }

      var _index = __webpack_require__(121)

      function defaultSeparation(a, b) {
        return a.parent === b.parent ? 1 : 2
      }

      // function radialSeparation(a, b) {
      //   return (a.parent === b.parent ? 1 : 2) / a.depth;
      // }

      // This function is used to traverse the left contour of a subtree (or
      // subforest). It returns the successor of v on this contour. This successor is
      // either given by the leftmost child of v or by the thread of v. The function
      // returns null if and only if v is on the highest level of its subtree.
      function nextLeft(v) {
        var children = v.children
        return children ? children[0] : v.t
      }

      // This function works analogously to nextLeft.
      function nextRight(v) {
        var children = v.children
        return children ? children[children.length - 1] : v.t
      }

      // Shifts the current subtree rooted at w+. This is done by increasing
      // prelim(w+) and mod(w+) by shift.
      function moveSubtree(wm, wp, shift) {
        var change = shift / (wp.i - wm.i)
        wp.c -= change
        wp.s += shift
        wm.c += change
        wp.z += shift
        wp.m += shift
      }

      // All other shifts, applied to the smaller subtrees between w- and w+, are
      // performed by this function. To prepare the shifts, we have to adjust
      // change(w+), shift(w+), and change(w-).
      function executeShifts(v) {
        var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w
        while (--i >= 0) {
          w = children[i]
          w.z += shift
          w.m += shift
          shift += w.s + (change += w.c)
        }
      }

      // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
      // returns the specified (default) ancestor.
      function nextAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor
      }

      function TreeNode(node, i) {
        this._ = node
        this.parent = null
        this.children = null
        this.A = null // default ancestor
        this.a = this // ancestor
        this.z = 0 // prelim
        this.m = 0 // mod
        this.c = 0 // change
        this.s = 0 // shift
        this.t = null // thread
        this.i = i // number
      }

      TreeNode.prototype = Object.create(_index.Node.prototype)

      function treeRoot(root) {
        var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n

        while (node = nodes.pop()) {
          if (children = node._.children) {
            node.children = new Array(n = children.length)
            for (i = n - 1; i >= 0; --i) {
              nodes.push(child = node.children[i] = new TreeNode(children[i], i))
              child.parent = node
            }
          }
        }

        (tree.parent = new TreeNode(null, 0)).children = [tree]
        return tree
      }

      // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
      /***/
    },
    /* 608 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var tile = _squarify2.default,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = _constant.constantZero,
          paddingTop = _constant.constantZero,
          paddingRight = _constant.constantZero,
          paddingBottom = _constant.constantZero,
          paddingLeft = _constant.constantZero

        function treemap(root) {
          root.x0 = root.y0 = 0
          root.x1 = dx
          root.y1 = dy
          root.eachBefore(positionNode)
          paddingStack = [0]
          if (round) root.eachBefore(_round2.default)
          return root
        }

        function positionNode(node) {
          var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2
          node.x0 = x0
          node.y0 = y0
          node.x1 = x1
          node.y1 = y1
          if (node.children) {
            p = paddingStack[node.depth + 1] = paddingInner(node) / 2
            x0 += paddingLeft(node) - p
            y0 += paddingTop(node) - p
            x1 -= paddingRight(node) - p
            y1 -= paddingBottom(node) - p
            if (x1 < x0) x0 = x1 = (x0 + x1) / 2
            if (y1 < y0) y0 = y1 = (y0 + y1) / 2
            tile(node, x0, y0, x1, y1)
          }
        }

        treemap.round = function (x) {
          return arguments.length ? (round = !!x, treemap) : round
        }

        treemap.size = function (x) {
          return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy]
        }

        treemap.tile = function (x) {
          return arguments.length ? (tile = (0, _accessors.required)(x), treemap) : tile
        }

        treemap.padding = function (x) {
          return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner()
        }

        treemap.paddingInner = function (x) {
          return arguments.length ? (paddingInner = typeof x === 'function' ? x : (0, _constant2.default)(+x), treemap) : paddingInner
        }

        treemap.paddingOuter = function (x) {
          return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop()
        }

        treemap.paddingTop = function (x) {
          return arguments.length ? (paddingTop = typeof x === 'function' ? x : (0, _constant2.default)(+x), treemap) : paddingTop
        }

        treemap.paddingRight = function (x) {
          return arguments.length ? (paddingRight = typeof x === 'function' ? x : (0, _constant2.default)(+x), treemap) : paddingRight
        }

        treemap.paddingBottom = function (x) {
          return arguments.length ? (paddingBottom = typeof x === 'function' ? x : (0, _constant2.default)(+x), treemap) : paddingBottom
        }

        treemap.paddingLeft = function (x) {
          return arguments.length ? (paddingLeft = typeof x === 'function' ? x : (0, _constant2.default)(+x), treemap) : paddingLeft
        }

        return treemap
      }

      var _round = __webpack_require__(242)

      var _round2 = _interopRequireDefault(_round)

      var _squarify = __webpack_require__(123)

      var _squarify2 = _interopRequireDefault(_squarify)

      var _accessors = __webpack_require__(122)

      var _constant = __webpack_require__(241)

      var _constant2 = _interopRequireDefault(_constant)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 609 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (parent, x0, y0, x1, y1) {
        var nodes = parent.children,
          i,
          n = nodes.length,
          sum,
          sums = new Array(n + 1)

        for (sums[0] = sum = i = 0; i < n; ++i) {
          sums[i + 1] = sum += nodes[i].value
        }

        partition(0, n, parent.value, x0, y0, x1, y1)

        function partition(i, j, value, x0, y0, x1, y1) {
          if (i >= j - 1) {
            var node = nodes[i]
            node.x0 = x0, node.y0 = y0
            node.x1 = x1, node.y1 = y1
            return
          }

          var valueOffset = sums[i],
            valueTarget = value / 2 + valueOffset,
            k = i + 1,
            hi = j - 1

          while (k < hi) {
            var mid = k + hi >>> 1
            if (sums[mid] < valueTarget) k = mid + 1;
            else hi = mid
          }

          if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k

          var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft

          if (x1 - x0 > y1 - y0) {
            var xk = (x0 * valueRight + x1 * valueLeft) / value
            partition(i, k, valueLeft, x0, y0, xk, y1)
            partition(k, j, valueRight, xk, y0, x1, y1)
          } else {
            var yk = (y0 * valueRight + y1 * valueLeft) / value
            partition(i, k, valueLeft, x0, y0, x1, yk)
            partition(k, j, valueRight, x0, yk, x1, y1)
          }
        }
      }
      /***/
    },
    /* 610 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (parent, x0, y0, x1, y1) {
        (parent.depth & 1 ? _slice2.default : _dice2.default)(parent, x0, y0, x1, y1)
      }

      var _dice = __webpack_require__(48)

      var _dice2 = _interopRequireDefault(_dice)

      var _slice = __webpack_require__(71)

      var _slice2 = _interopRequireDefault(_slice)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 611 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _dice = __webpack_require__(48)

      var _dice2 = _interopRequireDefault(_dice)

      var _slice = __webpack_require__(71)

      var _slice2 = _interopRequireDefault(_slice)

      var _squarify = __webpack_require__(123)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      exports.default = (function custom(ratio) {
        function resquarify(parent, x0, y0, x1, y1) {
          if ((rows = parent._squarify) && rows.ratio === ratio) {
            var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value

            while (++j < m) {
              row = rows[j], nodes = row.children
              for (i = row.value = 0, n = nodes.length; i < n; ++i) {
                row.value += nodes[i].value
              }
              if (row.dice)(0, _dice2.default)(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
              else(0, _slice2.default)(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1)
              value -= row.value
            }
          } else {
            parent._squarify = rows = (0, _squarify.squarifyRatio)(ratio, parent, x0, y0, x1, y1)
            rows.ratio = ratio
          }
        }

        resquarify.ratio = function (x) {
          return custom((x = +x) > 1 ? x : 1)
        }

        return resquarify
      }(_squarify.phi))
      /***/
    },
    /* 612 */
    /***/
    function (module, exports, __webpack_require__) {
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(613),
        feature = _require.feature

      var GeoJSONConnector = __webpack_require__(237)

      var _require2 = __webpack_require__(2),
        registerConnector = _require2.registerConnector

      function TopoJSONConnector(data, options, dataView) {
        var object = options.object
        if (!isString(object)) {
          throw new TypeError('Invalid object: must be a string!')
        }
        var geoData = feature(data, data.objects[object])
        return GeoJSONConnector(geoData, options, dataView)
      }

      registerConnector('topojson', TopoJSONConnector)
      registerConnector('TopoJSON', TopoJSONConnector)
      /***/
    },
    /* 613 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _bbox = __webpack_require__(243)

      Object.defineProperty(exports, 'bbox', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bbox).default
        }
      })

      var _feature = __webpack_require__(125)

      Object.defineProperty(exports, 'feature', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_feature).default
        }
      })

      var _mesh = __webpack_require__(615)

      Object.defineProperty(exports, 'mesh', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_mesh).default
        }
      })
      Object.defineProperty(exports, 'meshArcs', {
        enumerable: true,
        get: function get() {
          return _mesh.meshArcs
        }
      })

      var _merge = __webpack_require__(616)

      Object.defineProperty(exports, 'merge', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_merge).default
        }
      })
      Object.defineProperty(exports, 'mergeArcs', {
        enumerable: true,
        get: function get() {
          return _merge.mergeArcs
        }
      })

      var _neighbors = __webpack_require__(617)

      Object.defineProperty(exports, 'neighbors', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_neighbors).default
        }
      })

      var _quantize = __webpack_require__(619)

      Object.defineProperty(exports, 'quantize', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_quantize).default
        }
      })

      var _transform = __webpack_require__(124)

      Object.defineProperty(exports, 'transform', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_transform).default
        }
      })

      var _untransform = __webpack_require__(246)

      Object.defineProperty(exports, 'untransform', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_untransform).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 614 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (array, n) {
        var t,
          j = array.length,
          i = j - n
        while (i < --j) {
          t = array[i], array[i++] = array[j], array[j] = t
        }
      }
      /***/
    },
    /* 615 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (topology) {
        return (0, _feature.object)(topology, meshArcs.apply(this, arguments))
      }

      exports.meshArcs = meshArcs

      var _feature = __webpack_require__(125)

      var _stitch = __webpack_require__(245)

      var _stitch2 = _interopRequireDefault(_stitch)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function meshArcs(topology, object, filter) {
        var arcs, i, n
        if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
        else {
          for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) {
            arcs[i] = i
          }
        }
        return {
          type: 'MultiLineString',
          arcs: (0, _stitch2.default)(topology, arcs)
        }
      }

      function extractArcs(topology, object, filter) {
        var arcs = [],
          geomsByArc = [],
          geom

        function extract0(i) {
          var j = i < 0 ? ~i : i;
          (geomsByArc[j] || (geomsByArc[j] = [])).push({
            i: i,
            g: geom
          })
        }

        function extract1(arcs) {
          arcs.forEach(extract0)
        }

        function extract2(arcs) {
          arcs.forEach(extract1)
        }

        function extract3(arcs) {
          arcs.forEach(extract2)
        }

        function geometry(o) {
          switch (geom = o, o.type) {
            case 'GeometryCollection':
              o.geometries.forEach(geometry);
              break
            case 'LineString':
              extract1(o.arcs);
              break
            case 'MultiLineString':
            case 'Polygon':
              extract2(o.arcs);
              break
            case 'MultiPolygon':
              extract3(o.arcs);
              break
          }
        }

        geometry(object)

        geomsByArc.forEach(filter == null ? function (geoms) {
          arcs.push(geoms[0].i)
        } : function (geoms) {
          if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i)
        })

        return arcs
      }
      /***/
    },
    /* 616 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (topology) {
        return (0, _feature.object)(topology, mergeArcs.apply(this, arguments))
      }

      exports.mergeArcs = mergeArcs

      var _feature = __webpack_require__(125)

      var _stitch = __webpack_require__(245)

      var _stitch2 = _interopRequireDefault(_stitch)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function planarRingArea(ring) {
        var i = -1,
          n = ring.length,
          a,
          b = ring[n - 1],
          area = 0
        while (++i < n) {
          a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]
        }
        return Math.abs(area) // Note: doubled area!
      }

      function mergeArcs(topology, objects) {
        var polygonsByArc = {},
          polygons = [],
          groups = []

        objects.forEach(geometry)

        function geometry(o) {
          switch (o.type) {
            case 'GeometryCollection':
              o.geometries.forEach(geometry);
              break
            case 'Polygon':
              extract(o.arcs);
              break
            case 'MultiPolygon':
              o.arcs.forEach(extract);
              break
          }
        }

        function extract(polygon) {
          polygon.forEach(function (ring) {
            ring.forEach(function (arc) {
              (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon)
            })
          })
          polygons.push(polygon)
        }

        function area(ring) {
          return planarRingArea((0, _feature.object)(topology, {
            type: 'Polygon',
            arcs: [ring]
          }).coordinates[0])
        }

        polygons.forEach(function (polygon) {
          if (!polygon._) {
            var group = [],
              neighbors = [polygon]
            polygon._ = 1
            groups.push(group)
            while (polygon = neighbors.pop()) {
              group.push(polygon)
              polygon.forEach(function (ring) {
                ring.forEach(function (arc) {
                  polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {
                    if (!polygon._) {
                      polygon._ = 1
                      neighbors.push(polygon)
                    }
                  })
                })
              })
            }
          }
        })

        polygons.forEach(function (polygon) {
          delete polygon._
        })

        return {
          type: 'MultiPolygon',
          arcs: groups.map(function (polygons) {
            var arcs = [],
              n

            // Extract the exterior (unique) arcs.
            polygons.forEach(function (polygon) {
              polygon.forEach(function (ring) {
                ring.forEach(function (arc) {
                  if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                    arcs.push(arc)
                  }
                })
              })
            })

            // Stitch the arcs into one or more rings.
            arcs = (0, _stitch2.default)(topology, arcs)

            // If more than one ring is returned,
            // at most one of these rings can be the exterior;
            // choose the one with the greatest absolute area.
            if ((n = arcs.length) > 1) {
              for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                if ((ki = area(arcs[i])) > k) {
                  t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki
                }
              }
            }

            return arcs
          })
        }
      }
      /***/
    },
    /* 617 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (objects) {
        var indexesByArc = {},
          // arc index -> array of object indexes
          neighbors = objects.map(function () {
            return []
          })

        function line(arcs, i) {
          arcs.forEach(function (a) {
            if (a < 0) a = ~a
            var o = indexesByArc[a]
            if (o) o.push(i);
            else indexesByArc[a] = [i]
          })
        }

        function polygon(arcs, i) {
          arcs.forEach(function (arc) {
            line(arc, i)
          })
        }

        function geometry(o, i) {
          if (o.type === 'GeometryCollection') {
            o.geometries.forEach(function (o) {
              geometry(o, i)
            })
          } else if (o.type in geometryType) geometryType[o.type](o.arcs, i)
        }

        var geometryType = {
          LineString: line,
          MultiLineString: polygon,
          Polygon: polygon,
          MultiPolygon: function MultiPolygon(arcs, i) {
            arcs.forEach(function (arc) {
              polygon(arc, i)
            })
          }
        }

        objects.forEach(geometry)

        for (var i in indexesByArc) {
          for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
            for (var k = j + 1; k < m; ++k) {
              var ij = indexes[j],
                ik = indexes[k],
                n
              if ((n = neighbors[ij])[i = (0, _bisect2.default)(n, ik)] !== ik) n.splice(i, 0, ik)
              if ((n = neighbors[ik])[i = (0, _bisect2.default)(n, ij)] !== ij) n.splice(i, 0, ij)
            }
          }
        }

        return neighbors
      }

      var _bisect = __webpack_require__(618)

      var _bisect2 = _interopRequireDefault(_bisect)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 618 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, x) {
        var lo = 0,
          hi = a.length
        while (lo < hi) {
          var mid = lo + hi >>> 1
          if (a[mid] < x) lo = mid + 1;
          else hi = mid
        }
        return lo
      }
      /***/
    },
    /* 619 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (topology, transform) {
        if (topology.transform) throw new Error('already quantized')

        if (!transform || !transform.scale) {
          if (!((n = Math.floor(transform)) >= 2)) throw new Error('n must be 2')
          box = topology.bbox || (0, _bbox2.default)(topology)
          var x0 = box[0],
            y0 = box[1],
            x1 = box[2],
            y1 = box[3],
            n
          transform = {
            scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],
            translate: [x0, y0]
          }
        } else {
          box = topology.bbox
        }

        var t = (0, _untransform2.default)(transform),
          box,
          key,
          inputs = topology.objects,
          outputs = {}

        function quantizePoint(point) {
          return t(point)
        }

        function quantizeGeometry(input) {
          var output
          switch (input.type) {
            case 'GeometryCollection':
              output = {
                type: 'GeometryCollection',
                geometries: input.geometries.map(quantizeGeometry)
              };
              break
            case 'Point':
              output = {
                type: 'Point',
                coordinates: quantizePoint(input.coordinates)
              };
              break
            case 'MultiPoint':
              output = {
                type: 'MultiPoint',
                coordinates: input.coordinates.map(quantizePoint)
              };
              break
            default:
              return input
          }
          if (input.id != null) output.id = input.id
          if (input.bbox != null) output.bbox = input.bbox
          if (input.properties != null) output.properties = input.properties
          return output
        }

        function quantizeArc(input) {
          var i = 0,
            j = 1,
            n = input.length,
            p,
            output = new Array(n) // pessimistic
          output[0] = t(input[0], 0)
          while (++i < n) {
            if ((p = t(input[i], i))[0] || p[1]) output[j++] = p
          } // non-coincident points
          if (j === 1) output[j++] = [0, 0] // an arc must have at least two points
          output.length = j
          return output
        }

        for (key in inputs) {
          outputs[key] = quantizeGeometry(inputs[key])
        }
        return {
          type: 'Topology',
          bbox: box,
          transform: transform,
          objects: outputs,
          arcs: topology.arcs.map(quantizeArc)
        }
      }

      var _bbox = __webpack_require__(243)

      var _bbox2 = _interopRequireDefault(_bbox)

      var _untransform = __webpack_require__(246)

      var _untransform2 = _interopRequireDefault(_untransform)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 620 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      registerTransform('default', function (dataView) {
        return dataView
      })
      /***/
    },
    /* 621 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      /*
       * options: {
       *   type: 'filter',
       *   callback,
       * }
       */

      function defaultCallback(row) {
        return !!row
      }

      registerTransform('filter', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        dataView.rows = dataView.rows.filter(options.callback || defaultCallback)
      })
      /***/
    },
    /* 622 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var difference = __webpack_require__(623)
      var pick = __webpack_require__(69)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        fields: [],
        key: 'key',
        retains: [],
        value: 'value'
      }

      registerTransform('fold', function (dataView, options) {
        var columns = dataView.getColumnNames()
        options = assign({}, DEFAULT_OPTIONS, options)
        var fields = getFields(options)
        if (fields.length === 0) {
          console.warn('warning: option fields is not specified, will fold all columns.')
          fields = columns
        }
        var key = options.key
        var value = options.value
        var retains = options.retains
        if (retains.length === 0) {
          retains = difference(columns, fields)
        }
        var resultRows = []
        dataView.rows.forEach(function (row) {
          fields.forEach(function (field) {
            var resultRow = pick(row, retains)
            resultRow[key] = field
            resultRow[value] = row[field]
            resultRows.push(resultRow)
          })
        })
        dataView.rows = resultRows
      })
      /***/
    },
    /* 623 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseDifference = __webpack_require__(624),
        baseFlatten = __webpack_require__(106),
        baseRest = __webpack_require__(77),
        isArrayLikeObject = __webpack_require__(628)

      /**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */
      var difference = baseRest(function (array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []
      })

      module.exports = difference
      /***/
    },
    /* 624 */
    /***/
    function (module, exports, __webpack_require__) {
      var SetCache = __webpack_require__(102),
        arrayIncludes = __webpack_require__(247),
        arrayIncludesWith = __webpack_require__(248),
        arrayMap = __webpack_require__(68),
        baseUnary = __webpack_require__(82),
        cacheHas = __webpack_require__(103)

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200

      /**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length

        if (!length) {
          return result
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee))
        }
        if (comparator) {
          includes = arrayIncludesWith
          isCommon = false
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas
          isCommon = false
          values = new SetCache(values)
        }
        outer: while (++index < length) {
          var value = array[index],
            computed = iteratee == null ? value : iteratee(value)

          value = comparator || value !== 0 ? value : 0
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer
              }
            }
            result.push(value)
          } else if (!includes(values, computed, comparator)) {
            result.push(value)
          }
        }
        return result
      }

      module.exports = baseDifference
      /***/
    },
    /* 625 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFindIndex = __webpack_require__(201),
        baseIsNaN = __webpack_require__(626),
        strictIndexOf = __webpack_require__(627)

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
      }

      module.exports = baseIndexOf
      /***/
    },
    /* 626 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value
      }

      module.exports = baseIsNaN
      /***/
    },
    /* 627 */
    /***/
    function (module, exports) {
      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
          length = array.length

        while (++index < length) {
          if (array[index] === value) {
            return index
          }
        }
        return -1
      }

      module.exports = strictIndexOf
      /***/
    },
    /* 628 */
    /***/
    function (module, exports, __webpack_require__) {
      var isArrayLike = __webpack_require__(20),
        isObjectLike = __webpack_require__(15)

      /**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value)
      }

      module.exports = isArrayLikeObject
      /***/
    },
    /* 629 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      /*
       * options: {
       *   type: 'map',
       *   callback,
       * }
       */

      function defaultCallback(row) {
        return row
      }

      registerTransform('map', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        dataView.rows = dataView.rows.map(options.callback || defaultCallback)
      })
      /***/
    },
    /* 630 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var values = __webpack_require__(113)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var DEFAULT_OPTIONS = {
        groupBy: [], // optional
        orderBy: []
      }

      registerTransform('partition', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        options = assign({}, DEFAULT_OPTIONS, options)
        dataView.rows = partition(dataView.rows, options.groupBy, options.orderBy)
      })

      function group(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        options = assign({}, DEFAULT_OPTIONS, options)
        dataView.rows = values(partition(dataView.rows, options.groupBy, options.orderBy))
      }

      registerTransform('group', group)
      registerTransform('groups', group)
      /***/
    },
    /* 631 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(30),
        sum = _require.sum

      var partition = __webpack_require__(18)

      var _require2 = __webpack_require__(2),
        registerTransform = _require2.registerTransform

      var _require3 = __webpack_require__(6),
        getField = _require3.getField

      var DEFAULT_OPTIONS = {
        // field: 'y', // required
        // dimension: 'x', // required
        groupBy: [], // optional
        as: '_percent'
      }

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var dimension = options.dimension
        var groupBy = options.groupBy
        var as = options.as
        if (!isString(dimension)) {
          throw new TypeError('Invalid dimension: must be a string!')
        }
        if (Array.isArray(as)) {
          console.warn('Invalid as: must be a string, will use the first element of the array specified.')
          as = as[0]
        }
        if (!isString(as)) {
          throw new TypeError('Invalid as: must be a string!')
        }
        var rows = dataView.rows
        var result = []
        var groups = partition(rows, groupBy)
        forIn(groups, function (group) {
          var totalSum = sum(group.map(function (row) {
            return row[field]
          }))
          var innerGroups = partition(group, [dimension])
          forIn(innerGroups, function (innerGroup) {
            var innerSum = sum(innerGroup.map(function (row) {
              return row[field]
            }))
            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));
            var resultRow = innerGroup[0]
            // FIXME in case dimension and field is the same
            var dimensionValue = resultRow[dimension]
            resultRow[field] = innerSum
            resultRow[dimension] = dimensionValue
            resultRow[as] = innerSum / totalSum
            result.push(resultRow)
          })
        })
        dataView.rows = result
      }

      registerTransform('percent', transform)
      /***/
    },
    /* 632 */
    /***/
    function (module, exports, __webpack_require__) {
      var pick = __webpack_require__(69)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      /*
       * options: {
       *   type: 'pick',
       *   fields: [],
       * }
       */

      registerTransform('pick', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var columns = getFields(options, dataView.getColumnNames())
        dataView.rows = dataView.rows.map(function (row) {
          return pick(row, columns)
        })
      })
      /***/
    },
    /* 633 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var isString = __webpack_require__(7)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        // field: 'y', // required
        // dimension: 'x', // required
        groupBy: [], // optional
        as: '_proportion'
      }

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var dimension = options.dimension
        var groupBy = options.groupBy
        var as = options.as
        if (!isString(dimension)) {
          throw new TypeError('Invalid dimension: must be a string!')
        }
        if (Array.isArray(as)) {
          console.warn('Invalid as: must be a string, will use the first element of the array specified.')
          as = as[0]
        }
        if (!isString(as)) {
          throw new TypeError('Invalid as: must be a string!')
        }
        var rows = dataView.rows
        var result = []
        var groups = partition(rows, groupBy)
        forIn(groups, function (group) {
          var totalCount = group.length
          var innerGroups = partition(group, [dimension])
          forIn(innerGroups, function (innerGroup) {
            var innerCount = innerGroup.length
            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));
            var resultRow = innerGroup[0]
            // FIXME in case dimension and field is the same
            var dimensionValue = resultRow[dimension]
            resultRow[field] = innerCount
            resultRow[dimension] = dimensionValue
            resultRow[as] = innerCount / totalCount
            result.push(resultRow)
          })
        })
        dataView.rows = result
      }

      registerTransform('proportion', transform)
      /***/
    },
    /* 634 */
    /***/
    function (module, exports, __webpack_require__) {
      var forIn = __webpack_require__(11)
      var isPlainObject = __webpack_require__(635)
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      /*
       * options: {
       *   type: 'pick',
       *   fields: [],
       * }
       */

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var map = options.map || {}
        var cleanMap = {}
        if (isPlainObject(map)) {
          forIn(map, function (value, key) {
            if (isString(value) && isString(key)) {
              cleanMap[key] = value
            }
          })
        }
        dataView.rows.forEach(function (row) {
          forIn(map, function (newKey, key) {
            var temp = row[key]
            delete row[key]
            row[newKey] = temp
          })
        })
      }

      registerTransform('rename', transform)
      registerTransform('rename-fields', transform)
      /***/
    },
    /* 635 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseGetTag = __webpack_require__(19),
        getPrototype = __webpack_require__(100),
        isObjectLike = __webpack_require__(15)

      /** `Object#toString` result references. */
      var objectTag = '[object Object]'

      /** Used for built-in method references. */
      var funcProto = Function.prototype,
        objectProto = Object.prototype

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /** Used to infer the `Object` constructor. */
      var objectCtorString = funcToString.call(Object)

      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false
        }
        var proto = getPrototype(value)
        if (proto === null) {
          return true
        }
        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor
        return typeof Ctor === 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
      }

      module.exports = isPlainObject
      /***/
    },
    /* 636 */
    /***/
    function (module, exports, __webpack_require__) {
      var reverse = __webpack_require__(249)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      /*
       * options: {
       *   type: 'reverse',
       * }
       */

      registerTransform('reverse', function (dataView) {
        dataView.rows = reverse(dataView.rows)
      })
      /***/
    },
    /* 637 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      /*
       * options: {
       *   type: 'sort',
       *   callback,
       * }
       */

      registerTransform('sort', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var columnName = dataView.getColumnName(0)
        dataView.rows.sort(options.callback || function (a, b) {
          return a[columnName] - b[columnName]
        })
      })
      /***/
    },
    /* 638 */
    /***/
    function (module, exports, __webpack_require__) {
      var reverse = __webpack_require__(249)
      var sortBy = __webpack_require__(639)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      /*
       * options: {
       *   type: 'sort-by',
       *   fields: [],
       *   order: 'ASC' // 'DESC'
       * }
       */

      var VALID_ORDERS = ['ASC', 'DESC']

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var fields = getFields(options, [dataView.getColumnName(0)])
        if (!Array.isArray(fields)) {
          throw new TypeError('Invalid fields: must be an array with strings!')
        }
        dataView.rows = sortBy(dataView.rows, fields)
        var order = options.order
        if (order && VALID_ORDERS.indexOf(order) === -1) {
          throw new TypeError('Invalid order: ' + order + ' must be one of ' + VALID_ORDERS.join(', '))
        } else if (order === 'DESC') {
          dataView.rows = reverse(dataView.rows)
        }
      }
      registerTransform('sort-by', transform)
      registerTransform('sortBy', transform)
      /***/
    },
    /* 639 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseFlatten = __webpack_require__(106),
        baseOrderBy = __webpack_require__(640),
        baseRest = __webpack_require__(77),
        isIterateeCall = __webpack_require__(141)

      /**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
       */
      var sortBy = baseRest(function (collection, iteratees) {
        if (collection == null) {
          return []
        }
        var length = iteratees.length
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = []
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]]
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), [])
      })

      module.exports = sortBy
      /***/
    },
    /* 640 */
    /***/
    function (module, exports, __webpack_require__) {
      var arrayMap = __webpack_require__(68),
        baseIteratee = __webpack_require__(66),
        baseMap = __webpack_require__(641),
        baseSortBy = __webpack_require__(642),
        baseUnary = __webpack_require__(82),
        compareMultiple = __webpack_require__(643),
        identity = __webpack_require__(37)

      /**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */
      function baseOrderBy(collection, iteratees, orders) {
        var index = -1
        iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee))

        var result = baseMap(collection, function (value, key, collection) {
          var criteria = arrayMap(iteratees, function (iteratee) {
            return iteratee(value)
          })
          return {
            'criteria': criteria,
            'index': ++index,
            'value': value
          }
        })

        return baseSortBy(result, function (object, other) {
          return compareMultiple(object, other, orders)
        })
      }

      module.exports = baseOrderBy
      /***/
    },
    /* 641 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseEach = __webpack_require__(219),
        isArrayLike = __webpack_require__(20)

      /**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function baseMap(collection, iteratee) {
        var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : []

        baseEach(collection, function (value, key, collection) {
          result[++index] = iteratee(value, key, collection)
        })
        return result
      }

      module.exports = baseMap
      /***/
    },
    /* 642 */
    /***/
    function (module, exports) {
      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length

        array.sort(comparer)
        while (length--) {
          array[length] = array[length].value
        }
        return array
      }

      module.exports = baseSortBy
      /***/
    },
    /* 643 */
    /***/
    function (module, exports, __webpack_require__) {
      var compareAscending = __webpack_require__(644)

      /**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length

        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index])
          if (result) {
            if (index >= ordersLength) {
              return result
            }
            var order = orders[index]
            return result * (order == 'desc' ? -1 : 1)
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index
      }

      module.exports = compareMultiple
      /***/
    },
    /* 644 */
    /***/
    function (module, exports, __webpack_require__) {
      var isSymbol = __webpack_require__(43)

      /**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value)

          var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other)

          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1
          }
        }
        return 0
      }

      module.exports = compareAscending
      /***/
    },
    /* 645 */
    /***/
    function (module, exports, __webpack_require__) {
      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      /*
       * options: {
       *   type: 'subset',
       *   startRowIndex: 0,
       *   endRowIndex: 1,
       *   fields: [],
       * }
       */

      registerTransform('subset', function (dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var startIndex = options.startRowIndex || 0
        var endIndex = options.endRowIndex || dataView.rows.length - 1
        var columns = getFields(options, dataView.getColumnNames())
        dataView.rows = dataView.getSubset(startIndex, endIndex, columns)
      })
      /***/
    },
    /* 646 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var DEFAULT_OPTIONS = {
        fillBy: 'group', // group | order
        groupBy: [],
        orderBy: []
      }

      function arrayDifference(arr1, arr2) {
        // arrayDifference([1, 1, 1, 2], [1, 2]) => [1, 1]
        var shadow = arr1.map(function (item) {
          return item
        }) // shadow copy
        arr2.forEach(function (item) {
          var index = shadow.indexOf(item)
          if (index > -1) {
            shadow.splice(index, 1)
          }
        })
        return shadow
      }

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        options = assign({}, DEFAULT_OPTIONS, options)
        var rows = dataView.rows
        var groupBy = options.groupBy
        var orderBy = options.orderBy
        var groups = partition(rows, groupBy, orderBy)
        var maxLength = 0
        var referenceGroup = []
        forIn(groups, function (group) {
          if (group.length > maxLength) {
            maxLength = group.length
            referenceGroup = group
          }
        })
        var referenceOrderByKeys = []
        var referenceRowByOrderByKey = {}
        referenceGroup.forEach(function (row) {
          var key = orderBy.map(function (col) {
            return row[col]
          }).join('-')
          referenceOrderByKeys.push(key)
          referenceRowByOrderByKey[key] = row
        })
        if (options.fillBy === 'order') {
          var first = referenceGroup[0]
          var allOrderByKeys = []
          var rowByOrderByKey = {}
          rows.forEach(function (row) {
            var key = orderBy.map(function (col) {
              return row[col]
            }).join('-')
            if (allOrderByKeys.indexOf(key) === -1) {
              allOrderByKeys.push(key)
              rowByOrderByKey[key] = row
            }
          })
          var _missingOrderByKeys = arrayDifference(allOrderByKeys, referenceOrderByKeys)
          _missingOrderByKeys.forEach(function (key) {
            var row = {}
            groupBy.forEach(function (col) {
              row[col] = first[col]
            })
            orderBy.forEach(function (col) {
              row[col] = rowByOrderByKey[key][col]
            })
            rows.push(row)
            referenceGroup.push(row)
            referenceOrderByKeys.push(key)
            referenceRowByOrderByKey[key] = row
          })
          maxLength = referenceGroup.length
        }
        forIn(groups, function (group) {
          if (group !== referenceGroup && group.length < maxLength) {
            var _first = group[0]
            // missing orderBy keys
            var orderByKeys = []
            group.forEach(function (row) {
              orderByKeys.push(orderBy.map(function (col) {
                return row[col]
              }).join('-'))
            })
            var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys)
            missingOrderByKeys.some(function (key, i) {
              if (i >= maxLength - group.length) {
                // group length overflow
                return true
              }
              var referenceRow = referenceRowByOrderByKey[key]
              var row = {}
              groupBy.forEach(function (col) {
                row[col] = _first[col]
              })
              orderBy.forEach(function (col) {
                row[col] = referenceRow[col]
              })
              rows.push(row)
              return false
            })
          }
        })
      }

      registerTransform('fill-rows', transform)
      registerTransform('fillRows', transform)
      /***/
    },
    /* 647 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var has = __webpack_require__(648)
      var isFunction = __webpack_require__(8)
      var isNil = __webpack_require__(118)
      var isString = __webpack_require__(7)
      var simpleStatistics = __webpack_require__(30)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        // field: '', // required
        // method: 'value', // required
        // value: 10, // required if (method === 'value')
        groupBy: []
      }

      function notNilValues(values) {
        return values.filter(function (value) {
          return !isNil(value)
        })
      }

      var STATISTICS_METHODS = ['mean', 'median', 'max', 'min']
      var imputations = {}
      STATISTICS_METHODS.forEach(function (method) {
        imputations[method] = function (row, values) {
          return simpleStatistics[method](values)
        }
      })
      imputations.value = function (row, values, value) {
        return value
      }

      function transform(dataView) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}

        var rows = dataView.rows
        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var method = options.method
        var groupBy = options.groupBy
        if (!method) {
          throw new TypeError('Invalid method!')
        }
        if (method === 'value' && !has(options, 'value')) {
          throw new TypeError('Invalid value: it is nil.')
        }
        var column = notNilValues(dataView.getColumn(field))
        var groups = partition(rows, groupBy)
        forIn(groups, function (group) {
          var fieldValues = notNilValues(group.map(function (row) {
            return row[field]
          }))
          if (fieldValues.length === 0) {
            fieldValues = column
          }
          group.forEach(function (row) {
            if (isNil(row[field])) {
              if (isFunction(method)) {
                row[field] = method(row, fieldValues, options.value, group)
              } else if (isString(method)) {
                row[field] = imputations[method](row, fieldValues, options.value)
              } else {
                throw new TypeError('Invalid method: must be a function or one of ' + STATISTICS_METHODS.join(', '))
              }
            }
          })
        })
      }

      registerTransform('impute', transform)
      /***/
    },
    /* 648 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseHas = __webpack_require__(649),
        hasPath = __webpack_require__(200)

      /**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas)
      }

      module.exports = has
      /***/
    },
    /* 649 */
    /***/
    function (module, exports) {
      /** Used for built-in method references. */
      var objectProto = Object.prototype

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty

      /**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key)
      }

      module.exports = baseHas
      /***/
    },
    /* 650 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var keys = __webpack_require__(9)
      var isString = __webpack_require__(7)
      var uniq = __webpack_require__(651)
      var simpleStatistics = __webpack_require__(30)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        as: [],
        fields: [],
        groupBy: [],
        operations: []
      }
      var DEFAULT_OPERATION = 'count'

      var aggregates = {
        count: function count(data) {
          return data.length
        },
        distinct: function distinct(data, field) {
          var values = uniq(data.map(function (row) {
            return row[field]
          }))
          return values.length
        }
      }
      var STATISTICS_METHODS = ['max', 'mean', // alias: average
        'median', 'min', 'mode', 'product', 'standardDeviation', 'sum', 'sumSimple', 'variance'
      ]
      STATISTICS_METHODS.forEach(function (method) {
        aggregates[method] = function (data, field) {
          var values = data.map(function (row) {
            return row[field]
          })
          return simpleStatistics[method](values)
        }
      })
      aggregates.average = aggregates.mean

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var rows = dataView.rows
        var dims = options.groupBy
        var fields = getFields(options)
        if (!Array.isArray(fields)) {
          throw new TypeError('Invalid fields: it must be an array with one or more strings!')
        }
        var outputNames = options.as || []
        if (isString(outputNames)) {
          outputNames = [outputNames]
        }
        var operations = options.operations
        if (isString(operations)) {
          operations = [operations]
        }
        var DEFAULT_OPERATIONS = [DEFAULT_OPERATION]
        if (!Array.isArray(operations) || !operations.length) {
          console.warn('operations is not defined, will use [ "count" ] directly.')
          operations = DEFAULT_OPERATIONS
          outputNames = operations
        }
        if (!(operations.length === 1 && operations[0] === DEFAULT_OPERATION)) {
          if (operations.length !== fields.length) {
            throw new TypeError('Invalid operations: it\'s length must be the same as fields!')
          }
          if (outputNames.length !== fields.length) {
            throw new TypeError('Invalid as: it\'s length must be the same as fields!')
          }
        }
        var groups = partition(rows, dims)
        var results = []
        forIn(groups, function (group) {
          // const result = pick(group[0], dims);
          var result = group[0]
          operations.forEach(function (operation, i) {
            var outputName = outputNames[i]
            var field = fields[i]
            result[outputName] = aggregates[operation](group, field)
          })
          results.push(result)
        })
        dataView.rows = results
      }

      registerTransform('aggregate', transform)
      registerTransform('summary', transform)

      module.exports = {
        VALID_AGGREGATES: keys(aggregates)
      }
      /***/
    },
    /* 651 */
    /***/
    function (module, exports, __webpack_require__) {
      var baseUniq = __webpack_require__(652)

      /**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */
      function uniq(array) {
        return array && array.length ? baseUniq(array) : []
      }

      module.exports = uniq
      /***/
    },
    /* 652 */
    /***/
    function (module, exports, __webpack_require__) {
      var SetCache = __webpack_require__(102),
        arrayIncludes = __webpack_require__(247),
        arrayIncludesWith = __webpack_require__(248),
        cacheHas = __webpack_require__(103),
        createSet = __webpack_require__(653),
        setToArray = __webpack_require__(65)

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200

      /**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */
      function baseUniq(array, iteratee, comparator) {
        var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result

        if (comparator) {
          isCommon = false
          includes = arrayIncludesWith
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array)
          if (set) {
            return setToArray(set)
          }
          isCommon = false
          includes = cacheHas
          seen = new SetCache()
        } else {
          seen = iteratee ? [] : result
        }
        outer: while (++index < length) {
          var value = array[index],
            computed = iteratee ? iteratee(value) : value

          value = comparator || value !== 0 ? value : 0
          if (isCommon && computed === computed) {
            var seenIndex = seen.length
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer
              }
            }
            if (iteratee) {
              seen.push(computed)
            }
            result.push(value)
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed)
            }
            result.push(value)
          }
        }
        return result
      }

      module.exports = baseUniq
      /***/
    },
    /* 653 */
    /***/
    function (module, exports, __webpack_require__) {
      var Set = __webpack_require__(188),
        noop = __webpack_require__(654),
        setToArray = __webpack_require__(65)

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0

      /**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */
      var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
        return new Set(values)
      }

      module.exports = createSet
      /***/
    },
    /* 654 */
    /***/
    function (module, exports) {
      /**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */
      function noop() {
        // No operation performed.
      }

      module.exports = noop
      /***/
    },
    /* 655 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var isNumber = __webpack_require__(126)
      var regression = __webpack_require__(656)
      var getSeriesValues = __webpack_require__(127)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var _require3 = __webpack_require__(128),
        silverman = _require3.silverman

      var DEFAULT_OPTIONS = {
        as: ['x', 'y'],
        // fields: [ 'x', 'y' ], // required two fields
        method: 'linear', // regression method: linear, exponential, logarithmic, power, polynomial
        // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]
        // bandwidth: 1, // bandWidth to execute regression function
        order: 2, // order of the polynomial curve
        precision: 2 // the number of significant figures the output is rounded to
      }

      var REGRESSION_METHODS = ['linear', 'exponential', 'logarithmic', 'power', 'polynomial']

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var fields = getFields(options)
        if (!Array.isArray(fields) || fields.length !== 2) {
          throw new TypeError('invalid fields: must be an array of 2 strings.')
        }
        var xField = fields[0],
          yField = fields[1]

        var method = options.method
        if (REGRESSION_METHODS.indexOf(method) === -1) {
          throw new TypeError('invalid method: ' + method + '. Must be one of ' + REGRESSION_METHODS.join(', '))
        }
        var points = dataView.rows.map(function (row) {
          return [row[xField], row[yField]]
        })
        var regressionResult = regression[method](points, options)
        var extent = options.extent
        if (!Array.isArray(extent) || extent.length !== 2) {
          extent = dataView.range(xField)
        }
        var bandwidth = options.bandwidth
        if (!isNumber(bandwidth) || bandwidth <= 0) {
          bandwidth = silverman(dataView.getColumn(xField))
        }
        var valuesToPredict = getSeriesValues(extent, bandwidth)
        var result = []
        var _options$as = options.as,
          asX = _options$as[0],
          asY = _options$as[1]

        valuesToPredict.forEach(function (value) {
          var row = {}

          var _regressionResult$pre = regressionResult.predict(value),
            x = _regressionResult$pre[0],
            y = _regressionResult$pre[1]

          row[asX] = x
          row[asY] = y
          if (isFinite(y)) {
            result.push(row)
          }
        })
        dataView.rows = result
      }

      registerTransform('regression', transform)

      module.exports = {
        REGRESSION_METHODS: REGRESSION_METHODS
      }
      /***/
    },
    /* 656 */
    /***/
    function (module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      (function (global, factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
            __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
              (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        } else if (typeof exports !== 'undefined') {
          factory(module)
        } else {
          var mod = {
            exports: {}
          }
          factory(mod)
          global.regression = mod.exports
        }
      })(undefined, function (module) {
        'use strict'

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            })
          } else {
            obj[key] = value
          }

          return obj
        }

        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i]

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key]
              }
            }
          }

          return target
        }

        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i]
            }

            return arr2
          } else {
            return Array.from(arr)
          }
        }

        var DEFAULT_OPTIONS = {
          order: 2,
          precision: 2,
          period: null
        }

        /**
         * Determine the coefficient of determination (r^2) of a fit from the observations
         * and predictions.
         *
         * @param {Array<Array<number>>} data - Pairs of observed x-y values
         * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values
         *
         * @return {number} - The r^2 value, or NaN if one cannot be calculated.
         */
        function determinationCoefficient(data, results) {
          var predictions = []
          var observations = []

          data.forEach(function (d, i) {
            if (d[1] !== null) {
              observations.push(d)
              predictions.push(results[i])
            }
          })

          var sum = observations.reduce(function (a, observation) {
            return a + observation[1]
          }, 0)
          var mean = sum / observations.length

          var ssyy = observations.reduce(function (a, observation) {
            var difference = observation[1] - mean
            return a + difference * difference
          }, 0)

          var sse = observations.reduce(function (accum, observation, index) {
            var prediction = predictions[index]
            var residual = observation[1] - prediction[1]
            return accum + residual * residual
          }, 0)

          return 1 - sse / ssyy
        }

        /**
         * Determine the solution of a system of linear equations A * x = b using
         * Gaussian elimination.
         *
         * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]
         * @param {number} order - How many degrees to solve for
         *
         * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)
         */
        function gaussianElimination(input, order) {
          var matrix = input
          var n = input.length - 1
          var coefficients = [order]

          for (var i = 0; i < n; i++) {
            var maxrow = i
            for (var j = i + 1; j < n; j++) {
              if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {
                maxrow = j
              }
            }

            for (var k = i; k < n + 1; k++) {
              var tmp = matrix[k][i]
              matrix[k][i] = matrix[k][maxrow]
              matrix[k][maxrow] = tmp
            }

            for (var _j = i + 1; _j < n; _j++) {
              for (var _k = n; _k >= i; _k--) {
                matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i]
              }
            }
          }

          for (var _j2 = n - 1; _j2 >= 0; _j2--) {
            var total = 0
            for (var _k2 = _j2 + 1; _k2 < n; _k2++) {
              total += matrix[_k2][_j2] * coefficients[_k2]
            }

            coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2]
          }

          return coefficients
        }

        /**
         * Round a number to a precision, specificed in number of decimal places
         *
         * @param {number} number - The number to round
         * @param {number} precision - The number of decimal places to round to:
         *                             > 0 means decimals, < 0 means powers of 10
         *
         *
         * @return {numbr} - The number, rounded
         */
        function round(number, precision) {
          var factor = Math.pow(10, precision)
          return Math.round(number * factor) / factor
        }

        /**
         * The set of all fitting methods
         *
         * @namespace
         */
        var methods = {
          linear: function linear(data, options) {
            var sum = [0, 0, 0, 0, 0]
            var len = 0

            for (var n = 0; n < data.length; n++) {
              if (data[n][1] !== null) {
                len++
                sum[0] += data[n][0]
                sum[1] += data[n][1]
                sum[2] += data[n][0] * data[n][0]
                sum[3] += data[n][0] * data[n][1]
                sum[4] += data[n][1] * data[n][1]
              }
            }

            var run = len * sum[2] - sum[0] * sum[0]
            var rise = len * sum[3] - sum[0] * sum[1]
            var gradient = run === 0 ? 0 : round(rise / run, options.precision)
            var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision)

            var predict = function predict(x) {
              return [round(x, options.precision), round(gradient * x + intercept, options.precision)]
            }

            var points = data.map(function (point) {
              return predict(point[0])
            })

            return {
              points: points,
              predict: predict,
              equation: [gradient, intercept],
              r2: round(determinationCoefficient(data, points), options.precision),
              string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept
            }
          },
          exponential: function exponential(data, options) {
            var sum = [0, 0, 0, 0, 0, 0]

            for (var n = 0; n < data.length; n++) {
              if (data[n][1] !== null) {
                sum[0] += data[n][0]
                sum[1] += data[n][1]
                sum[2] += data[n][0] * data[n][0] * data[n][1]
                sum[3] += data[n][1] * Math.log(data[n][1])
                sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1])
                sum[5] += data[n][0] * data[n][1]
              }
            }

            var denominator = sum[1] * sum[2] - sum[5] * sum[5]
            var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator)
            var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator
            var coeffA = round(a, options.precision)
            var coeffB = round(b, options.precision)
            var predict = function predict(x) {
              return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)]
            }

            var points = data.map(function (point) {
              return predict(point[0])
            })

            return {
              points: points,
              predict: predict,
              equation: [coeffA, coeffB],
              string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',
              r2: round(determinationCoefficient(data, points), options.precision)
            }
          },
          logarithmic: function logarithmic(data, options) {
            var sum = [0, 0, 0, 0]
            var len = data.length

            for (var n = 0; n < len; n++) {
              if (data[n][1] !== null) {
                sum[0] += Math.log(data[n][0])
                sum[1] += data[n][1] * Math.log(data[n][0])
                sum[2] += data[n][1]
                sum[3] += Math.pow(Math.log(data[n][0]), 2)
              }
            }

            var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0])
            var coeffB = round(a, options.precision)
            var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision)

            var predict = function predict(x) {
              return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)]
            }

            var points = data.map(function (point) {
              return predict(point[0])
            })

            return {
              points: points,
              predict: predict,
              equation: [coeffA, coeffB],
              string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',
              r2: round(determinationCoefficient(data, points), options.precision)
            }
          },
          power: function power(data, options) {
            var sum = [0, 0, 0, 0, 0]
            var len = data.length

            for (var n = 0; n < len; n++) {
              if (data[n][1] !== null) {
                sum[0] += Math.log(data[n][0])
                sum[1] += Math.log(data[n][1]) * Math.log(data[n][0])
                sum[2] += Math.log(data[n][1])
                sum[3] += Math.pow(Math.log(data[n][0]), 2)
              }
            }

            var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2))
            var a = (sum[2] - b * sum[0]) / len
            var coeffA = round(Math.exp(a), options.precision)
            var coeffB = round(b, options.precision)

            var predict = function predict(x) {
              return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)]
            }

            var points = data.map(function (point) {
              return predict(point[0])
            })

            return {
              points: points,
              predict: predict,
              equation: [coeffA, coeffB],
              string: 'y = ' + coeffA + 'x^' + coeffB,
              r2: round(determinationCoefficient(data, points), options.precision)
            }
          },
          polynomial: function polynomial(data, options) {
            var lhs = []
            var rhs = []
            var a = 0
            var b = 0
            var len = data.length
            var k = options.order + 1

            for (var i = 0; i < k; i++) {
              for (var l = 0; l < len; l++) {
                if (data[l][1] !== null) {
                  a += Math.pow(data[l][0], i) * data[l][1]
                }
              }

              lhs.push(a)
              a = 0

              var c = []
              for (var j = 0; j < k; j++) {
                for (var _l = 0; _l < len; _l++) {
                  if (data[_l][1] !== null) {
                    b += Math.pow(data[_l][0], i + j)
                  }
                }
                c.push(b)
                b = 0
              }
              rhs.push(c)
            }
            rhs.push(lhs)

            var coefficients = gaussianElimination(rhs, k).map(function (v) {
              return round(v, options.precision)
            })

            var predict = function predict(x) {
              return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {
                return sum + coeff * Math.pow(x, power)
              }, 0), options.precision)]
            }

            var points = data.map(function (point) {
              return predict(point[0])
            })

            var string = 'y = '
            for (var _i = coefficients.length - 1; _i >= 0; _i--) {
              if (_i > 1) {
                string += coefficients[_i] + 'x^' + _i + ' + '
              } else if (_i === 1) {
                string += coefficients[_i] + 'x + '
              } else {
                string += coefficients[_i]
              }
            }

            return {
              string: string,
              points: points,
              predict: predict,
              equation: [].concat(_toConsumableArray(coefficients)).reverse(),
              r2: round(determinationCoefficient(data, points), options.precision)
            }
          }
        }

        function createWrapper() {
          var reduce = function reduce(accumulator, name) {
            return _extends({
              _round: round
            }, accumulator, _defineProperty({}, name, function (data, supplied) {
              return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied))
            }))
          }

          return Object.keys(methods).reduce(reduce, {})
        }

        module.exports = createWrapper()
      })
      /***/
    },
    /* 657 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        as: ['x', 'y', 'count'],
        bins: [30, 30], // Numeric vector giving number of bins in both horizontal and vertical directions
        offset: [0, 0],
        sizeByCount: false // calculate bin size by binning count
        // fields: ['field0', 'field1'], // required
        // binWidth: [ 30, 30 ], // Numeric vector giving bin width in both horizontal and vertical directions. Overrides bins if both set.
      }
      var SQRT3 = Math.sqrt(3)
      var THIRD_PI = Math.PI / 3
      var ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI]

      function distance(x0, y0, x1, y1) {
        return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1))
      }

      function nearestBinsCenters(value, scale, offset) {
        var temp = value - offset
        scale = scale / 2
        var div = Math.floor(temp / scale)
        var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0))
        var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1))
        return [rounded + offset, roundedScaled + offset]
      }

      function generateBins(points) {
        var binWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1]
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0]
        // processing aligned data
        var bins = {}
        var binWidthX = binWidth[0],
          binWidthY = binWidth[1]
        var offsetX = offset[0],
          offsetY = offset[1]

        points.forEach(function (point) {
          var x = point[0],
            y = point[1]
          // step3.1: nearest two centers

          var _nearestBinsCenters = nearestBinsCenters(x, binWidthX, offsetX),
            xRounded = _nearestBinsCenters[0],
            xRoundedScaled = _nearestBinsCenters[1]

          var _nearestBinsCenters2 = nearestBinsCenters(y, binWidthY, offsetY),
            yRounded = _nearestBinsCenters2[0],
            yRoundedScaled = _nearestBinsCenters2[1]
          // step3.2: compare distances

          var d1 = distance(x, y, xRounded, yRounded)
          var d2 = distance(x, y, xRoundedScaled, yRoundedScaled)
          var binKey = void 0
          var binX = void 0
          var binY = void 0

          if (d1 < d2) {
            binKey = 'x' + xRounded + 'y' + yRounded
            binX = xRounded
            binY = yRounded
          } else {
            binKey = 'x' + xRoundedScaled + 'y' + yRoundedScaled
            binX = xRoundedScaled
            binY = yRoundedScaled
          }
          bins[binKey] = bins[binKey] || {
            x: binX,
            y: binY,
            count: 0
          }
          bins[binKey].count++
        })
        return bins
      }

      function transform(dataView, options) {
        // step1: get binWidth, etc.
        options = assign({}, DEFAULT_OPTIONS, options)
        var fields = getFields(options)
        if (!Array.isArray(fields) || fields.length !== 2) {
          throw new TypeError('Invalid fields: it must be an array with 2 strings!')
        }
        var fieldX = fields[0],
          fieldY = fields[1]

        var rangeFieldX = dataView.range(fieldX)
        var rangeFieldY = dataView.range(fieldY)
        var widthX = rangeFieldX[1] - rangeFieldX[0]
        var widthY = rangeFieldY[1] - rangeFieldY[0]
        var binWidth = options.binWidth || []
        if (binWidth.length !== 2) {
          var _options$bins = options.bins,
            binsX = _options$bins[0],
            binsY = _options$bins[1]

          if (binsX <= 0 || binsY <= 0) {
            throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!')
          }
          binWidth = [widthX / binsX, widthY / binsY]
        }
        // step2: align scale (squash Y)
        /*
         * binWidthX / binWidthY should be Math.sqrt3 / 1.5
         * -: binWidthX |: binWidthY
         *           3
         *           |
         *   4       |        2
         *           |
         *           |
         *   5----------------1
         *
         *           0
         */
        var _options$offset = options.offset,
          offsetX = _options$offset[0],
          offsetY = _options$offset[1]

        var yScale = 3 * binWidth[0] / (SQRT3 * binWidth[1])
        // const yScale = binWidth[0] / (SQRT3 * binWidth[1]);
        var points = dataView.rows.map(function (row) {
          return [row[fieldX], yScale * row[fieldY]]
        })
        // step3: binning
        var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY])
        // step4: restore scale (for Y)
        var _options$as = options.as,
          asX = _options$as[0],
          asY = _options$as[1],
          asCount = _options$as[2]

        if (!asX || !asY || !asCount) {
          throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ "x", "y", "count" ])!')
        }
        var radius = binWidth[0] / SQRT3
        var hexagonPoints = ANGLES.map(function (angle) {
          return [Math.sin(angle) * radius, -Math.cos(angle) * radius]
        })
        var result = []
        var maxCount = 0
        if (options.sizeByCount) {
          forIn(bins, function (bin) {
            if (bin.count > maxCount) {
              maxCount = bin.count
            }
          })
        }
        forIn(bins, function (bin) {
          var x = bin.x,
            y = bin.y,
            count = bin.count

          var row = {}
          row[asCount] = count
          if (options.sizeByCount) {
            row[asX] = hexagonPoints.map(function (p) {
              return x + bin.count / maxCount * p[0]
            })
            row[asY] = hexagonPoints.map(function (p) {
              return (y + bin.count / maxCount * p[1]) / yScale
            })
          } else {
            row[asX] = hexagonPoints.map(function (p) {
              return x + p[0]
            })
            row[asY] = hexagonPoints.map(function (p) {
              return (y + p[1]) / yScale
            })
          }
          result.push(row)
        })

        dataView.rows = result
      }

      registerTransform('bin.hexagon', transform)
      registerTransform('bin.hex', transform)
      registerTransform('hexbin', transform)
      /***/
    },
    /* 658 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var pick = __webpack_require__(69)
      var partition = __webpack_require__(18)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        as: ['x', 'count'],
        bins: 30,
        offset: 0,
        groupBy: []
        // field: '', // required
        // binWidth: 10, // override bins
      }

      function nearestBin(value, scale, offset) {
        var temp = value - offset
        var div = Math.floor(temp / scale)
        return [div * scale + offset, (div + 1) * scale + offset]
      }

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var range = dataView.range(field)
        var width = range[1] - range[0]
        var binWidth = options.binWidth
        if (!binWidth) {
          var bins = options.bins
          if (bins <= 0) {
            throw new TypeError('Invalid bins: it must be a positive number!')
          }
          binWidth = width / bins
        }
        var offset = options.offset % binWidth

        // grouping
        var rows = []
        var groupBy = options.groupBy
        var groups = partition(dataView.rows, groupBy)
        forIn(groups, function (group) {
          var bins = {}
          var column = group.map(function (row) {
            return row[field]
          })
          column.forEach(function (value) {
            var _nearestBin = nearestBin(value, binWidth, offset),
              x0 = _nearestBin[0],
              x1 = _nearestBin[1]

            var binKey = x0 + '-' + x1
            bins[binKey] = bins[binKey] || {
              x0: x0,
              x1: x1,
              count: 0
            }
            bins[binKey].count++
          })
          var _options$as = options.as,
            asX = _options$as[0],
            asCount = _options$as[1]

          if (!asX || !asCount) {
            throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ "x", "count" ])!')
          }

          var meta = pick(group[0], groupBy)
          forIn(bins, function (bin) {
            var row = assign({}, meta)
            row[asX] = [bin.x0, bin.x1]
            row[asCount] = bin.count
            rows.push(row)
          })
        })
        dataView.rows = rows
      }

      registerTransform('bin.histogram', transform)
      registerTransform('bin.dot', transform)
      /***/
    },
    /* 659 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var isString = __webpack_require__(7)
      // const pick = require('lodash/pick');

      var _require = __webpack_require__(30),
        quantile = _require.quantile

      var partition = __webpack_require__(18)
      var pByFraction = __webpack_require__(236)

      var _require2 = __webpack_require__(2),
        registerTransform = _require2.registerTransform

      var _require3 = __webpack_require__(6),
        getField = _require3.getField

      var DEFAULT_OPTIONS = {
        as: '_bin',
        groupBy: [], // optional
        fraction: 4 // default
        // p: [0.5, 0.3], // array of p parameter
        // field: 'y', // required
      }

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var as = options.as
        if (!isString(as)) {
          throw new TypeError('Invalid as: it must be a string (e.g. "_bin")!')
        }
        var pArray = options.p
        var fraction = options.fraction
        if (!Array.isArray(pArray) || pArray.length === 0) {
          pArray = pByFraction(fraction)
        }
        var rows = dataView.rows
        var groupBy = options.groupBy
        var groups = partition(rows, groupBy)
        var result = []
        forIn(groups, function (group) {
          // const resultRow = pick(group[0], groupBy);
          var resultRow = group[0]
          var binningColumn = group.map(function (row) {
            return row[field]
          })
          var quantiles = pArray.map(function (p) {
            return quantile(binningColumn, p)
          })
          resultRow[as] = quantiles
          result.push(resultRow)
        })
        dataView.rows = result
      }

      registerTransform('bin.quantile', transform)
      /***/
    },
    /* 660 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        as: ['x', 'y', 'count'],
        bins: [30, 30], // Numeric vector giving number of bins in both horizontal and vertical directions
        offset: [0, 0],
        sizeByCount: false // calculate bin size by binning count
        // fields: ['field0', 'field1'], // required
        // binWidth: [ 30, 30 ], // Numeric vector giving bin width in both horizontal and vertical directions. Overrides bins if both set.
      }

      function nearestBin(value, scale, offset) {
        var temp = value - offset
        var div = Math.floor(temp / scale)
        return [div * scale + offset, (div + 1) * scale + offset]
      }

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)

        var _getFields = getFields(options),
          fieldX = _getFields[0],
          fieldY = _getFields[1]

        if (!fieldX || !fieldY) {
          throw new TypeError('Invalid fields: must be an array with 2 strings!')
        }
        var rangeFieldX = dataView.range(fieldX)
        var rangeFieldY = dataView.range(fieldY)
        var widthX = rangeFieldX[1] - rangeFieldX[0]
        var widthY = rangeFieldY[1] - rangeFieldY[0]
        var binWidth = options.binWidth || []
        if (binWidth.length !== 2) {
          var _options$bins = options.bins,
            binsX = _options$bins[0],
            binsY = _options$bins[1]

          if (binsX <= 0 || binsY <= 0) {
            throw new TypeError('Invalid bins: must be an array with 2 positive numbers (e.g. [ 30, 30 ])!')
          }
          binWidth = [widthX / binsX, widthY / binsY]
        }
        var points = dataView.rows.map(function (row) {
          return [row[fieldX], row[fieldY]]
        })
        var bins = {}
        var _options$offset = options.offset,
          offsetX = _options$offset[0],
          offsetY = _options$offset[1]

        points.forEach(function (point) {
          var _nearestBin = nearestBin(point[0], binWidth[0], offsetX),
            x0 = _nearestBin[0],
            x1 = _nearestBin[1]

          var _nearestBin2 = nearestBin(point[1], binWidth[1], offsetY),
            y0 = _nearestBin2[0],
            y1 = _nearestBin2[1]

          var binKey = x0 + '-' + x1 + '-' + y0 + '-' + y1
          bins[binKey] = bins[binKey] || {
            x0: x0,
            x1: x1,
            y0: y0,
            y1: y1,
            count: 0
          }
          bins[binKey].count++
        })
        var rows = []
        var _options$as = options.as,
          asX = _options$as[0],
          asY = _options$as[1],
          asCount = _options$as[2]

        if (!asX || !asY || !asCount) {
          throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "count" ])!')
        }
        /* points
         * 3---2
         * |   |
         * 0---1
         */
        if (!options.sizeByCount) {
          forIn(bins, function (bin) {
            var row = {}
            row[asX] = [bin.x0, bin.x1, bin.x1, bin.x0]
            row[asY] = [bin.y0, bin.y0, bin.y1, bin.y1]
            row[asCount] = bin.count
            rows.push(row)
          })
        } else {
          var maxCount = 0
          forIn(bins, function (bin) {
            if (bin.count > maxCount) {
              maxCount = bin.count
            }
          })
          forIn(bins, function (bin) {
            var x0 = bin.x0,
              x1 = bin.x1,
              y0 = bin.y0,
              y1 = bin.y1,
              count = bin.count

            var scale = count / maxCount
            var cx = (x0 + x1) / 2,
              cy = (y0 + y1) / 2

            var rx = (x1 - x0) * scale / 2
            var ry = (y1 - y0) * scale / 2
            var x01 = cx - rx
            var x11 = cx + rx
            var y01 = cy - ry
            var y11 = cy + ry
            var row = {}
            row[asX] = [x01, x11, x11, x01]
            row[asY] = [y01, y01, y11, y11]
            row[asCount] = count
            rows.push(row)
          })
        }
        dataView.rows = rows
      }

      registerTransform('bin.rectangle', transform)
      registerTransform('bin.rect', transform)
      /***/
    },
    /* 661 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        // field: 'name', // required
        // geoView: view, // required
        // geoDataView: view, // alias
        as: ['_centroid_x', '_centroid_y']
      }

      function transform(view, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var geoView = options.geoView || options.geoDataView // alias
        if (isString(geoView)) {
          geoView = view.dataSet.getView(geoView)
        }
        if (!geoView || geoView.dataType !== 'geo') {
          throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!')
        }
        var as = options.as
        if (!Array.isArray(as) || as.length !== 2) {
          throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "cX", "cY" ])!')
        }

        var centroidX = as[0]
        var centroidY = as[1]
        view.rows.forEach(function (row) {
          var feature = geoView.geoFeatureByName(row[field])
          if (feature) {
            if (geoView._projectedAs) {
              row[centroidX] = feature[geoView._projectedAs[2]]
              row[centroidY] = feature[geoView._projectedAs[3]]
            } else {
              row[centroidX] = feature.centroidX
              row[centroidY] = feature.centroidY
            }
          }
        })
      }

      registerTransform('geo.centroid', transform)
      /***/
    },
    /* 662 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var d3Geo = __webpack_require__(0)
      var getPointAtLength = __webpack_require__(238)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var getGeoProjection = __webpack_require__(203)

      var geoPath = d3Geo.geoPath

      var DEFAULT_OPTIONS = {
        // projection: '', // default to null
        as: ['_x', '_y', '_centroid_x', '_centroid_y']
      }

      function transform(dataView, options) {
        if (dataView.dataType !== 'geo' && dataView.dataType !== 'geo-graticule') {
          throw new TypeError('Invalid dataView: this transform is for Geo data only!')
        }
        options = assign({}, DEFAULT_OPTIONS, options)
        var projection = options.projection
        if (!projection) {
          throw new TypeError('Invalid projection!')
        }
        projection = getGeoProjection(projection)
        var geoPathGenerator = geoPath(projection)
        var as = options.as
        if (!Array.isArray(as) || as.length !== 4) {
          throw new TypeError('Invalid as: it must be an array with 4 strings (e.g. [ "x", "y", "cX", "cY" ])!')
        }
        dataView._projectedAs = as
        var lonField = as[0],
          latField = as[1],
          centroidX = as[2],
          centroidY = as[3]

        dataView.rows.forEach(function (row) {
          row[lonField] = []
          row[latField] = []
          var pathData = geoPathGenerator(row)
          if (pathData) {
            // TODO projection returns null
            var points = getPointAtLength(pathData)
            points._path.forEach(function (point) {
              row[lonField].push(point[1])
              row[latField].push(point[2])
            })
            var centroid = geoPathGenerator.centroid(row)
            row[centroidX] = centroid[0]
            row[centroidY] = centroid[1]
          }
        })
        dataView.rows = dataView.rows.filter(function (row) {
          return row[lonField].length !== 0
        })
      }

      registerTransform('geo.projection', transform)
      /***/
    },
    /* 663 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        // field: 'name', // required
        // geoView: view, // required
        // geoDataView: view, // alias
        as: ['_x', '_y']
      }

      function transform(view, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var field = getField(options)
        var geoView = options.geoView || options.geoDataView // alias
        if (isString(geoView)) {
          geoView = view.dataSet.getView(geoView)
        }
        if (!geoView || geoView.dataType !== 'geo') {
          throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!')
        }
        var as = options.as
        if (!Array.isArray(as) || as.length !== 2) {
          throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!')
        }
        var lonField = as[0]
        var latField = as[1]
        view.rows.forEach(function (row) {
          var feature = geoView.geoFeatureByName(row[field])
          if (feature) {
            if (geoView._projectedAs) {
              row[lonField] = feature[geoView._projectedAs[0]]
              row[latField] = feature[geoView._projectedAs[1]]
            } else {
              row[lonField] = feature.longitude
              row[latField] = feature.latitude
            }
          }
        })
      }

      registerTransform('geo.region', transform)
      /***/
    },
    /* 664 */
    /***/
    function (module, exports, __webpack_require__) {
      /*
       * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)
       * graph data required (nodes, edges)
       */
      var assign = __webpack_require__(5)
      var forIn = __webpack_require__(11)
      var values = __webpack_require__(113)
      var isFunction = __webpack_require__(8)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var DEFAULT_OPTIONS = {
        y: 0,
        thickness: 0.05, // thickness of the node, (0, 1)
        weight: false,
        marginRatio: 0.1, // margin ratio, [0, 1)
        id: function id(node) {
          return node.id
        },
        source: function source(edge) {
          return edge.source
        },
        target: function target(edge) {
          return edge.target
        },
        sourceWeight: function sourceWeight(edge) {
          return edge.value || 1
        },
        targetWeight: function targetWeight(edge) {
          return edge.value || 1
        },
        sortBy: null // optional, id | weight | frequency | {function}
      }

      function _nodesFromEdges(edges, options) {
        var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}

        edges.forEach(function (edge) {
          var sId = options.edgeSource(edge)
          var tId = options.edgeTarget(edge)
          if (!map[sId]) {
            map[sId] = {
              id: sId
            }
          }
          if (!map[tId]) {
            map[tId] = {
              id: tId
            }
          }
        })
        return values(map)
      }

      function _processGraph(nodeById, edges, options) {
        forIn(nodeById, function (node, id) {
          // in edges, out edges
          node.inEdges = edges.filter(function (edge) {
            return '' + options.target(edge) === '' + id
          })
          node.outEdges = edges.filter(function (edge) {
            return '' + options.source(edge) === '' + id
          })
          // frequency
          node.edges = node.outEdges.concat(node.inEdges)
          node.frequency = node.edges.length
          // weight
          node.value = 0
          node.inEdges.forEach(function (edge) {
            node.value += options.targetWeight(edge)
          })
          node.outEdges.forEach(function (edge) {
            node.value += options.sourceWeight(edge)
          })
        })
      }

      function _sortNodes(nodes, options) {
        var sortMethods = {
          weight: function weight(a, b) {
            return b.value - a.value
          },
          frequency: function frequency(a, b) {
            return b.frequency - a.frequency
          },
          id: function id(a, b) {
            return ('' + options.id(a)).localeCompare('' + options.id(b))
          }
        }
        var method = sortMethods[options.sortBy]
        if (!method && isFunction(options.sortBy)) {
          method = options.sortBy
        }
        if (method) {
          nodes.sort(method)
        }
      }

      function _layoutNodes(nodes, options) {
        var len = nodes.length
        if (!len) {
          throw new TypeError('Invalid nodes: it\'s empty!')
        }
        if (options.weight) {
          var marginRatio = options.marginRatio
          if (marginRatio < 0 || marginRatio >= 1) {
            throw new TypeError('Invalid marginRatio: it must be in range [0, 1)!')
          }
          var margin = marginRatio / (2 * len)
          var thickness = options.thickness
          if (thickness <= 0 || thickness >= 1) {
            throw new TypeError('Invalid thickness: it must be in range (0, 1)!')
          }
          var totalValue = 0
          nodes.forEach(function (node) {
            totalValue += node.value
          })
          nodes.forEach(function (node) {
            node.weight = node.value / totalValue
            node.width = node.weight * (1 - marginRatio)
            node.height = thickness
          })
          nodes.forEach(function (node, index) {
            // x
            var deltaX = 0
            for (var i = index - 1; i >= 0; i--) {
              deltaX += nodes[i].width + 2 * margin
            }
            var minX = node.minX = margin + deltaX
            var maxX = node.maxX = node.minX + node.width
            var minY = node.minY = options.y - thickness / 2
            var maxY = node.maxY = minY + thickness
            node.x = [minX, maxX, maxX, minX]
            node.y = [minY, minY, maxY, maxY]
            /* points
             * 3---2
             * |   |
             * 0---1
             */
            // node.x = minX + 0.5 * node.width;
            // node.y = options.y;
          })
        } else {
          var deltaX = 1 / len
          nodes.forEach(function (node, index) {
            node.x = (index + 0.5) * deltaX
            node.y = options.y
          })
        }
      }

      function _locatingEdges(nodeById, edges, options) {
        if (options.weight) {
          var valueById = {}
          forIn(nodeById, function (node, id) {
            valueById[id] = node.value
          })
          edges.forEach(function (edge) {
            var sId = options.source(edge)
            var tId = options.target(edge)
            var sNode = nodeById[sId]
            var tNode = nodeById[tId]
            if (sNode && tNode) {
              var sValue = valueById[sId]
              var currentSValue = options.sourceWeight(edge)
              var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width
              var sEnd = sStart + currentSValue / sNode.value * sNode.width
              valueById[sId] -= currentSValue

              var tValue = valueById[tId]
              var currentTValue = options.targetWeight(edge)
              var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width
              var tEnd = tStart + currentTValue / tNode.value * tNode.width
              valueById[tId] -= currentTValue

              var y = options.y
              edge.x = [sStart, sEnd, tStart, tEnd]
              edge.y = [y, y, y, y]
            }
          })
        } else {
          edges.forEach(function (edge) {
            var sNode = nodeById[options.source(edge)]
            var tNode = nodeById[options.target(edge)]
            if (sNode && tNode) {
              edge.x = [sNode.x, tNode.x]
              edge.y = [sNode.y, tNode.y]
            }
          })
        }
      }

      function transform(dv, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var nodeById = {}
        var nodes = dv.nodes
        var edges = dv.edges
        if (!Array.isArray(nodes) || nodes.length === 0) {
          nodes = _nodesFromEdges(edges, options, nodeById)
        }
        nodes.forEach(function (node) {
          var id = options.id(node)
          nodeById[id] = node
        })
        _processGraph(nodeById, edges, options)
        _sortNodes(nodes, options)
        _layoutNodes(nodes, options)
        _locatingEdges(nodeById, edges, options)
        dv.nodes = nodes
        dv.edges = edges
      }

      registerTransform('diagram.arc', transform)
      registerTransform('arc', transform)
      /***/
    },
    /* 665 */
    /***/
    function (module, exports, __webpack_require__) {
      /*
       * for Sankey Diagram
       * graph data required (nodes, edges)
       */
      var assign = __webpack_require__(5)
      var isString = __webpack_require__(7)
      var isFunction = __webpack_require__(8)

      var _require = __webpack_require__(666),
        sankey = _require.sankey,
        sankeyLeft = _require.sankeyLeft,
        sankeyRight = _require.sankeyRight,
        sankeyCenter = _require.sankeyCenter,
        sankeyJustify = _require.sankeyJustify

      var _require2 = __webpack_require__(2),
        registerTransform = _require2.registerTransform

      var ALIGN_METHOD = {
        sankeyLeft: sankeyLeft,
        sankeyRight: sankeyRight,
        sankeyCenter: sankeyCenter,
        sankeyJustify: sankeyJustify
      }

      var DEFAULT_OPTIONS = {
        id: function id(node) {
          return node.id
        },
        value: function value(node) {
          return node.value
        },
        source: function source(edge) {
          return edge.source
        },
        target: function target(edge) {
          return edge.target
        },
        nodeAlign: 'sankeyJustify',
        nodeWidth: 0.02,
        nodePadding: 0.02
      }

      function transform(dv, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var nodeAlign = null
        if (isString(options.nodeAlign)) {
          nodeAlign = ALIGN_METHOD[options.nodeAlign]
        } else if (isFunction(options.nodeAlign)) {
          nodeAlign = options.nodeAlign
        }
        var sankeyProcessor = sankey().links(function (d) {
          return d.edges
        }).nodeWidth(options.nodeWidth).nodePadding(options.nodePadding).extent([
          [0, 0],
          [1, 1]
        ])
        if (nodeAlign) {
          sankeyProcessor.nodeAlign(nodeAlign)
        }
        sankeyProcessor(dv)
        // post process (x, y), etc.
        dv.nodes.forEach(function (node) {
          var x0 = node.x0,
            x1 = node.x1,
            y0 = node.y0,
            y1 = node.y1
          /* points
           * 3---2
           * |   |
           * 0---1
           */

          node.x = [x0, x1, x1, x0]
          node.y = [y0, y0, y1, y1]
        })
        dv.edges.forEach(function (edge) {
          var source = edge.source,
            target = edge.target

          var sx = source.x1
          var tx = target.x0
          edge.x = [sx, sx, tx, tx]
          var offset = edge.width / 2
          edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset]
        })
      }

      registerTransform('diagram.sankey', transform)
      registerTransform('sankey', transform)
      /***/
    },
    /* 666 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _sankey = __webpack_require__(667)

      Object.defineProperty(exports, 'sankey', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sankey).default
        }
      })

      var _align = __webpack_require__(250)

      Object.defineProperty(exports, 'sankeyCenter', {
        enumerable: true,
        get: function get() {
          return _align.center
        }
      })
      Object.defineProperty(exports, 'sankeyLeft', {
        enumerable: true,
        get: function get() {
          return _align.left
        }
      })
      Object.defineProperty(exports, 'sankeyRight', {
        enumerable: true,
        get: function get() {
          return _align.right
        }
      })
      Object.defineProperty(exports, 'sankeyJustify', {
        enumerable: true,
        get: function get() {
          return _align.justify
        }
      })

      var _sankeyLinkHorizontal = __webpack_require__(675)

      Object.defineProperty(exports, 'sankeyLinkHorizontal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_sankeyLinkHorizontal).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 667 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj
      } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj
      }

      exports.default = function () {
        var x0 = 0,
          y0 = 0,
          x1 = 1,
          y1 = 1,
          // extent
          dx = 24,
          // nodeWidth
          py = 8,
          // nodePadding
          id = defaultId,
          align = _align.justify,
          nodes = defaultNodes,
          links = defaultLinks,
          iterations = 32

        function sankey() {
          var graph = {
            nodes: nodes.apply(null, arguments),
            links: links.apply(null, arguments)
          }
          computeNodeLinks(graph)
          computeNodeValues(graph)
          computeNodeDepths(graph)
          computeNodeBreadths(graph, iterations)
          computeLinkBreadths(graph)
          return graph
        }

        sankey.update = function (graph) {
          computeLinkBreadths(graph)
          return graph
        }

        sankey.nodeId = function (_) {
          return arguments.length ? (id = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankey) : id
        }

        sankey.nodeAlign = function (_) {
          return arguments.length ? (align = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankey) : align
        }

        sankey.nodeWidth = function (_) {
          return arguments.length ? (dx = +_, sankey) : dx
        }

        sankey.nodePadding = function (_) {
          return arguments.length ? (py = +_, sankey) : py
        }

        sankey.nodes = function (_) {
          return arguments.length ? (nodes = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankey) : nodes
        }

        sankey.links = function (_) {
          return arguments.length ? (links = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankey) : links
        }

        sankey.size = function (_) {
          return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0]
        }

        sankey.extent = function (_) {
          return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [
            [x0, y0],
            [x1, y1]
          ]
        }

        sankey.iterations = function (_) {
          return arguments.length ? (iterations = +_, sankey) : iterations
        }

        // Populate the sourceLinks and targetLinks for each node.
        // Also, if the source and target are not objects, assume they are indices.
        function computeNodeLinks(graph) {
          graph.nodes.forEach(function (node, i) {
            node.index = i
            node.sourceLinks = []
            node.targetLinks = []
          })
          var nodeById = (0, _d3Collection.map)(graph.nodes, id)
          graph.links.forEach(function (link, i) {
            link.index = i
            var source = link.source,
              target = link.target
            if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') source = link.source = find(nodeById, source)
            if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') target = link.target = find(nodeById, target)
            source.sourceLinks.push(link)
            target.targetLinks.push(link)
          })
        }

        // Compute the value (size) of each node by summing the associated links.
        function computeNodeValues(graph) {
          graph.nodes.forEach(function (node) {
            node.value = Math.max((0, _d3Array.sum)(node.sourceLinks, value), (0, _d3Array.sum)(node.targetLinks, value))
          })
        }

        // Iteratively assign the depth (x-position) for each node.
        // Nodes are assigned the maximum depth of incoming neighbors plus one;
        // nodes with no incoming links are assigned depth zero, while
        // nodes with no outgoing links are assigned the maximum depth.
        function computeNodeDepths(graph) {
          var nodes, next, x

          for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
            nodes.forEach(function (node) {
              node.depth = x
              node.sourceLinks.forEach(function (link) {
                if (next.indexOf(link.target) < 0) {
                  next.push(link.target)
                }
              })
            })
          }

          for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
            nodes.forEach(function (node) {
              node.height = x
              node.targetLinks.forEach(function (link) {
                if (next.indexOf(link.source) < 0) {
                  next.push(link.source)
                }
              })
            })
          }

          var kx = (x1 - x0 - dx) / (x - 1)
          graph.nodes.forEach(function (node) {
            node.x1 = (node.x0 = x0 + Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x)))) * kx) + dx
          })
        }

        function computeNodeBreadths(graph) {
          var columns = (0, _d3Collection.nest)().key(function (d) {
            return d.x0
          }).sortKeys(_d3Array.ascending).entries(graph.nodes).map(function (d) {
            return d.values
          })

          //
          initializeNodeBreadth()
          resolveCollisions()
          for (var alpha = 1, n = iterations; n > 0; --n) {
            relaxRightToLeft(alpha *= 0.99)
            resolveCollisions()
            relaxLeftToRight(alpha)
            resolveCollisions()
          }

          function initializeNodeBreadth() {
            var ky = (0, _d3Array.min)(columns, function (nodes) {
              return (y1 - y0 - (nodes.length - 1) * py) / (0, _d3Array.sum)(nodes, value)
            })

            columns.forEach(function (nodes) {
              nodes.forEach(function (node, i) {
                node.y1 = (node.y0 = i) + node.value * ky
              })
            })

            graph.links.forEach(function (link) {
              link.width = link.value * ky
            })
          }

          function relaxLeftToRight(alpha) {
            columns.forEach(function (nodes) {
              nodes.forEach(function (node) {
                if (node.targetLinks.length) {
                  var dy = ((0, _d3Array.sum)(node.targetLinks, weightedSource) / (0, _d3Array.sum)(node.targetLinks, value) - nodeCenter(node)) * alpha
                  node.y0 += dy, node.y1 += dy
                }
              })
            })
          }

          function relaxRightToLeft(alpha) {
            columns.slice().reverse().forEach(function (nodes) {
              nodes.forEach(function (node) {
                if (node.sourceLinks.length) {
                  var dy = ((0, _d3Array.sum)(node.sourceLinks, weightedTarget) / (0, _d3Array.sum)(node.sourceLinks, value) - nodeCenter(node)) * alpha
                  node.y0 += dy, node.y1 += dy
                }
              })
            })
          }

          function resolveCollisions() {
            columns.forEach(function (nodes) {
              var node,
                dy,
                y = y0,
                n = nodes.length,
                i

              // Push any overlapping nodes down.
              nodes.sort(ascendingBreadth)
              for (i = 0; i < n; ++i) {
                node = nodes[i]
                dy = y - node.y0
                if (dy > 0) node.y0 += dy, node.y1 += dy
                y = node.y1 + py
              }

              // If the bottommost node goes outside the bounds, push it back up.
              dy = y - py - y1
              if (dy > 0) {
                y = node.y0 -= dy, node.y1 -= dy

                // Push any overlapping nodes back up.
                for (i = n - 2; i >= 0; --i) {
                  node = nodes[i]
                  dy = node.y1 + py - y
                  if (dy > 0) node.y0 -= dy, node.y1 -= dy
                  y = node.y0
                }
              }
            })
          }
        }

        function computeLinkBreadths(graph) {
          graph.nodes.forEach(function (node) {
            node.sourceLinks.sort(ascendingTargetBreadth)
            node.targetLinks.sort(ascendingSourceBreadth)
          })
          graph.nodes.forEach(function (node) {
            var y0 = node.y0,
              y1 = y0
            node.sourceLinks.forEach(function (link) {
              link.y0 = y0 + link.width / 2, y0 += link.width
            })
            node.targetLinks.forEach(function (link) {
              link.y1 = y1 + link.width / 2, y1 += link.width
            })
          })
        }

        return sankey
      }

      var _d3Array = __webpack_require__(14)

      var _d3Collection = __webpack_require__(668)

      var _align = __webpack_require__(250)

      var _constant = __webpack_require__(674)

      var _constant2 = _interopRequireDefault(_constant)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function ascendingSourceBreadth(a, b) {
        return ascendingBreadth(a.source, b.source) || a.index - b.index
      }

      function ascendingTargetBreadth(a, b) {
        return ascendingBreadth(a.target, b.target) || a.index - b.index
      }

      function ascendingBreadth(a, b) {
        return a.y0 - b.y0
      }

      function value(d) {
        return d.value
      }

      function nodeCenter(node) {
        return (node.y0 + node.y1) / 2
      }

      function weightedSource(link) {
        return nodeCenter(link.source) * link.value
      }

      function weightedTarget(link) {
        return nodeCenter(link.target) * link.value
      }

      function defaultId(d) {
        return d.index
      }

      function defaultNodes(graph) {
        return graph.nodes
      }

      function defaultLinks(graph) {
        return graph.links
      }

      function find(nodeById, id) {
        var node = nodeById.get(id)
        if (!node) throw new Error('missing: ' + id)
        return node
      }
      /***/
    },
    /* 668 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _nest = __webpack_require__(669)

      Object.defineProperty(exports, 'nest', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_nest).default
        }
      })

      var _set = __webpack_require__(670)

      Object.defineProperty(exports, 'set', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_set).default
        }
      })

      var _map = __webpack_require__(129)

      Object.defineProperty(exports, 'map', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_map).default
        }
      })

      var _keys = __webpack_require__(671)

      Object.defineProperty(exports, 'keys', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_keys).default
        }
      })

      var _values = __webpack_require__(672)

      Object.defineProperty(exports, 'values', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_values).default
        }
      })

      var _entries = __webpack_require__(673)

      Object.defineProperty(exports, 'entries', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_entries).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 669 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var keys = [],
          _sortKeys = [],
          _sortValues,
          _rollup,
          nest

        function apply(array, depth, createResult, setResult) {
          if (depth >= keys.length) {
            if (_sortValues != null) array.sort(_sortValues)
            return _rollup != null ? _rollup(array) : array
          }

          var i = -1,
            n = array.length,
            key = keys[depth++],
            keyValue,
            value,
            valuesByKey = (0, _map2.default)(),
            values,
            result = createResult()

          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(value = array[i]) + '')) {
              values.push(value)
            } else {
              valuesByKey.set(keyValue, [value])
            }
          }

          valuesByKey.each(function (values, key) {
            setResult(result, key, apply(values, depth, createResult, setResult))
          })

          return result
        }

        function _entries(map, depth) {
          if (++depth > keys.length) return map
          var array,
            sortKey = _sortKeys[depth - 1]
          if (_rollup != null && depth >= keys.length) array = map.entries();
          else {
            array = [], map.each(function (v, k) {
              array.push({
                key: k,
                values: _entries(v, depth)
              })
            })
          }
          return sortKey != null ? array.sort(function (a, b) {
            return sortKey(a.key, b.key)
          }) : array
        }

        return nest = {
          object: function object(array) {
            return apply(array, 0, createObject, setObject)
          },
          map: function map(array) {
            return apply(array, 0, createMap, setMap)
          },
          entries: function entries(array) {
            return _entries(apply(array, 0, createMap, setMap), 0)
          },
          key: function key(d) {
            keys.push(d);
            return nest
          },
          sortKeys: function sortKeys(order) {
            _sortKeys[keys.length - 1] = order;
            return nest
          },
          sortValues: function sortValues(order) {
            _sortValues = order;
            return nest
          },
          rollup: function rollup(f) {
            _rollup = f;
            return nest
          }
        }
      }

      var _map = __webpack_require__(129)

      var _map2 = _interopRequireDefault(_map)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function createObject() {
        return {}
      }

      function setObject(object, key, value) {
        object[key] = value
      }

      function createMap() {
        return (0, _map2.default)()
      }

      function setMap(map, key, value) {
        map.set(key, value)
      }
      /***/
    },
    /* 670 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _map = __webpack_require__(129)

      var _map2 = _interopRequireDefault(_map)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function Set() {}

      var proto = _map2.default.prototype

      Set.prototype = set.prototype = {
        constructor: Set,
        has: proto.has,
        add: function add(value) {
          value += ''
          this[_map.prefix + value] = value
          return this
        },
        remove: proto.remove,
        clear: proto.clear,
        values: proto.keys,
        size: proto.size,
        empty: proto.empty,
        each: proto.each
      }

      function set(object, f) {
        var set = new Set()

        // Copy constructor.
        if (object instanceof Set) {
          object.each(function (value) {
            set.add(value)
          })
        }

        // Otherwise, assume its an array.
        else if (object) {
          var i = -1,
            n = object.length
          if (f == null) {
            while (++i < n) {
              set.add(object[i])
            }
          } else {
            while (++i < n) {
              set.add(f(object[i], i, object))
            }
          }
        }

        return set
      }

      exports.default = set
      /***/
    },
    /* 671 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (map) {
        var keys = []
        for (var key in map) {
          keys.push(key)
        }
        return keys
      }
      /***/
    },
    /* 672 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (map) {
        var values = []
        for (var key in map) {
          values.push(map[key])
        }
        return values
      }
      /***/
    },
    /* 673 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (map) {
        var entries = []
        for (var key in map) {
          entries.push({
            key: key,
            value: map[key]
          })
        }
        return entries
      }
      /***/
    },
    /* 674 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.default = constant

      function constant(x) {
        return function () {
          return x
        }
      }
      /***/
    },
    /* 675 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        return (0, _d3Shape.linkHorizontal)().source(horizontalSource).target(horizontalTarget)
      }

      var _d3Shape = __webpack_require__(676)

      function horizontalSource(d) {
        return [d.source.x1, d.y0]
      }

      function horizontalTarget(d) {
        return [d.target.x0, d.y1]
      }
      /***/
    },
    /* 676 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _arc = __webpack_require__(677)

      Object.defineProperty(exports, 'arc', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_arc).default
        }
      })

      var _area = __webpack_require__(251)

      Object.defineProperty(exports, 'area', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_area).default
        }
      })

      var _line = __webpack_require__(130)

      Object.defineProperty(exports, 'line', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_line).default
        }
      })

      var _pie = __webpack_require__(678)

      Object.defineProperty(exports, 'pie', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_pie).default
        }
      })

      var _areaRadial = __webpack_require__(681)

      Object.defineProperty(exports, 'areaRadial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_areaRadial).default
        }
      })
      Object.defineProperty(exports, 'radialArea', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_areaRadial).default
        }
      })

      var _lineRadial = __webpack_require__(253)

      Object.defineProperty(exports, 'lineRadial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_lineRadial).default
        }
      })
      Object.defineProperty(exports, 'radialLine', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_lineRadial).default
        }
      })

      var _pointRadial = __webpack_require__(254)

      Object.defineProperty(exports, 'pointRadial', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_pointRadial).default
        }
      })

      var _index = __webpack_require__(682)

      Object.defineProperty(exports, 'linkHorizontal', {
        enumerable: true,
        get: function get() {
          return _index.linkHorizontal
        }
      })
      Object.defineProperty(exports, 'linkVertical', {
        enumerable: true,
        get: function get() {
          return _index.linkVertical
        }
      })
      Object.defineProperty(exports, 'linkRadial', {
        enumerable: true,
        get: function get() {
          return _index.linkRadial
        }
      })

      var _symbol = __webpack_require__(683)

      Object.defineProperty(exports, 'symbol', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_symbol).default
        }
      })
      Object.defineProperty(exports, 'symbols', {
        enumerable: true,
        get: function get() {
          return _symbol.symbols
        }
      })

      var _circle = __webpack_require__(256)

      Object.defineProperty(exports, 'symbolCircle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_circle).default
        }
      })

      var _cross = __webpack_require__(257)

      Object.defineProperty(exports, 'symbolCross', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cross).default
        }
      })

      var _diamond = __webpack_require__(258)

      Object.defineProperty(exports, 'symbolDiamond', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_diamond).default
        }
      })

      var _square = __webpack_require__(260)

      Object.defineProperty(exports, 'symbolSquare', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_square).default
        }
      })

      var _star = __webpack_require__(259)

      Object.defineProperty(exports, 'symbolStar', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_star).default
        }
      })

      var _triangle = __webpack_require__(261)

      Object.defineProperty(exports, 'symbolTriangle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_triangle).default
        }
      })

      var _wye = __webpack_require__(262)

      Object.defineProperty(exports, 'symbolWye', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wye).default
        }
      })

      var _basisClosed = __webpack_require__(684)

      Object.defineProperty(exports, 'curveBasisClosed', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_basisClosed).default
        }
      })

      var _basisOpen = __webpack_require__(685)

      Object.defineProperty(exports, 'curveBasisOpen', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_basisOpen).default
        }
      })

      var _basis = __webpack_require__(74)

      Object.defineProperty(exports, 'curveBasis', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_basis).default
        }
      })

      var _bundle = __webpack_require__(686)

      Object.defineProperty(exports, 'curveBundle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_bundle).default
        }
      })

      var _cardinalClosed = __webpack_require__(263)

      Object.defineProperty(exports, 'curveCardinalClosed', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cardinalClosed).default
        }
      })

      var _cardinalOpen = __webpack_require__(264)

      Object.defineProperty(exports, 'curveCardinalOpen', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cardinalOpen).default
        }
      })

      var _cardinal = __webpack_require__(75)

      Object.defineProperty(exports, 'curveCardinal', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_cardinal).default
        }
      })

      var _catmullRomClosed = __webpack_require__(687)

      Object.defineProperty(exports, 'curveCatmullRomClosed', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_catmullRomClosed).default
        }
      })

      var _catmullRomOpen = __webpack_require__(688)

      Object.defineProperty(exports, 'curveCatmullRomOpen', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_catmullRomOpen).default
        }
      })

      var _catmullRom = __webpack_require__(132)

      Object.defineProperty(exports, 'curveCatmullRom', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_catmullRom).default
        }
      })

      var _linearClosed = __webpack_require__(689)

      Object.defineProperty(exports, 'curveLinearClosed', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_linearClosed).default
        }
      })

      var _linear = __webpack_require__(72)

      Object.defineProperty(exports, 'curveLinear', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_linear).default
        }
      })

      var _monotone = __webpack_require__(690)

      Object.defineProperty(exports, 'curveMonotoneX', {
        enumerable: true,
        get: function get() {
          return _monotone.monotoneX
        }
      })
      Object.defineProperty(exports, 'curveMonotoneY', {
        enumerable: true,
        get: function get() {
          return _monotone.monotoneY
        }
      })

      var _natural = __webpack_require__(691)

      Object.defineProperty(exports, 'curveNatural', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_natural).default
        }
      })

      var _step = __webpack_require__(692)

      Object.defineProperty(exports, 'curveStep', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_step).default
        }
      })
      Object.defineProperty(exports, 'curveStepAfter', {
        enumerable: true,
        get: function get() {
          return _step.stepAfter
        }
      })
      Object.defineProperty(exports, 'curveStepBefore', {
        enumerable: true,
        get: function get() {
          return _step.stepBefore
        }
      })

      var _stack = __webpack_require__(693)

      Object.defineProperty(exports, 'stack', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_stack).default
        }
      })

      var _expand = __webpack_require__(694)

      Object.defineProperty(exports, 'stackOffsetExpand', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_expand).default
        }
      })

      var _diverging = __webpack_require__(695)

      Object.defineProperty(exports, 'stackOffsetDiverging', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_diverging).default
        }
      })

      var _none = __webpack_require__(50)

      Object.defineProperty(exports, 'stackOffsetNone', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_none).default
        }
      })

      var _silhouette = __webpack_require__(696)

      Object.defineProperty(exports, 'stackOffsetSilhouette', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_silhouette).default
        }
      })

      var _wiggle = __webpack_require__(697)

      Object.defineProperty(exports, 'stackOffsetWiggle', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_wiggle).default
        }
      })

      var _ascending = __webpack_require__(133)

      Object.defineProperty(exports, 'stackOrderAscending', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ascending).default
        }
      })

      var _descending = __webpack_require__(698)

      Object.defineProperty(exports, 'stackOrderDescending', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_descending).default
        }
      })

      var _insideOut = __webpack_require__(699)

      Object.defineProperty(exports, 'stackOrderInsideOut', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_insideOut).default
        }
      })

      var _none2 = __webpack_require__(51)

      Object.defineProperty(exports, 'stackOrderNone', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_none2).default
        }
      })

      var _reverse = __webpack_require__(700)

      Object.defineProperty(exports, 'stackOrderReverse', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_reverse).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 677 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = (0, _constant2.default)(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null

        function arc() {
          var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - _math.halfPi,
            a1 = endAngle.apply(this, arguments) - _math.halfPi,
            da = (0, _math.abs)(a1 - a0),
            cw = a1 > a0

          if (!context) context = buffer = (0, _d3Path.path)()

          // Ensure that the outer radius is always larger than the inner radius.
          if (r1 < r0) r = r1, r1 = r0, r0 = r

          // Is it a point?
          if (!(r1 > _math.epsilon)) context.moveTo(0, 0)

          // Or is it a circle or annulus?
          else if (da > _math.tau - _math.epsilon) {
            context.moveTo(r1 * (0, _math.cos)(a0), r1 * (0, _math.sin)(a0))
            context.arc(0, 0, r1, a0, a1, !cw)
            if (r0 > _math.epsilon) {
              context.moveTo(r0 * (0, _math.cos)(a1), r0 * (0, _math.sin)(a1))
              context.arc(0, 0, r0, a1, a0, cw)
            }
          }

          // Or is it a circular or annular sector?
          else {
            var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > _math.epsilon && (padRadius ? +padRadius.apply(this, arguments) : (0, _math.sqrt)(r0 * r0 + r1 * r1)),
              rc = (0, _math.min)((0, _math.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1

            // Apply padding? Note that since r1  r0, da1  da0.
            if (rp > _math.epsilon) {
              var p0 = (0, _math.asin)(rp / r0 * (0, _math.sin)(ap)),
                p1 = (0, _math.asin)(rp / r1 * (0, _math.sin)(ap))
              if ((da0 -= p0 * 2) > _math.epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
              else da0 = 0, a00 = a10 = (a0 + a1) / 2
              if ((da1 -= p1 * 2) > _math.epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
              else da1 = 0, a01 = a11 = (a0 + a1) / 2
            }

            var x01 = r1 * (0, _math.cos)(a01),
              y01 = r1 * (0, _math.sin)(a01),
              x10 = r0 * (0, _math.cos)(a10),
              y10 = r0 * (0, _math.sin)(a10)

            // Apply rounded corners?
            if (rc > _math.epsilon) {
              var x11 = r1 * (0, _math.cos)(a11),
                y11 = r1 * (0, _math.sin)(a11),
                x00 = r0 * (0, _math.cos)(a00),
                y00 = r0 * (0, _math.sin)(a00)

              // Restrict the corner radius according to the sector angle.
              if (da < _math.pi) {
                var oc = da0 > _math.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                  ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / (0, _math.sin)((0, _math.acos)((ax * bx + ay * by) / ((0, _math.sqrt)(ax * ax + ay * ay) * (0, _math.sqrt)(bx * bx + by * by))) / 2),
                  lc = (0, _math.sqrt)(oc[0] * oc[0] + oc[1] * oc[1])
                rc0 = (0, _math.min)(rc, (r0 - lc) / (kc - 1))
                rc1 = (0, _math.min)(rc, (r1 - lc) / (kc + 1))
              }
            }

            // Is the sector collapsed to a line?
            if (!(da1 > _math.epsilon)) context.moveTo(x01, y01)

            // Does the sectors outer ring have rounded corners?
            else if (rc1 > _math.epsilon) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw)
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw)

              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01)

              // Have the corners merged?
              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw)

              // Otherwise, draw the two corners and the ring.
              else {
                context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw)
                context.arc(0, 0, r1, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw)
                context.arc(t1.cx, t1.cy, rc1, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw)
              }
            }

            // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw)

            // Is there no inner ring, and its a circular sector?
            // Or perhaps its an annular sector collapsed due to padding?
            if (!(r0 > _math.epsilon) || !(da0 > _math.epsilon)) context.lineTo(x10, y10)

            // Does the sectors inner ring (or point) have rounded corners?
            else if (rc0 > _math.epsilon) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw)
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw)

              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01)

              // Have the corners merged?
              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw)

              // Otherwise, draw the two corners and the ring.
              else {
                context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw)
                context.arc(0, 0, r0, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw)
                context.arc(t1.cx, t1.cy, rc0, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw)
              }
            }

            // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw)
          }

          context.closePath()

          if (buffer) return context = null, buffer + '' || null
        }

        arc.centroid = function () {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math.pi / 2
          return [(0, _math.cos)(a) * r, (0, _math.sin)(a) * r]
        }

        arc.innerRadius = function (_) {
          return arguments.length ? (innerRadius = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : innerRadius
        }

        arc.outerRadius = function (_) {
          return arguments.length ? (outerRadius = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : outerRadius
        }

        arc.cornerRadius = function (_) {
          return arguments.length ? (cornerRadius = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : cornerRadius
        }

        arc.padRadius = function (_) {
          return arguments.length ? (padRadius = _ == null ? null : typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : padRadius
        }

        arc.startAngle = function (_) {
          return arguments.length ? (startAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : startAngle
        }

        arc.endAngle = function (_) {
          return arguments.length ? (endAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : endAngle
        }

        arc.padAngle = function (_) {
          return arguments.length ? (padAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), arc) : padAngle
        }

        arc.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, arc) : context
        }

        return arc
      }

      var _d3Path = __webpack_require__(29)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _math = __webpack_require__(49)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function arcInnerRadius(d) {
        return d.innerRadius
      }

      function arcOuterRadius(d) {
        return d.outerRadius
      }

      function arcStartAngle(d) {
        return d.startAngle
      }

      function arcEndAngle(d) {
        return d.endAngle
      }

      function arcPadAngle(d) {
        return d && d.padAngle // Note: optional!
      }

      function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
        var x10 = x1 - x0,
          y10 = y1 - y0,
          x32 = x3 - x2,
          y32 = y3 - y2,
          t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10)
        return [x0 + t * x10, y0 + t * y10]
      }

      // Compute perpendicular offset line of length rc.
      // http://mathworld.wolfram.com/Circle-LineIntersection.html
      function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
        var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / (0, _math.sqrt)(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * (0, _math.sqrt)((0, _math.max)(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00

        // Pick the closer of the two intersection points.
        // TODO Is there a faster way to determine which intersection to use?
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1

        return {
          cx: cx0,
          cy: cy0,
          x01: -ox,
          y01: -oy,
          x11: cx0 * (r1 / r - 1),
          y11: cy0 * (r1 / r - 1)
        }
      }
      /***/
    },
    /* 678 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var value = _identity2.default,
          sortValues = _descending2.default,
          sort = null,
          startAngle = (0, _constant2.default)(0),
          endAngle = (0, _constant2.default)(_math.tau),
          padAngle = (0, _constant2.default)(0)

        function pie(data) {
          var i,
            n = data.length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(_math.tau, Math.max(-_math.tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v

          for (i = 0; i < n; ++i) {
            if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
              sum += v
            }
          }

          // Optionally sort the arcs by previously-computed values or by data.
          if (sortValues != null) {
            index.sort(function (i, j) {
              return sortValues(arcs[i], arcs[j])
            })
          } else if (sort != null) {
            index.sort(function (i, j) {
              return sort(data[i], data[j])
            })
          }

          // Compute the arcs! They are stored in the original data's order.
          for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
            j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
              data: data[j],
              index: i,
              value: v,
              startAngle: a0,
              endAngle: a1,
              padAngle: p
            }
          }

          return arcs
        }

        pie.value = function (_) {
          return arguments.length ? (value = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), pie) : value
        }

        pie.sortValues = function (_) {
          return arguments.length ? (sortValues = _, sort = null, pie) : sortValues
        }

        pie.sort = function (_) {
          return arguments.length ? (sort = _, sortValues = null, pie) : sort
        }

        pie.startAngle = function (_) {
          return arguments.length ? (startAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), pie) : startAngle
        }

        pie.endAngle = function (_) {
          return arguments.length ? (endAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), pie) : endAngle
        }

        pie.padAngle = function (_) {
          return arguments.length ? (padAngle = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), pie) : padAngle
        }

        return pie
      }

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _descending = __webpack_require__(679)

      var _descending2 = _interopRequireDefault(_descending)

      var _identity = __webpack_require__(680)

      var _identity2 = _interopRequireDefault(_identity)

      var _math = __webpack_require__(49)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 679 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
      }
      /***/
    },
    /* 680 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (d) {
        return d
      }
      /***/
    },
    /* 681 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var a = (0, _area2.default)().curve(_radial.curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1

        a.angle = a.x, delete a.x
        a.startAngle = a.x0, delete a.x0
        a.endAngle = a.x1, delete a.x1
        a.radius = a.y, delete a.y
        a.innerRadius = a.y0, delete a.y0
        a.outerRadius = a.y1, delete a.y1
        a.lineStartAngle = function () {
          return (0, _lineRadial.lineRadial)(x0())
        }, delete a.lineX0
        a.lineEndAngle = function () {
          return (0, _lineRadial.lineRadial)(x1())
        }, delete a.lineX1
        a.lineInnerRadius = function () {
          return (0, _lineRadial.lineRadial)(y0())
        }, delete a.lineY0
        a.lineOuterRadius = function () {
          return (0, _lineRadial.lineRadial)(y1())
        }, delete a.lineY1

        a.curve = function (_) {
          return arguments.length ? c((0, _radial2.default)(_)) : c()._curve
        }

        return a
      }

      var _radial = __webpack_require__(252)

      var _radial2 = _interopRequireDefault(_radial)

      var _area = __webpack_require__(251)

      var _area2 = _interopRequireDefault(_area)

      var _lineRadial = __webpack_require__(253)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 682 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.linkHorizontal = linkHorizontal
      exports.linkVertical = linkVertical
      exports.linkRadial = linkRadial

      var _d3Path = __webpack_require__(29)

      var _array = __webpack_require__(255)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _point = __webpack_require__(131)

      var _pointRadial = __webpack_require__(254)

      var _pointRadial2 = _interopRequireDefault(_pointRadial)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function linkSource(d) {
        return d.source
      }

      function linkTarget(d) {
        return d.target
      }

      function link(curve) {
        var source = linkSource,
          target = linkTarget,
          x = _point.x,
          y = _point.y,
          context = null

        function link() {
          var buffer,
            argv = _array.slice.call(arguments),
            s = source.apply(this, argv),
            t = target.apply(this, argv)
          if (!context) context = buffer = (0, _d3Path.path)()
          curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv))
          if (buffer) return context = null, buffer + '' || null
        }

        link.source = function (_) {
          return arguments.length ? (source = _, link) : source
        }

        link.target = function (_) {
          return arguments.length ? (target = _, link) : target
        }

        link.x = function (_) {
          return arguments.length ? (x = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), link) : x
        }

        link.y = function (_) {
          return arguments.length ? (y = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), link) : y
        }

        link.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, link) : context
        }

        return link
      }

      function curveHorizontal(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0)
        context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1)
      }

      function curveVertical(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0)
        context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1)
      }

      function curveRadial(context, x0, y0, x1, y1) {
        var p0 = (0, _pointRadial2.default)(x0, y0),
          p1 = (0, _pointRadial2.default)(x0, y0 = (y0 + y1) / 2),
          p2 = (0, _pointRadial2.default)(x1, y0),
          p3 = (0, _pointRadial2.default)(x1, y1)
        context.moveTo(p0[0], p0[1])
        context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1])
      }

      function linkHorizontal() {
        return link(curveHorizontal)
      }

      function linkVertical() {
        return link(curveVertical)
      }

      function linkRadial() {
        var l = link(curveRadial)
        l.angle = l.x, delete l.x
        l.radius = l.y, delete l.y
        return l
      }
      /***/
    },
    /* 683 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.symbols = undefined

      exports.default = function () {
        var type = (0, _constant2.default)(_circle2.default),
          size = (0, _constant2.default)(64),
          context = null

        function symbol() {
          var buffer
          if (!context) context = buffer = (0, _d3Path.path)()
          type.apply(this, arguments).draw(context, +size.apply(this, arguments))
          if (buffer) return context = null, buffer + '' || null
        }

        symbol.type = function (_) {
          return arguments.length ? (type = typeof _ === 'function' ? _ : (0, _constant2.default)(_), symbol) : type
        }

        symbol.size = function (_) {
          return arguments.length ? (size = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), symbol) : size
        }

        symbol.context = function (_) {
          return arguments.length ? (context = _ == null ? null : _, symbol) : context
        }

        return symbol
      }

      var _d3Path = __webpack_require__(29)

      var _circle = __webpack_require__(256)

      var _circle2 = _interopRequireDefault(_circle)

      var _cross = __webpack_require__(257)

      var _cross2 = _interopRequireDefault(_cross)

      var _diamond = __webpack_require__(258)

      var _diamond2 = _interopRequireDefault(_diamond)

      var _star = __webpack_require__(259)

      var _star2 = _interopRequireDefault(_star)

      var _square = __webpack_require__(260)

      var _square2 = _interopRequireDefault(_square)

      var _triangle = __webpack_require__(261)

      var _triangle2 = _interopRequireDefault(_triangle)

      var _wye = __webpack_require__(262)

      var _wye2 = _interopRequireDefault(_wye)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      var symbols = exports.symbols = [_circle2.default, _cross2.default, _diamond2.default, _square2.default, _star2.default, _triangle2.default, _wye2.default]
      /***/
    },
    /* 684 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (context) {
        return new BasisClosed(context)
      }

      var _noop = __webpack_require__(73)

      var _noop2 = _interopRequireDefault(_noop)

      var _basis = __webpack_require__(74)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function BasisClosed(context) {
        this._context = context
      }

      BasisClosed.prototype = {
        areaStart: _noop2.default,
        areaEnd: _noop2.default,
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x2, this._y2)
                this._context.closePath()
                break
              }
            case 2:
              {
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3)
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3)
                this._context.closePath()
                break
              }
            case 3:
              {
                this.point(this._x2, this._y2)
                this.point(this._x3, this._y3)
                this.point(this._x4, this._y4)
                break
              }
          }
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._x2 = x, this._y2 = y;
              break
            case 1:
              this._point = 2;
              this._x3 = x, this._y3 = y;
              break
            case 2:
              this._point = 3;
              this._x4 = x, this._y4 = y;
              this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);
              break
            default:
              (0, _basis.point)(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = x
          this._y0 = this._y1, this._y1 = y
        }
      }
      /***/
    },
    /* 685 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (context) {
        return new BasisOpen(context)
      }

      var _basis = __webpack_require__(74)

      function BasisOpen(context) {
        this._context = context
      }

      BasisOpen.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3;
              var x0 = (this._x0 + 4 * this._x1 + x) / 6,
                y0 = (this._y0 + 4 * this._y1 + y) / 6;
              this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
              break
            case 3:
              this._point = 4 // proceed
            default:
              (0, _basis.point)(this, x, y);
              break
          }
          this._x0 = this._x1, this._x1 = x
          this._y0 = this._y1, this._y1 = y
        }
      }
      /***/
    },
    /* 686 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _basis = __webpack_require__(74)

      function Bundle(context, beta) {
        this._basis = new _basis.Basis(context)
        this._beta = beta
      }

      Bundle.prototype = {
        lineStart: function lineStart() {
          this._x = []
          this._y = []
          this._basis.lineStart()
        },
        lineEnd: function lineEnd() {
          var x = this._x,
            y = this._y,
            j = x.length - 1

          if (j > 0) {
            var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t

            while (++i <= j) {
              t = i / j
              this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy))
            }
          }

          this._x = this._y = null
          this._basis.lineEnd()
        },
        point: function point(x, y) {
          this._x.push(+x)
          this._y.push(+y)
        }
      }

      exports.default = (function custom(beta) {
        function bundle(context) {
          return beta === 1 ? new _basis.Basis(context) : new Bundle(context, beta)
        }

        bundle.beta = function (beta) {
          return custom(+beta)
        }

        return bundle
      }(0.85))
      /***/
    },
    /* 687 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _cardinalClosed = __webpack_require__(263)

      var _noop = __webpack_require__(73)

      var _noop2 = _interopRequireDefault(_noop)

      var _catmullRom = __webpack_require__(132)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function CatmullRomClosed(context, alpha) {
        this._context = context
        this._alpha = alpha
      }

      CatmullRomClosed.prototype = {
        areaStart: _noop2.default,
        areaEnd: _noop2.default,
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 1:
              {
                this._context.moveTo(this._x3, this._y3)
                this._context.closePath()
                break
              }
            case 2:
              {
                this._context.lineTo(this._x3, this._y3)
                this._context.closePath()
                break
              }
            case 3:
              {
                this.point(this._x3, this._y3)
                this.point(this._x4, this._y4)
                this.point(this._x5, this._y5)
                break
              }
          }
        },
        point: function point(x, y) {
          x = +x, y = +y

          if (this._point) {
            var x23 = this._x2 - x,
              y23 = this._y2 - y
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha))
          }

          switch (this._point) {
            case 0:
              this._point = 1;
              this._x3 = x, this._y3 = y;
              break
            case 1:
              this._point = 2;
              this._context.moveTo(this._x4 = x, this._y4 = y);
              break
            case 2:
              this._point = 3;
              this._x5 = x, this._y5 = y;
              break
            default:
              (0, _catmullRom.point)(this, x, y);
              break
          }

          this._l01_a = this._l12_a, this._l12_a = this._l23_a
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed.CardinalClosed(context, 0)
        }

        catmullRom.alpha = function (alpha) {
          return custom(+alpha)
        }

        return catmullRom
      }(0.5))
      /***/
    },
    /* 688 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _cardinalOpen = __webpack_require__(264)

      var _catmullRom = __webpack_require__(132)

      function CatmullRomOpen(context, alpha) {
        this._context = context
        this._alpha = alpha
      }

      CatmullRomOpen.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN
          this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._line || this._line !== 0 && this._point === 3) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y

          if (this._point) {
            var x23 = this._x2 - x,
              y23 = this._y2 - y
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha))
          }

          switch (this._point) {
            case 0:
              this._point = 1;
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3;
              this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
              break
            case 3:
              this._point = 4 // proceed
            default:
              (0, _catmullRom.point)(this, x, y);
              break
          }

          this._l01_a = this._l12_a, this._l12_a = this._l23_a
          this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a
          this._x0 = this._x1, this._x1 = this._x2, this._x2 = x
          this._y0 = this._y1, this._y1 = this._y2, this._y2 = y
        }
      }

      exports.default = (function custom(alpha) {
        function catmullRom(context) {
          return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen.CardinalOpen(context, 0)
        }

        catmullRom.alpha = function (alpha) {
          return custom(+alpha)
        }

        return catmullRom
      }(0.5))
      /***/
    },
    /* 689 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (context) {
        return new LinearClosed(context)
      }

      var _noop = __webpack_require__(73)

      var _noop2 = _interopRequireDefault(_noop)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function LinearClosed(context) {
        this._context = context
      }

      LinearClosed.prototype = {
        areaStart: _noop2.default,
        areaEnd: _noop2.default,
        lineStart: function lineStart() {
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._point) this._context.closePath()
        },
        point: function point(x, y) {
          x = +x, y = +y
          if (this._point) this._context.lineTo(x, y);
          else this._point = 1, this._context.moveTo(x, y)
        }
      }
      /***/
    },
    /* 690 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.monotoneX = monotoneX
      exports.monotoneY = monotoneY

      function sign(x) {
        return x < 0 ? -1 : 1
      }

      // Calculate the slopes of the tangents (Hermite-type interpolation) based on
      // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
      // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
      // NOV(II), P. 443, 1990.
      function slope3(that, x2, y2) {
        var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1)
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0
      }

      // Calculate a one-sided slope.
      function slope2(that, t) {
        var h = that._x1 - that._x0
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t
      }

      // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
      // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
      // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
      function _point(that, t0, t1) {
        var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1)
      }

      function MonotoneX(context) {
        this._context = context
      }

      MonotoneX.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x1, this._y1);
              break
            case 3:
              _point(this, this._t0, slope2(this, this._t0));
              break
          }
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          this._line = 1 - this._line
        },
        point: function point(x, y) {
          var t1 = NaN

          x = +x, y = +y
          if (x === this._x1 && y === this._y1) return // Ignore coincident points.
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2;
              break
            case 2:
              this._point = 3;
              _point(this, slope2(this, t1 = slope3(this, x, y)), t1);
              break
            default:
              _point(this, this._t0, t1 = slope3(this, x, y));
              break
          }

          this._x0 = this._x1, this._x1 = x
          this._y0 = this._y1, this._y1 = y
          this._t0 = t1
        }
      }

      function MonotoneY(context) {
        this._context = new ReflectContext(context)
      }

      (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
        MonotoneX.prototype.point.call(this, y, x)
      }

      function ReflectContext(context) {
        this._context = context
      }

      ReflectContext.prototype = {
        moveTo: function moveTo(x, y) {
          this._context.moveTo(y, x)
        },
        closePath: function closePath() {
          this._context.closePath()
        },
        lineTo: function lineTo(x, y) {
          this._context.lineTo(y, x)
        },
        bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
          this._context.bezierCurveTo(y1, x1, y2, x2, y, x)
        }
      }

      function monotoneX(context) {
        return new MonotoneX(context)
      }

      function monotoneY(context) {
        return new MonotoneY(context)
      }
      /***/
    },
    /* 691 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (context) {
        return new Natural(context)
      }

      function Natural(context) {
        this._context = context
      }

      Natural.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x = []
          this._y = []
        },
        lineEnd: function lineEnd() {
          var x = this._x,
            y = this._y,
            n = x.length

          if (n) {
            this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0])
            if (n === 2) {
              this._context.lineTo(x[1], y[1])
            } else {
              var px = controlPoints(x),
                py = controlPoints(y)
              for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
                this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1])
              }
            }
          }

          if (this._line || this._line !== 0 && n === 1) this._context.closePath()
          this._line = 1 - this._line
          this._x = this._y = null
        },
        point: function point(x, y) {
          this._x.push(+x)
          this._y.push(+y)
        }
      }

      // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
      function controlPoints(x) {
        var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n)
        a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1]
        for (i = 1; i < n - 1; ++i) {
          a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1]
        }
        a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n]
        for (i = 1; i < n; ++i) {
          m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1]
        }
        a[n - 1] = r[n - 1] / b[n - 1]
        for (i = n - 2; i >= 0; --i) {
          a[i] = (r[i] - a[i + 1]) / b[i]
        }
        b[n - 1] = (x[n] + a[n - 1]) / 2
        for (i = 0; i < n - 1; ++i) {
          b[i] = 2 * x[i + 1] - a[i + 1]
        }
        return [a, b]
      }
      /***/
    },
    /* 692 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (context) {
        return new Step(context, 0.5)
      }

      exports.stepBefore = stepBefore
      exports.stepAfter = stepAfter

      function Step(context, t) {
        this._context = context
        this._t = t
      }

      Step.prototype = {
        areaStart: function areaStart() {
          this._line = 0
        },
        areaEnd: function areaEnd() {
          this._line = NaN
        },
        lineStart: function lineStart() {
          this._x = this._y = NaN
          this._point = 0
        },
        lineEnd: function lineEnd() {
          if (this._t > 0 && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y)
          if (this._line || this._line !== 0 && this._point === 1) this._context.closePath()
          if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line
        },
        point: function point(x, y) {
          x = +x, y = +y
          switch (this._point) {
            case 0:
              this._point = 1;
              this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
              break
            case 1:
              this._point = 2 // proceed
            default:
              {
                if (this._t <= 0) {
                  this._context.lineTo(this._x, y)
                  this._context.lineTo(x, y)
                } else {
                  var x1 = this._x * (1 - this._t) + x * this._t
                  this._context.lineTo(x1, this._y)
                  this._context.lineTo(x1, y)
                }
                break
              }
          }
          this._x = x, this._y = y
        }
      }

      function stepBefore(context) {
        return new Step(context, 0)
      }

      function stepAfter(context) {
        return new Step(context, 1)
      }
      /***/
    },
    /* 693 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var keys = (0, _constant2.default)([]),
          order = _none4.default,
          offset = _none2.default,
          value = stackValue

        function stack(data) {
          var kz = keys.apply(this, arguments),
            i,
            m = data.length,
            n = kz.length,
            sz = new Array(n),
            oz

          for (i = 0; i < n; ++i) {
            for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
              si[j] = sij = [0, +value(data[j], ki, j, data)]
              sij.data = data[j]
            }
            si.key = ki
          }

          for (i = 0, oz = order(sz); i < n; ++i) {
            sz[oz[i]].index = i
          }

          offset(sz, oz)
          return sz
        }

        stack.keys = function (_) {
          return arguments.length ? (keys = typeof _ === 'function' ? _ : (0, _constant2.default)(_array.slice.call(_)), stack) : keys
        }

        stack.value = function (_) {
          return arguments.length ? (value = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), stack) : value
        }

        stack.order = function (_) {
          return arguments.length ? (order = _ == null ? _none4.default : typeof _ === 'function' ? _ : (0, _constant2.default)(_array.slice.call(_)), stack) : order
        }

        stack.offset = function (_) {
          return arguments.length ? (offset = _ == null ? _none2.default : _, stack) : offset
        }

        return stack
      }

      var _array = __webpack_require__(255)

      var _constant = __webpack_require__(31)

      var _constant2 = _interopRequireDefault(_constant)

      var _none = __webpack_require__(50)

      var _none2 = _interopRequireDefault(_none)

      var _none3 = __webpack_require__(51)

      var _none4 = _interopRequireDefault(_none3)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }

      function stackValue(d, key) {
        return d[key]
      }
      /***/
    },
    /* 694 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series, order) {
        if (!((n = series.length) > 0)) return
        for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
          for (y = i = 0; i < n; ++i) {
            y += series[i][j][1] || 0
          }
          if (y) {
            for (i = 0; i < n; ++i) {
              series[i][j][1] /= y
            }
          }
        }
        (0, _none2.default)(series, order)
      }

      var _none = __webpack_require__(50)

      var _none2 = _interopRequireDefault(_none)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 695 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (series, order) {
        if (!((n = series.length) > 1)) return
        for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
          for (yp = yn = 0, i = 0; i < n; ++i) {
            if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
              d[0] = yp, d[1] = yp += dy
            } else if (dy < 0) {
              d[1] = yn, d[0] = yn += dy
            } else {
              d[0] = yp
            }
          }
        }
      }
      /***/
    },
    /* 696 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series, order) {
        if (!((n = series.length) > 0)) return
        for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
          for (var i = 0, y = 0; i < n; ++i) {
            y += series[i][j][1] || 0
          }
          s0[j][1] += s0[j][0] = -y / 2
        }
        (0, _none2.default)(series, order)
      }

      var _none = __webpack_require__(50)

      var _none2 = _interopRequireDefault(_none)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 697 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series, order) {
        if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return
        for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
          for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
            var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2
            for (var k = 0; k < i; ++k) {
              var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0
              s3 += skj0 - skj1
            }
            s1 += sij0, s2 += s3 * sij0
          }
          s0[j - 1][1] += s0[j - 1][0] = y
          if (s1) y -= s2 / s1
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        (0, _none2.default)(series, order)
      }

      var _none = __webpack_require__(50)

      var _none2 = _interopRequireDefault(_none)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 698 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series) {
        return (0, _ascending2.default)(series).reverse()
      }

      var _ascending = __webpack_require__(133)

      var _ascending2 = _interopRequireDefault(_ascending)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 699 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series) {
        var n = series.length,
          i,
          j,
          sums = series.map(_ascending.sum),
          order = (0, _none2.default)(series).sort(function (a, b) {
            return sums[b] - sums[a]
          }),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = []

        for (i = 0; i < n; ++i) {
          j = order[i]
          if (top < bottom) {
            top += sums[j]
            tops.push(j)
          } else {
            bottom += sums[j]
            bottoms.push(j)
          }
        }

        return bottoms.reverse().concat(tops)
      }

      var _none = __webpack_require__(51)

      var _none2 = _interopRequireDefault(_none)

      var _ascending = __webpack_require__(133)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 700 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function (series) {
        return (0, _none2.default)(series).reverse()
      }

      var _none = __webpack_require__(51)

      var _none2 = _interopRequireDefault(_none)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 701 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var d3Voronoi = __webpack_require__(702)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        // fields: [ 'x', 'y' ] // field x and field y, required
        // extend: [[x0, y0], [x1, y1]], // optional
        // size: [width, height], // optional
        as: ['_x', '_y']
      }

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)

        var as = options.as
        if (!Array.isArray(as) || as.length !== 2) {
          throw new TypeError('Invalid as: must be an array with two strings!')
        }
        var xField = as[0]
        var yField = as[1]

        var fields = getFields(options)
        if (!Array.isArray(fields) && fields.length !== 2) {
          throw new TypeError('Invalid fields: must be an array with two strings!')
        }
        var x = fields[0]
        var y = fields[1]

        var rows = dataView.rows
        var data = rows.map(function (row) {
          return [row[x], row[y]]
        })
        var voronoi = d3Voronoi.voronoi()
        if (options.extend) {
          voronoi.extent(options.extend)
        }
        if (options.size) {
          voronoi.size(options.size)
        }
        var polygons = voronoi(data).polygons()
        rows.forEach(function (row, i) {
          var polygon = polygons[i].filter(function (point) {
            return !!point
          }) // some points are null
          row[xField] = polygon.map(function (point) {
            return point[0]
          })
          row[yField] = polygon.map(function (point) {
            return point[1]
          })
        })
      }

      registerTransform('diagram.voronoi', transform)
      registerTransform('voronoi', transform)
      /***/
    },
    /* 702 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      var _voronoi = __webpack_require__(703)

      Object.defineProperty(exports, 'voronoi', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_voronoi).default
        }
      })

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 703 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true

      exports.default = function () {
        var x = _point.x,
          y = _point.y,
          extent = null

        function voronoi(data) {
          return new _Diagram2.default(data.map(function (d, i) {
            var s = [Math.round(x(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon, Math.round(y(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon]
            s.index = i
            s.data = d
            return s
          }), extent)
        }

        voronoi.polygons = function (data) {
          return voronoi(data).polygons()
        }

        voronoi.links = function (data) {
          return voronoi(data).links()
        }

        voronoi.triangles = function (data) {
          return voronoi(data).triangles()
        }

        voronoi.x = function (_) {
          return arguments.length ? (x = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), voronoi) : x
        }

        voronoi.y = function (_) {
          return arguments.length ? (y = typeof _ === 'function' ? _ : (0, _constant2.default)(+_), voronoi) : y
        }

        voronoi.extent = function (_) {
          return arguments.length ? (extent = _ == null ? null : [
            [+_[0][0], +_[0][1]],
            [+_[1][0], +_[1][1]]
          ], voronoi) : extent && [
            [extent[0][0], extent[0][1]],
            [extent[1][0], extent[1][1]]
          ]
        }

        voronoi.size = function (_) {
          return arguments.length ? (extent = _ == null ? null : [
            [0, 0],
            [+_[0], +_[1]]
          ], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]]
        }

        return voronoi
      }

      var _constant = __webpack_require__(704)

      var _constant2 = _interopRequireDefault(_constant)

      var _point = __webpack_require__(705)

      var _Diagram = __webpack_require__(52)

      var _Diagram2 = _interopRequireDefault(_Diagram)

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        }
      }
      /***/
    },
    /* 704 */
    /***/
    function (module, exports) {
      exports.__esModule = true

      exports.default = function (x) {
        return function () {
          return x
        }
      }
      /***/
    },
    /* 705 */
    /***/
    function (module, exports) {
      exports.__esModule = true
      exports.x = x
      exports.y = y

      function x(d) {
        return d[0]
      }

      function y(d) {
        return d[1]
      }
      /***/
    },
    /* 706 */
    /***/
    function (module, exports, __webpack_require__) {
      exports.__esModule = true
      exports.removeBeach = removeBeach
      exports.addBeach = addBeach

      var _RedBlackTree = __webpack_require__(134)

      var _Cell = __webpack_require__(265)

      var _Circle = __webpack_require__(266)

      var _Edge = __webpack_require__(135)

      var _Diagram = __webpack_require__(52)

      var beachPool = []

      function Beach() {
        (0, _RedBlackTree.RedBlackNode)(this)
        this.edge = this.site = this.circle = null
      }

      function createBeach(site) {
        var beach = beachPool.pop() || new Beach()
        beach.site = site
        return beach
      }

      function detachBeach(beach) {
        (0, _Circle.detachCircle)(beach)
        _Diagram.beaches.remove(beach)
        beachPool.push(beach);
        (0, _RedBlackTree.RedBlackNode)(beach)
      }

      function removeBeach(beach) {
        var circle = beach.circle,
          x = circle.x,
          y = circle.cy,
          vertex = [x, y],
          previous = beach.P,
          next = beach.N,
          disappearing = [beach]

        detachBeach(beach)

        var lArc = previous
        while (lArc.circle && Math.abs(x - lArc.circle.x) < _Diagram.epsilon && Math.abs(y - lArc.circle.cy) < _Diagram.epsilon) {
          previous = lArc.P
          disappearing.unshift(lArc)
          detachBeach(lArc)
          lArc = previous
        }

        disappearing.unshift(lArc);
        (0, _Circle.detachCircle)(lArc)

        var rArc = next
        while (rArc.circle && Math.abs(x - rArc.circle.x) < _Diagram.epsilon && Math.abs(y - rArc.circle.cy) < _Diagram.epsilon) {
          next = rArc.N
          disappearing.push(rArc)
          detachBeach(rArc)
          rArc = next
        }

        disappearing.push(rArc);
        (0, _Circle.detachCircle)(rArc)

        var nArcs = disappearing.length,
          iArc
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc]
          lArc = disappearing[iArc - 1];
          (0, _Edge.setEdgeEnd)(rArc.edge, lArc.site, rArc.site, vertex)
        }

        lArc = disappearing[0]
        rArc = disappearing[nArcs - 1]
        rArc.edge = (0, _Edge.createEdge)(lArc.site, rArc.site, null, vertex);

        (0, _Circle.attachCircle)(lArc);
        (0, _Circle.attachCircle)(rArc)
      }

      function addBeach(site) {
        var x = site[0],
          directrix = site[1],
          lArc,
          rArc,
          dxl,
          dxr,
          node = _Diagram.beaches._

        while (node) {
          dxl = leftBreakPoint(node, directrix) - x
          if (dxl > _Diagram.epsilon) node = node.L;
          else {
            dxr = x - rightBreakPoint(node, directrix)
            if (dxr > _Diagram.epsilon) {
              if (!node.R) {
                lArc = node
                break
              }
              node = node.R
            } else {
              if (dxl > -_Diagram.epsilon) {
                lArc = node.P
                rArc = node
              } else if (dxr > -_Diagram.epsilon) {
                lArc = node
                rArc = node.N
              } else {
                lArc = rArc = node
              }
              break
            }
          }
        }

        (0, _Cell.createCell)(site)
        var newArc = createBeach(site)
        _Diagram.beaches.insert(lArc, newArc)

        if (!lArc && !rArc) return

        if (lArc === rArc) {
          (0, _Circle.detachCircle)(lArc)
          rArc = createBeach(lArc.site)
          _Diagram.beaches.insert(newArc, rArc)
          newArc.edge = rArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site);
          (0, _Circle.attachCircle)(lArc);
          (0, _Circle.attachCircle)(rArc)
          return
        }

        if (!rArc) {
          // && lArc
          newArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site)
          return
        }

        // else lArc !== rArc
        (0, _Circle.detachCircle)(lArc);
        (0, _Circle.detachCircle)(rArc)

        var lSite = lArc.site,
          ax = lSite[0],
          ay = lSite[1],
          bx = site[0] - ax,
          by = site[1] - ay,
          rSite = rArc.site,
          cx = rSite[0] - ax,
          cy = rSite[1] - ay,
          d = 2 * (bx * cy - by * cx),
          hb = bx * bx + by * by,
          hc = cx * cx + cy * cy,
          vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

        (0, _Edge.setEdgeEnd)(rArc.edge, lSite, rSite, vertex)
        newArc.edge = (0, _Edge.createEdge)(lSite, site, null, vertex)
        rArc.edge = (0, _Edge.createEdge)(site, rSite, null, vertex);
        (0, _Circle.attachCircle)(lArc);
        (0, _Circle.attachCircle)(rArc)
      }

      function leftBreakPoint(arc, directrix) {
        var site = arc.site,
          rfocx = site[0],
          rfocy = site[1],
          pby2 = rfocy - directrix

        if (!pby2) return rfocx

        var lArc = arc.P
        if (!lArc) return -Infinity

        site = lArc.site
        var lfocx = site[0],
          lfocy = site[1],
          plby2 = lfocy - directrix

        if (!plby2) return lfocx

        var hl = lfocx - rfocx,
          aby2 = 1 / pby2 - 1 / plby2,
          b = hl / plby2

        if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx

        return (rfocx + lfocx) / 2
      }

      function rightBreakPoint(arc, directrix) {
        var rArc = arc.N
        if (rArc) return leftBreakPoint(rArc, directrix)
        var site = arc.site
        return site[1] === directrix ? site[0] : Infinity
      }
      /***/
    },
    /* 707 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var d3Hierarchy = __webpack_require__(120)

      var _require = __webpack_require__(2),
        HIERARCHY = _require.HIERARCHY,
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        field: 'value',
        tile: 'treemapSquarify', // treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify
        size: [1, 1], // width, height
        round: false,
        // ratio: 1.618033988749895, // golden ratio
        padding: 0,
        paddingInner: 0,
        paddingOuter: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        as: ['x', 'y']
      }

      function transform(dataView, options) {
        if (dataView.dataType !== HIERARCHY) {
          throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!')
        }
        var root = dataView.root
        options = assign({}, DEFAULT_OPTIONS, options)

        var as = options.as
        if (!Array.isArray(as) || as.length !== 2) {
          throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!')
        }

        var field = void 0
        try {
          field = getField(options)
        } catch (e) {
          console.warn(e)
        }
        if (field) {
          root.sum(function (d) {
            return d[field]
          })
        }

        var treemapLayout = d3Hierarchy.treemap()
        treemapLayout.tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)
        treemapLayout(root)

        /*
         * points:
         *   3  2
         *   0  1
         */
        var x = as[0]
        var y = as[1]
        root.each(function (node) {
          node[x] = [node.x0, node.x1, node.x1, node.x0]
          node[y] = [node.y1, node.y1, node.y0, node.y0];
          ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
            if (as.indexOf(prop) === -1) {
              delete node[prop]
            }
          })
        })
      }

      registerTransform('hierarchy.treemap', transform)
      registerTransform('treemap', transform)
      /***/
    },
    /* 708 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var d3Hierarchy = __webpack_require__(120)

      var _require = __webpack_require__(2),
        HIERARCHY = _require.HIERARCHY,
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getField = _require2.getField

      var DEFAULT_OPTIONS = {
        field: 'value',
        size: [1, 1], // width, height
        round: false,
        // ratio: 1.618033988749895, // golden ratio
        padding: 0,
        sort: true,
        as: ['x', 'y']
      }

      function transform(dataView, options) {
        if (dataView.dataType !== HIERARCHY) {
          throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!')
        }
        var root = dataView.root
        options = assign({}, DEFAULT_OPTIONS, options)

        var as = options.as
        if (!Array.isArray(as) || as.length !== 2) {
          throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!')
        }

        var field = void 0
        try {
          field = getField(options)
        } catch (e) {
          console.warn(e)
        }
        if (field) {
          root.sum(function (d) {
            return d[field]
          })
        }

        var partitionLayout = d3Hierarchy.partition()
        partitionLayout.size(options.size).round(options.round).padding(options.padding)
        partitionLayout(root)

        /*
         * points:
         *   3  2
         *   0  1
         */
        var x = as[0]
        var y = as[1]
        root.each(function (node) {
          node[x] = [node.x0, node.x1, node.x1, node.x0]
          node[y] = [node.y1, node.y1, node.y0, node.y0];
          ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
            if (as.indexOf(prop) === -1) {
              delete node[prop]
            }
          })
        })
      }

      registerTransform('hierarchy.partition', transform)
      registerTransform('adjacency', transform)
      /***/
    },
    /* 709 */
    /***/
    function (module, exports, __webpack_require__) {
      var assign = __webpack_require__(5)
      var isString = __webpack_require__(7)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var tagCloud = __webpack_require__(710)

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var DEFAULT_OPTIONS = {
        fields: ['text', 'value'], // fields to keep
        font: 'serif',
        padding: 1,
        size: [500, 500],
        spiral: 'archimedean', // 'archimedean' || 'rectangular' || {function}
        timeInterval: Infinity // max execute time
        // imageMask: '', // instance of Image, must be loaded
      }

      function transform(dataView, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var layout = tagCloud();
        ['font', 'padding', 'size', 'spiral', 'timeInterval'].forEach(function (key) {
          layout[key](options[key])
        })
        var fields = getFields(options)
        var text = fields[0],
          value = fields[1]

        if (!isString(text) || !isString(value)) {
          throw new TypeError('Invalid fields: must be an array with 2 strings (e.g. [ "text", "value" ])!')
        }
        var words = dataView.rows.map(function (row) {
          var word = {}
          word.text = row[text]
          word.value = row[value]
          return word
        })
        layout.words(words)
        if (options.imageMask) {
          layout.createMask(options.imageMask)
        }

        var _layout$execute = layout.execute(),
          tags = _layout$execute.tags

        dataView.rows = tags
      }

      registerTransform('tag-cloud', transform)
      registerTransform('word-cloud', transform)
      /***/
    },
    /* 710 */
    /***/
    function (module, exports) {
      /*
       * Synchronous version of d3-cloud
       */
      // Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
      // Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
      /* eslint-disable no-return-assign, no-cond-assign */

      var cloudRadians = Math.PI / 180
      var cw = 1 << 11 >> 5
      var ch = 1 << 11

      function cloudText(d) {
        return d.text
      }

      function cloudFont() {
        return 'serif'
      }

      function cloudFontNormal() {
        return 'normal'
      }

      function cloudFontSize(d) {
        return Math.sqrt(d.value)
      }

      function cloudRotate() {
        return (~~(Math.random() * 6) - 3) * 30
      }

      function cloudPadding() {
        return 1
      }

      // Fetches a monochrome sprite bitmap for the specified text.
      // Load in batches for speed.
      function cloudSprite(contextAndRatio, d, data, di) {
        if (d.sprite) return
        var c = contextAndRatio.context
        var ratio = contextAndRatio.ratio

        c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio)
        var x = 0
        var y = 0
        var maxh = 0
        var n = data.length
          --di
        while (++di < n) {
          d = data[di]
          c.save()
          c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font
          var w = c.measureText(d.text + 'm').width * ratio,
            h = d.size << 1
          if (d.rotate) {
            var sr = Math.sin(d.rotate * cloudRadians)
            var cr = Math.cos(d.rotate * cloudRadians)
            var wcr = w * cr
            var wsr = w * sr
            var hcr = h * cr
            var hsr = h * sr
            w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5
            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr))
          } else {
            w = w + 0x1f >> 5 << 5
          }
          if (h > maxh) maxh = h
          if (x + w >= cw << 5) {
            x = 0
            y += maxh
            maxh = 0
          }
          if (y + h >= ch) break
          c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio)
          if (d.rotate) c.rotate(d.rotate * cloudRadians)
          c.fillText(d.text, 0, 0)
          if (d.padding) {
            c.lineWidth = 2 * d.padding
            c.strokeText(d.text, 0, 0)
          }
          c.restore()
          d.width = w
          d.height = h
          d.xoff = x
          d.yoff = y
          d.x1 = w >> 1
          d.y1 = h >> 1
          d.x0 = -d.x1
          d.y0 = -d.y1
          d.hasText = true
          x += w
        }
        var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data
        var sprite = []
        while (--di >= 0) {
          d = data[di]
          if (!d.hasText) continue
          var _w = d.width
          var w32 = _w >> 5
          var _h = d.y1 - d.y0
          // Zero the buffer
          for (var i = 0; i < _h * w32; i++) {
            sprite[i] = 0
          }
          x = d.xoff
          if (x == null) return
          y = d.yoff
          var seen = 0,
            seenRow = -1
          for (var j = 0; j < _h; j++) {
            for (var _i = 0; _i < _w; _i++) {
              var k = w32 * j + (_i >> 5)
              var m = pixels[(y + j) * (cw << 5) + (x + _i) << 2] ? 1 << 31 - _i % 32 : 0
              sprite[k] |= m
              seen |= m
            }
            if (seen) seenRow = j;
            else {
              d.y0++
                _h--
                j--
                y++
            }
          }
          d.y1 = d.y0 + seenRow
          d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32)
        }
      }

      // Use mask-based collision detection.
      function cloudCollide(tag, board, sw) {
        sw >>= 5
        var sprite = tag.sprite
        var w = tag.width >> 5
        var lx = tag.x - (w << 4)
        var sx = lx & 0x7f
        var msx = 32 - sx
        var h = tag.y1 - tag.y0
        var x = (tag.y + tag.y0) * sw + (lx >> 5)
        var last = void 0
        for (var j = 0; j < h; j++) {
          last = 0
          for (var i = 0; i <= w; i++) {
            if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true
          }
          x += sw
        }
        return false
      }

      function cloudBounds(bounds, d) {
        var b0 = bounds[0]
        var b1 = bounds[1]
        if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0
        if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0
        if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1
        if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1
      }

      function collideRects(a, b) {
        return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y
      }

      function archimedeanSpiral(size) {
        var e = size[0] / size[1]
        return function (t) {
          return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)]
        }
      }

      function rectangularSpiral(size) {
        var dy = 4
        var dx = dy * size[0] / size[1]
        var x = 0
        var y = 0
        return function (t) {
          var sign = t < 0 ? -1 : 1
          // See triangular numbers: T_n = n * (n + 1) / 2.
          switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
            case 0:
              x += dx;
              break
            case 1:
              y += dy;
              break
            case 2:
              x -= dx;
              break
            default:
              y -= dy;
              break
          }
          return [x, y]
        }
      }

      // TODO reuse arrays?
      function zeroArray(n) {
        var a = []
        var i = -1
        while (++i < n) {
          a[i] = 0
        }
        return a
      }

      function cloudCanvas() {
        return document.createElement('canvas')
      }

      function functor(d) {
        return typeof d === 'function' ? d : function () {
          return d
        }
      }

      var spirals = {
        archimedean: archimedeanSpiral,
        rectangular: rectangularSpiral
      }

      var tagCloud = function tagCloud() {
        // TODO image mask

        var size = [256, 256]
        var text = cloudText
        var font = cloudFont
        var fontSize = cloudFontSize
        var fontStyle = cloudFontNormal
        var fontWeight = cloudFontNormal
        var rotate = cloudRotate
        var padding = cloudPadding
        var spiral = archimedeanSpiral
        var words = []
        var timeInterval = Infinity
        var random = Math.random
        var cloud = {}
        var canvas = cloudCanvas

        cloud.canvas = function (_) {
          return arguments.length ? (canvas = functor(_), cloud) : canvas
        }

        cloud.start = cloud.exec = cloud.execute = function () {
          // origin: cloud.start
          var contextAndRatio = getContext(canvas())
          var board = cloud.board || zeroArray((size[0] >> 5) * size[1])
          var bounds = null
          var n = words.length
          var tags = []
          var data = words.map(function (d, i) {
            d.text = text.call(this, d, i)
            d.font = font.call(this, d, i)
            d.style = fontStyle.call(this, d, i)
            d.weight = fontWeight.call(this, d, i)
            d.rotate = rotate.call(this, d, i)
            d.size = ~~fontSize.call(this, d, i)
            d.padding = padding.call(this, d, i)
            return d
          }).sort(function (a, b) {
            return b.size - a.size
          })
          var i = -1

          step()

          cloud.tags = tags
          cloud.bounds = bounds

          return cloud

          function step() {
            var start = Date.now()
            while (Date.now() - start < timeInterval && ++i < n) {
              var d = data[i]
              d.x = size[0] * (random() + 0.5) >> 1
              d.y = size[1] * (random() + 0.5) >> 1
              cloudSprite(contextAndRatio, d, data, i)
              if (d.hasText && place(board, d, bounds)) {
                tags.push(d)
                if (bounds) cloudBounds(bounds, d);
                else bounds = [{
                  x: d.x + d.x0,
                  y: d.y + d.y0
                }, {
                  x: d.x + d.x1,
                  y: d.y + d.y1
                }]
                // Temporary hack
                d.x -= size[0] >> 1
                d.y -= size[1] >> 1
              }
            }
          }
        }

        function getContext(canvas) {
          canvas.width = canvas.height = 1
          var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2)
          canvas.width = (cw << 5) / ratio
          canvas.height = ch / ratio

          var context = canvas.getContext('2d')
          context.fillStyle = context.strokeStyle = 'red'
          context.textAlign = 'center'

          return {
            context: context,
            ratio: ratio
          }
        }

        function place(board, tag, bounds) {
          // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }];
          var startX = tag.x
          var startY = tag.y
          var maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1])
          var s = spiral(size)
          var dt = random() < 0.5 ? 1 : -1
          var t = -dt
          var dxdy = void 0
          var dx = void 0
          var dy = void 0

          while (dxdy = s(t += dt)) {
            dx = ~~dxdy[0]
            dy = ~~dxdy[1]

            if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break

            tag.x = startX + dx
            tag.y = startY + dy

            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue
            // TODO only check for collisions within current bounds.
            if (!bounds || !cloudCollide(tag, board, size[0])) {
              if (!bounds || collideRects(tag, bounds)) {
                var sprite = tag.sprite
                var w = tag.width >> 5
                var sw = size[0] >> 5
                var lx = tag.x - (w << 4)
                var sx = lx & 0x7f
                var msx = 32 - sx
                var h = tag.y1 - tag.y0
                var x = (tag.y + tag.y0) * sw + (lx >> 5)
                var last = void 0
                for (var j = 0; j < h; j++) {
                  last = 0
                  for (var i = 0; i <= w; i++) {
                    board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)
                  }
                  x += sw
                }
                delete tag.sprite
                return true
              }
            }
          }
          return false
        }

        cloud.createMask = function (img) {
          var can = document.createElement('canvas')
          var _size = size,
            width = _size[0],
            height = _size[1]

          var w32 = width >> 5
          var board = zeroArray((width >> 5) * height)
          can.width = width
          can.height = height
          var cxt = can.getContext('2d')
          cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height)
          var imageData = cxt.getImageData(0, 0, can.width, can.height).data
          // 
          for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++) {
              var k = w32 * j + (i >> 5)
              var tmp = j * width + i << 2
              var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250
              var m = flag ? 1 << 31 - i % 32 : 0
              board[k] |= m
            }
          }
          cloud.board = board
          cloud.hasImage = true
        }

        cloud.timeInterval = function (_) {
          return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval
        }

        cloud.words = function (_) {
          return arguments.length ? (words = _, cloud) : words
        }

        cloud.size = function (_) {
          return arguments.length ? (size = [+_[0], +_[1]], cloud) : size
        }

        cloud.font = function (_) {
          return arguments.length ? (font = functor(_), cloud) : font
        }

        cloud.fontStyle = function (_) {
          return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle
        }

        cloud.fontWeight = function (_) {
          return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight
        }

        cloud.rotate = function (_) {
          return arguments.length ? (rotate = functor(_), cloud) : rotate
        }

        cloud.text = function (_) {
          return arguments.length ? (text = functor(_), cloud) : text
        }

        cloud.spiral = function (_) {
          return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral
        }

        cloud.fontSize = function (_) {
          return arguments.length ? (fontSize = functor(_), cloud) : fontSize
        }

        cloud.padding = function (_) {
          return arguments.length ? (padding = functor(_), cloud) : padding
        }

        cloud.random = function (_) {
          return arguments.length ? (random = _, cloud) : random
        }

        return cloud
      }

      module.exports = tagCloud
      /***/
    },
    /* 711 */
    /***/
    function (module, exports, __webpack_require__) {
      /*
       * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js
       */
      var assign = __webpack_require__(5)
      var isFunction = __webpack_require__(8)
      var isNumber = __webpack_require__(126)
      var isString = __webpack_require__(7)
      var keys = __webpack_require__(9)
      // const regression = require('regression');
      var getSeriesValues = __webpack_require__(127)
      // const enclideanDistance = require('../../util/euclidean-distance');
      var kernel = __webpack_require__(267)

      var _require = __webpack_require__(2),
        registerTransform = _require.registerTransform

      var _require2 = __webpack_require__(6),
        getFields = _require2.getFields

      var _require3 = __webpack_require__(128),
        silverman = _require3.silverman

      var isArray = Array.isArray

      var DEFAULT_OPTIONS = {
        as: ['x', 'y', 'z'],
        // fields: [ 'x', 'y' ], // required, one or two fields
        method: 'gaussian', // kernel method: should be one of _.keys(kernel)
        extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]
        bandwidth: [] // bandWidth to execute kernel function
      }

      var KERNEL_METHODS = keys(kernel)

      function transform(dv, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var fields = getFields(options)
        if (!isArray(fields) || fields.length !== 2) {
          throw new TypeError('invalid fields: must be an array of 2 strings!')
        }
        var _options$as = options.as,
          asX = _options$as[0],
          asY = _options$as[1],
          asZ = _options$as[2]

        if (!isString(asX) || !isString(asY) || !isString(asZ)) {
          throw new TypeError('invalid as: must be an array of 3 strings!')
        }
        var method = options.method
        if (isString(method)) {
          if (KERNEL_METHODS.indexOf(method) === -1) {
            throw new TypeError('invalid method: ' + method + '. Must be one of ' + KERNEL_METHODS.join(', '))
          }
          method = kernel[method]
        }
        if (!isFunction(method)) {
          throw new TypeError('invalid method: kernel method must be a function!')
        }

        var xField = fields[0],
          yField = fields[1]
        var _options$extent = options.extent,
          extentX = _options$extent[0],
          extentY = _options$extent[1]

        if (!isArray(extentX) || !isArray(extentY)) {
          extentX = dv.range(xField)
          extentY = dv.range(yField)
        }
        var _options$bandwidth = options.bandwidth,
          bwX = _options$bandwidth[0],
          bwY = _options$bandwidth[1]

        if (!isNumber(bwX) || bwX <= 0 || !isNumber(bwY) || bwY <= 0) {
          bwX = silverman(dv.getColumn(xField))
          bwY = silverman(dv.getColumn(yField))
        }
        var seriesValuesX = getSeriesValues(extentX, bwX)
        var seriesValuesY = getSeriesValues(extentY, bwY)
        var count = dv.rows.length
        var result = []

        for (var i = 0; i < seriesValuesX.length; i++) {
          for (var j = 0; j < seriesValuesY.length; j++) {
            var sum = 0
            var x = seriesValuesX[i]
            var y = seriesValuesY[j]
            for (var k = 0; k < count; k++) {
              sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY)
            }
            var z = 1 / (count * bwX * bwY) * sum
            var row = {}
            row[asX] = x
            row[asY] = y
            row[asZ] = z
            result.push(row)
          }
        }

        dv.rows = result
      }

      registerTransform('kernel-smooth.density', transform)
      registerTransform('kernel.density', transform)

      module.exports = {
        KERNEL_METHODS: KERNEL_METHODS
      }
      /***/
    },
    /* 712 */
    /***/
    function (module, exports, __webpack_require__) {
      /*
       * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js
       */
      var assign = __webpack_require__(5)
      var isFunction = __webpack_require__(8)
      var isNil = __webpack_require__(118)
      var isNumber = __webpack_require__(126)
      var isString = __webpack_require__(7)
      var keys = __webpack_require__(9)
      // const regression = require('regression');

      var _require = __webpack_require__(30),
        sum = _require.sum

      var getSeriesValues = __webpack_require__(127)
      // const enclideanDistance = require('../../util/euclidean-distance');
      var kernel = __webpack_require__(267)

      var _require2 = __webpack_require__(2),
        registerTransform = _require2.registerTransform

      var _require3 = __webpack_require__(6),
        getFields = _require3.getFields

      var _require4 = __webpack_require__(128),
        silverman = _require4.silverman

      var isArray = Array.isArray

      var DEFAULT_OPTIONS = {
        as: ['x', 'y'],
        // fields: [ 'x', 'y' ], // required, one or two fields
        method: 'gaussian' // kernel method: should be one of _.keys(kernel)
        // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]
        // bandwidth: 0.5 // bandWidth to execute kernel function
      }

      var KERNEL_METHODS = keys(kernel)

      // calculates weight for i-th obs
      function weight(kernel, bandwidth, x_0, x_i) {
        var arg = (x_i - x_0) / bandwidth
        return kernel(arg)
      }
      // calculates weight for i-th obs when p > 1
      // function weight_vectors(kernel, bandwidth, x_0, x_i) {
      //   const arg = enclideanDistance(x_i, x_0) / bandwidth;
      //   return kernel(arg);
      // }
      function vectorize(fun) {
        return function (x) {
          if (!isArray(x)) {
            return fun(x)
          }
          return x.map(function (x) {
            return fun(x)
          })
        }
      }

      function transform(dv, options) {
        options = assign({}, DEFAULT_OPTIONS, options)
        var fields = getFields(options)
        if (!isArray(fields) || fields.length !== 1 && fields.length !== 2) {
          throw new TypeError('invalid fields: must be an array of 1 or 2 strings!')
        }
        var _options$as = options.as,
          asX = _options$as[0],
          asY = _options$as[1]

        if (!isString(asX) || !isString(asY)) {
          throw new TypeError('invalid as: must be an array of 2 strings!')
        }
        var method = options.method
        if (isString(method)) {
          if (KERNEL_METHODS.indexOf(method) === -1) {
            throw new TypeError('invalid method: ' + method + '. Must be one of ' + KERNEL_METHODS.join(', '))
          }
          method = kernel[method]
        }
        if (!isFunction(method)) {
          throw new TypeError('invalid method: kernel method must be a function!')
        }

        var xField = fields[0],
          yField = fields[1]

        var xs = dv.getColumn(xField)

        var extent = options.extent
        if (!isArray(extent)) {
          extent = dv.range(xField)
        }
        var bandwidth = options.bandwidth
        if (!isNumber(bandwidth) || bandwidth <= 0) {
          bandwidth = silverman(xs)
        }
        var seriesValues = getSeriesValues(extent, bandwidth)
        var xCount = xs.length
        var weightFunc = weight.bind(null, method, bandwidth)
        var kernelSmoother = void 0

        if (isNil(yField)) {
          // KDE
          kernelSmoother = vectorize(function (x) {
            var weights = xs.map(function (x_i) {
              return weightFunc(x, x_i)
            })
            var num = sum(weights)
            var denom = xCount * bandwidth
            if (!num || !denom) return 0
            return num / denom
          })
        } else {
          // kernel regression smoothing
          var ys = dv.getColumn(yField)
          kernelSmoother = vectorize(function (x) {
            var weights = xs.map(function (x_i) {
              return weightFunc(x, x_i)
            })
            var num = sum(weights.map(function (w, i) {
              return w * ys[i]
            }))
            var denom = sum(weights)
            if (!num || !denom) return 0
            return num / denom
          })
        }

        var result = seriesValues.map(function (x) {
          var row = {}
          row[asX] = x
          row[asY] = kernelSmoother(x)
          return row
        })
        dv.rows = result
      }

      registerTransform('kernel-smooth.regression', transform)
      registerTransform('kernel.regression', transform)

      module.exports = {
        KERNEL_METHODS: KERNEL_METHODS
      }
      /***/
    }
    /******/
  ])
})
