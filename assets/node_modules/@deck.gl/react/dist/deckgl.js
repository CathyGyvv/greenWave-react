"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _autobind = _interopRequireDefault(require("./utils/autobind"));

var _inheritsFrom = require("./utils/inherits-from");

var _core = require("@deck.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var propTypes = Object.assign({}, _core.Deck.getPropTypes(_propTypes.default), {
  viewports: _propTypes.default.array,
  // Deprecated
  viewport: _propTypes.default.object // Deprecated

});
var defaultProps = _core.Deck.defaultProps;

var DeckGL =
/*#__PURE__*/
function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    var _this;

    _classCallCheck(this, DeckGL);

    _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));
    _this.state = {};
    _this.children = [];
    (0, _autobind.default)(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(DeckGL, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.deck = new _core.Deck(Object.assign({}, this.props, {
        canvas: this.deckCanvas,
        viewState: this._getViewState(this.props),
        // Note: If Deck event handling change size or view state, it calls onResize to update
        onViewStateChange: this._onViewStateChange,
        onResize: this._onResize
      }));

      this._updateFromProps(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this._updateFromProps(nextProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.deck.finalize();
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;
      return this.deck.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds
      });
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? 10 : _ref2$depth;
      return this.deck.pickMultipleObjects({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        depth: depth
      });
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;
      return this.deck.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
    }
  }, {
    key: "queryObject",
    value: function queryObject(opts) {
      _core.log.deprecated('queryObject', 'pickObject')();

      return this.deck.pickObject(opts);
    }
  }, {
    key: "queryVisibleObjects",
    value: function queryVisibleObjects(opts) {
      _core.log.deprecated('queryVisibleObjects', 'pickObjects')();

      return this.pickObjects(opts);
    } // Callbacks
    // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onResize",
    value: function _onResize() {
      if (this.props.onResize) {
        var _this$props;

        (_this$props = this.props).onResize.apply(_this$props, arguments);
      }

      this.forceUpdate();
    } // Forward callback and then call forceUpdate to guarantee that sub components update

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange() {
      if (this.props.onViewStateChange) {
        var _this$props2;

        (_this$props2 = this.props).onViewStateChange.apply(_this$props2, arguments);
      }

      this.forceUpdate();
    } // Private Helpers
    // 1. Extract any JSX layers from the react children
    // 2. Handle any backwards compatiblity props for React layer
    // Needs to be called both from initial mount, and when new props arrive

  }, {
    key: "_updateFromProps",
    value: function _updateFromProps(nextProps) {
      // extract any deck.gl layers masquerading as react elements from props.children
      var _this$_extractJSXLaye = this._extractJSXLayers(nextProps.children),
          layers = _this$_extractJSXLaye.layers,
          children = _this$_extractJSXLaye.children;

      if (this.deck) {
        this.deck.setProps(Object.assign({}, nextProps, {
          views: this._getViews(nextProps),
          viewState: this._getViewState(nextProps),
          // Avoid modifying layers array if no JSX layers were found
          layers: layers ? _toConsumableArray(layers).concat(_toConsumableArray(nextProps.layers)) : nextProps.layers
        }));
      }

      this.children = children;
    } // Support old `viewports` prop (React only!)

  }, {
    key: "_getViews",
    value: function _getViews(props) {
      if (props.viewports) {
        _core.log.deprecated('DeckGL.viewports', 'DeckGL.views')();
      }

      if (props.viewport) {
        _core.log.deprecated('DeckGL.viewport', 'DeckGL.views')();
      }

      return props.views || props.viewports || props.viewport && [props.viewport];
    } // Supports old "geospatial view state as separate props" style (React only!)

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      var viewState = props.viewState;

      if (!viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {
        var latitude = props.latitude,
            longitude = props.longitude,
            zoom = props.zoom,
            _props$pitch = props.pitch,
            pitch = _props$pitch === void 0 ? 0 : _props$pitch,
            _props$bearing = props.bearing,
            bearing = _props$bearing === void 0 ? 0 : _props$bearing;
        viewState = props.viewState || {
          latitude: latitude,
          longitude: longitude,
          zoom: zoom,
          pitch: pitch,
          bearing: bearing
        };
      }

      return viewState;
    } // extracts any deck.gl layers masquerading as react elements from props.children

  }, {
    key: "_extractJSXLayers",
    value: function _extractJSXLayers(children) {
      var reactChildren = []; // extract real react elements (i.e. not deck.gl layers)

      var layers = null; // extracted layer from react children, will add to deck.gl layer array

      _react.default.Children.forEach(children, function (reactElement) {
        if (reactElement) {
          // For some reason Children.forEach doesn't filter out `null`s
          var LayerType = reactElement.type;

          if ((0, _inheritsFrom.inheritsFrom)(LayerType, _core.Layer)) {
            var layer = new LayerType(reactElement.props);
            layers = layers || [];
            layers.push(layer);
          } else {
            reactChildren.push(reactElement);
          }
        }
      });

      return {
        layers: layers,
        children: reactChildren
      };
    } // Iterate over views and reposition children associated with views
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: "_renderChildrenUnderViews",
    value: function _renderChildrenUnderViews(children) {
      var _this2 = this;

      // Flatten out nested views array
      var views = this.deck ? this.deck.getViewports() : []; // Build a view id to view index

      var viewMap = {};
      views.forEach(function (view) {
        if (view.id) {
          viewMap[view.id] = view;
        }
      });
      return children.map( // If child specifies props.viewId, position under view, otherwise render as normal
      function (child, i) {
        return child.props.viewId || child.props.viewId ? _this2._positionChild({
          child: child,
          viewMap: viewMap,
          i: i
        }) : child;
      });
    }
  }, {
    key: "_positionChild",
    value: function _positionChild(_ref4) {
      var child = _ref4.child,
          viewMap = _ref4.viewMap,
          i = _ref4.i;
      var _child$props = child.props,
          viewId = _child$props.viewId,
          viewportId = _child$props.viewportId;

      if (viewportId) {
        _core.log.deprecated('viewportId', 'viewId')();
      }

      var view = viewMap[viewId || viewportId]; // Drop (auto-hide) elements with viewId that are not matched by any current view

      if (!view) {
        return null;
      } // Resolve potentially relative dimensions using the deck.gl container size


      var x = view.x,
          y = view.y,
          width = view.width,
          height = view.height; // Clone the element with width and height set per view

      var newProps = Object.assign({}, child.props, {
        width: width,
        height: height
      }); // Inject map properties
      // TODO - this is too react-map-gl specific

      Object.assign(newProps, view.getMercatorParams(), {
        visible: view.isMapSynched()
      });
      var clone = (0, _react.cloneElement)(child, newProps); // Wrap it in an absolutely positioning div

      var style = {
        position: 'absolute',
        left: x,
        top: y,
        width: width,
        height: height
      };
      var key = "view-child-".concat(viewId, "-").concat(i);
      return (0, _react.createElement)('div', {
        key: key,
        id: key,
        style: style
      }, clone);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      // Render the background elements (typically react-map-gl instances)
      // using the view descriptors
      var children = this._renderChildrenUnderViews(this.children); // Note that width and height are handled by deck.gl


      var id = this.props.id; // TODO - this styling is enforced for correct positioning with children
      // It can override the styling set by `Deck`, this should be consolidated.

      var style = Object.assign({}, {
        position: 'absolute',
        left: 0,
        top: 0
      }, this.props.style);
      var canvas = (0, _react.createElement)('canvas', {
        ref: function ref(c) {
          return _this3.deckCanvas = c;
        },
        key: 'deck-canvas',
        id: id,
        style: style
      }); // Render deck.gl as last child

      children.push(canvas);
      return (0, _react.createElement)('div', {
        id: 'deckgl-wrapper'
      }, children);
    }
  }]);

  return DeckGL;
}(_react.default.Component);

exports.default = DeckGL;
DeckGL.propTypes = propTypes;
DeckGL.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWNrZ2wuanMiXSwibmFtZXMiOlsicHJvcFR5cGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiRGVjayIsImdldFByb3BUeXBlcyIsIlByb3BUeXBlcyIsInZpZXdwb3J0cyIsImFycmF5Iiwidmlld3BvcnQiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwiY2hpbGRyZW4iLCJkZWNrIiwiY2FudmFzIiwiZGVja0NhbnZhcyIsInZpZXdTdGF0ZSIsIl9nZXRWaWV3U3RhdGUiLCJvblZpZXdTdGF0ZUNoYW5nZSIsIl9vblZpZXdTdGF0ZUNoYW5nZSIsIm9uUmVzaXplIiwiX29uUmVzaXplIiwiX3VwZGF0ZUZyb21Qcm9wcyIsIm5leHRQcm9wcyIsImZpbmFsaXplIiwieCIsInkiLCJyYWRpdXMiLCJsYXllcklkcyIsInBpY2tPYmplY3QiLCJkZXB0aCIsInBpY2tNdWx0aXBsZU9iamVjdHMiLCJ3aWR0aCIsImhlaWdodCIsInBpY2tPYmplY3RzIiwib3B0cyIsImxvZyIsImRlcHJlY2F0ZWQiLCJmb3JjZVVwZGF0ZSIsIl9leHRyYWN0SlNYTGF5ZXJzIiwibGF5ZXJzIiwic2V0UHJvcHMiLCJ2aWV3cyIsIl9nZXRWaWV3cyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsInJlYWN0Q2hpbGRyZW4iLCJSZWFjdCIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsInJlYWN0RWxlbWVudCIsIkxheWVyVHlwZSIsInR5cGUiLCJMYXllciIsImxheWVyIiwicHVzaCIsImdldFZpZXdwb3J0cyIsInZpZXdNYXAiLCJ2aWV3IiwiaWQiLCJtYXAiLCJjaGlsZCIsImkiLCJ2aWV3SWQiLCJfcG9zaXRpb25DaGlsZCIsInZpZXdwb3J0SWQiLCJuZXdQcm9wcyIsImdldE1lcmNhdG9yUGFyYW1zIiwidmlzaWJsZSIsImlzTWFwU3luY2hlZCIsImNsb25lIiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJrZXkiLCJfcmVuZGVyQ2hpbGRyZW5VbmRlclZpZXdzIiwicmVmIiwiYyIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkMsV0FBS0MsWUFBTCxDQUFrQkMsa0JBQWxCLENBQWxCLEVBQWdEO0FBQ2hFQyxhQUFXRCxtQkFBVUUsS0FEMkM7QUFDcEM7QUFDNUJDLFlBQVVILG1CQUFVSSxNQUY0QyxDQUVyQzs7QUFGcUMsQ0FBaEQsQ0FBbEI7QUFLQSxJQUFNQyxlQUFlUCxXQUFLTyxZQUExQjs7SUFFcUJDLE07Ozs7O0FBQ25CLGtCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUE7O0FBQ2pCLDRHQUFNQSxLQUFOO0FBQ0EsVUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDQSxVQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0E7QUFKaUI7QUFLbEI7Ozs7d0NBRW1CO0FBQ2xCLFdBQUtDLElBQUwsR0FBWSxJQUFJWixVQUFKLENBQ1ZGLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtVLEtBQXZCLEVBQThCO0FBQzVCSSxnQkFBUSxLQUFLQyxVQURlO0FBRTVCQyxtQkFBVyxLQUFLQyxhQUFMLENBQW1CLEtBQUtQLEtBQXhCLENBRmlCO0FBRzVCO0FBQ0FRLDJCQUFtQixLQUFLQyxrQkFKSTtBQUs1QkMsa0JBQVUsS0FBS0M7QUFMYSxPQUE5QixDQURVLENBQVo7O0FBU0EsV0FBS0MsZ0JBQUwsQ0FBc0IsS0FBS1osS0FBM0I7QUFDRDs7OzhDQUV5QmEsUyxFQUFXO0FBQ25DLFdBQUtELGdCQUFMLENBQXNCQyxTQUF0QjtBQUNEOzs7MkNBRXNCO0FBQ3JCLFdBQUtWLElBQUwsQ0FBVVcsUUFBVjtBQUNELEssQ0FFRDs7OztxQ0FFZ0Q7QUFBQSxVQUFwQ0MsQ0FBb0MsUUFBcENBLENB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NSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi91dGlscy9hdXRvYmluZCc7XG5pbXBvcnQge2luaGVyaXRzRnJvbX0gZnJvbSAnLi91dGlscy9pbmhlcml0cy1mcm9tJztcbmltcG9ydCB7RGVjaywgTGF5ZXIsIGxvZ30gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5cbmNvbnN0IHByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIERlY2suZ2V0UHJvcFR5cGVzKFByb3BUeXBlcyksIHtcbiAgdmlld3BvcnRzOiBQcm9wVHlwZXMuYXJyYXksIC8vIERlcHJlY2F0ZWRcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5vYmplY3QgLy8gRGVwcmVjYXRlZFxufSk7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IERlY2suZGVmYXVsdFByb3BzO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrR0wgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5kZWNrID0gbmV3IERlY2soXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIGNhbnZhczogdGhpcy5kZWNrQ2FudmFzLFxuICAgICAgICB2aWV3U3RhdGU6IHRoaXMuX2dldFZpZXdTdGF0ZSh0aGlzLnByb3BzKSxcbiAgICAgICAgLy8gTm90ZTogSWYgRGVjayBldmVudCBoYW5kbGluZyBjaGFuZ2Ugc2l6ZSBvciB2aWV3IHN0YXRlLCBpdCBjYWxscyBvblJlc2l6ZSB0byB1cGRhdGVcbiAgICAgICAgb25WaWV3U3RhdGVDaGFuZ2U6IHRoaXMuX29uVmlld1N0YXRlQ2hhbmdlLFxuICAgICAgICBvblJlc2l6ZTogdGhpcy5fb25SZXNpemVcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl91cGRhdGVGcm9tUHJvcHModGhpcy5wcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMuX3VwZGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kZWNrLmZpbmFsaXplKCk7XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJXG5cbiAgcGlja09iamVjdCh7eCwgeSwgcmFkaXVzID0gMCwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucGlja09iamVjdCh7eCwgeSwgcmFkaXVzLCBsYXllcklkc30pO1xuICB9XG5cbiAgcGlja011bHRpcGxlT2JqZWN0cyh7eCwgeSwgcmFkaXVzID0gMCwgbGF5ZXJJZHMgPSBudWxsLCBkZXB0aCA9IDEwfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucGlja011bHRpcGxlT2JqZWN0cyh7eCwgeSwgcmFkaXVzLCBsYXllcklkcywgZGVwdGh9KTtcbiAgfVxuXG4gIHBpY2tPYmplY3RzKHt4LCB5LCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICByZXR1cm4gdGhpcy5kZWNrLnBpY2tPYmplY3RzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsYXllcklkc30pO1xuICB9XG5cbiAgcXVlcnlPYmplY3Qob3B0cykge1xuICAgIGxvZy5kZXByZWNhdGVkKCdxdWVyeU9iamVjdCcsICdwaWNrT2JqZWN0JykoKTtcbiAgICByZXR1cm4gdGhpcy5kZWNrLnBpY2tPYmplY3Qob3B0cyk7XG4gIH1cblxuICBxdWVyeVZpc2libGVPYmplY3RzKG9wdHMpIHtcbiAgICBsb2cuZGVwcmVjYXRlZCgncXVlcnlWaXNpYmxlT2JqZWN0cycsICdwaWNrT2JqZWN0cycpKCk7XG4gICAgcmV0dXJuIHRoaXMucGlja09iamVjdHMob3B0cyk7XG4gIH1cblxuICAvLyBDYWxsYmFja3NcblxuICAvLyBGb3J3YXJkIGNhbGxiYWNrIGFuZCB0aGVuIGNhbGwgZm9yY2VVcGRhdGUgdG8gZ3VhcmFudGVlIHRoYXQgc3ViIGNvbXBvbmVudHMgdXBkYXRlXG4gIF9vblJlc2l6ZSguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25SZXNpemUpIHtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemUoLi4uYXJncyk7XG4gICAgfVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIC8vIEZvcndhcmQgY2FsbGJhY2sgYW5kIHRoZW4gY2FsbCBmb3JjZVVwZGF0ZSB0byBndWFyYW50ZWUgdGhhdCBzdWIgY29tcG9uZW50cyB1cGRhdGVcbiAgX29uVmlld1N0YXRlQ2hhbmdlKC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSkge1xuICAgICAgdGhpcy5wcm9wcy5vblZpZXdTdGF0ZUNoYW5nZSguLi5hcmdzKTtcbiAgICB9XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBIZWxwZXJzXG5cbiAgLy8gMS4gRXh0cmFjdCBhbnkgSlNYIGxheWVycyBmcm9tIHRoZSByZWFjdCBjaGlsZHJlblxuICAvLyAyLiBIYW5kbGUgYW55IGJhY2t3YXJkcyBjb21wYXRpYmxpdHkgcHJvcHMgZm9yIFJlYWN0IGxheWVyXG4gIC8vIE5lZWRzIHRvIGJlIGNhbGxlZCBib3RoIGZyb20gaW5pdGlhbCBtb3VudCwgYW5kIHdoZW4gbmV3IHByb3BzIGFycml2ZVxuICBfdXBkYXRlRnJvbVByb3BzKG5leHRQcm9wcykge1xuICAgIC8vIGV4dHJhY3QgYW55IGRlY2suZ2wgbGF5ZXJzIG1hc3F1ZXJhZGluZyBhcyByZWFjdCBlbGVtZW50cyBmcm9tIHByb3BzLmNoaWxkcmVuXG4gICAgY29uc3Qge2xheWVycywgY2hpbGRyZW59ID0gdGhpcy5fZXh0cmFjdEpTWExheWVycyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKHRoaXMuZGVjaykge1xuICAgICAgdGhpcy5kZWNrLnNldFByb3BzKFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBuZXh0UHJvcHMsIHtcbiAgICAgICAgICB2aWV3czogdGhpcy5fZ2V0Vmlld3MobmV4dFByb3BzKSxcbiAgICAgICAgICB2aWV3U3RhdGU6IHRoaXMuX2dldFZpZXdTdGF0ZShuZXh0UHJvcHMpLFxuICAgICAgICAgIC8vIEF2b2lkIG1vZGlmeWluZyBsYXllcnMgYXJyYXkgaWYgbm8gSlNYIGxheWVycyB3ZXJlIGZvdW5kXG4gICAgICAgICAgbGF5ZXJzOiBsYXllcnMgPyBbLi4ubGF5ZXJzLCAuLi5uZXh0UHJvcHMubGF5ZXJzXSA6IG5leHRQcm9wcy5sYXllcnNcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBvbGQgYHZpZXdwb3J0c2AgcHJvcCAoUmVhY3Qgb25seSEpXG4gIF9nZXRWaWV3cyhwcm9wcykge1xuICAgIGlmIChwcm9wcy52aWV3cG9ydHMpIHtcbiAgICAgIGxvZy5kZXByZWNhdGVkKCdEZWNrR0wudmlld3BvcnRzJywgJ0RlY2tHTC52aWV3cycpKCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy52aWV3cG9ydCkge1xuICAgICAgbG9nLmRlcHJlY2F0ZWQoJ0RlY2tHTC52aWV3cG9ydCcsICdEZWNrR0wudmlld3MnKSgpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMudmlld3MgfHwgcHJvcHMudmlld3BvcnRzIHx8IChwcm9wcy52aWV3cG9ydCAmJiBbcHJvcHMudmlld3BvcnRdKTtcbiAgfVxuXG4gIC8vIFN1cHBvcnRzIG9sZCBcImdlb3NwYXRpYWwgdmlldyBzdGF0ZSBhcyBzZXBhcmF0ZSBwcm9wc1wiIHN0eWxlIChSZWFjdCBvbmx5ISlcbiAgX2dldFZpZXdTdGF0ZShwcm9wcykge1xuICAgIGxldCB7dmlld1N0YXRlfSA9IHByb3BzO1xuXG4gICAgaWYgKCF2aWV3U3RhdGUgJiYgJ2xhdGl0dWRlJyBpbiBwcm9wcyAmJiAnbG9uZ2l0dWRlJyBpbiBwcm9wcyAmJiAnem9vbScgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCA9IDAsIGJlYXJpbmcgPSAwfSA9IHByb3BzO1xuICAgICAgdmlld1N0YXRlID0gcHJvcHMudmlld1N0YXRlIHx8IHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZ307XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIGV4dHJhY3RzIGFueSBkZWNrLmdsIGxheWVycyBtYXNxdWVyYWRpbmcgYXMgcmVhY3QgZWxlbWVudHMgZnJvbSBwcm9wcy5jaGlsZHJlblxuICBfZXh0cmFjdEpTWExheWVycyhjaGlsZHJlbikge1xuICAgIGNvbnN0IHJlYWN0Q2hpbGRyZW4gPSBbXTsgLy8gZXh0cmFjdCByZWFsIHJlYWN0IGVsZW1lbnRzIChpLmUuIG5vdCBkZWNrLmdsIGxheWVycylcbiAgICBsZXQgbGF5ZXJzID0gbnVsbDsgLy8gZXh0cmFjdGVkIGxheWVyIGZyb20gcmVhY3QgY2hpbGRyZW4sIHdpbGwgYWRkIHRvIGRlY2suZ2wgbGF5ZXIgYXJyYXlcblxuICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIHJlYWN0RWxlbWVudCA9PiB7XG4gICAgICBpZiAocmVhY3RFbGVtZW50KSB7XG4gICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBDaGlsZHJlbi5mb3JFYWNoIGRvZXNuJ3QgZmlsdGVyIG91dCBgbnVsbGBzXG4gICAgICAgIGNvbnN0IExheWVyVHlwZSA9IHJlYWN0RWxlbWVudC50eXBlO1xuICAgICAgICBpZiAoaW5oZXJpdHNGcm9tKExheWVyVHlwZSwgTGF5ZXIpKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXIgPSBuZXcgTGF5ZXJUeXBlKHJlYWN0RWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgbGF5ZXJzID0gbGF5ZXJzIHx8IFtdO1xuICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFjdENoaWxkcmVuLnB1c2gocmVhY3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtsYXllcnMsIGNoaWxkcmVuOiByZWFjdENoaWxkcmVufTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciB2aWV3cyBhbmQgcmVwb3NpdGlvbiBjaGlsZHJlbiBhc3NvY2lhdGVkIHdpdGggdmlld3NcbiAgLy8gVE9ETyAtIENhbiB3ZSBzdXBwbHkgYSBzaW1pbGFyIGZ1bmN0aW9uIGZvciB0aGUgbm9uLVJlYWN0IGNhc2U/XG4gIF9yZW5kZXJDaGlsZHJlblVuZGVyVmlld3MoY2hpbGRyZW4pIHtcbiAgICAvLyBGbGF0dGVuIG91dCBuZXN0ZWQgdmlld3MgYXJyYXlcbiAgICBjb25zdCB2aWV3cyA9IHRoaXMuZGVjayA/IHRoaXMuZGVjay5nZXRWaWV3cG9ydHMoKSA6IFtdO1xuXG4gICAgLy8gQnVpbGQgYSB2aWV3IGlkIHRvIHZpZXcgaW5kZXhcbiAgICBjb25zdCB2aWV3TWFwID0ge307XG4gICAgdmlld3MuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgIGlmICh2aWV3LmlkKSB7XG4gICAgICAgIHZpZXdNYXBbdmlldy5pZF0gPSB2aWV3O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuLm1hcChcbiAgICAgIC8vIElmIGNoaWxkIHNwZWNpZmllcyBwcm9wcy52aWV3SWQsIHBvc2l0aW9uIHVuZGVyIHZpZXcsIG90aGVyd2lzZSByZW5kZXIgYXMgbm9ybWFsXG4gICAgICAoY2hpbGQsIGkpID0+XG4gICAgICAgIGNoaWxkLnByb3BzLnZpZXdJZCB8fCBjaGlsZC5wcm9wcy52aWV3SWQgPyB0aGlzLl9wb3NpdGlvbkNoaWxkKHtjaGlsZCwgdmlld01hcCwgaX0pIDogY2hpbGRcbiAgICApO1xuICB9XG5cbiAgX3Bvc2l0aW9uQ2hpbGQoe2NoaWxkLCB2aWV3TWFwLCBpfSkge1xuICAgIGNvbnN0IHt2aWV3SWQsIHZpZXdwb3J0SWR9ID0gY2hpbGQucHJvcHM7XG4gICAgaWYgKHZpZXdwb3J0SWQpIHtcbiAgICAgIGxvZy5kZXByZWNhdGVkKCd2aWV3cG9ydElkJywgJ3ZpZXdJZCcpKCk7XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSB2aWV3TWFwW3ZpZXdJZCB8fCB2aWV3cG9ydElkXTtcblxuICAgIC8vIERyb3AgKGF1dG8taGlkZSkgZWxlbWVudHMgd2l0aCB2aWV3SWQgdGhhdCBhcmUgbm90IG1hdGNoZWQgYnkgYW55IGN1cnJlbnQgdmlld1xuICAgIGlmICghdmlldykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzb2x2ZSBwb3RlbnRpYWxseSByZWxhdGl2ZSBkaW1lbnNpb25zIHVzaW5nIHRoZSBkZWNrLmdsIGNvbnRhaW5lciBzaXplXG4gICAgY29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gdmlldztcblxuICAgIC8vIENsb25lIHRoZSBlbGVtZW50IHdpdGggd2lkdGggYW5kIGhlaWdodCBzZXQgcGVyIHZpZXdcbiAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLnByb3BzLCB7d2lkdGgsIGhlaWdodH0pO1xuXG4gICAgLy8gSW5qZWN0IG1hcCBwcm9wZXJ0aWVzXG4gICAgLy8gVE9ETyAtIHRoaXMgaXMgdG9vIHJlYWN0LW1hcC1nbCBzcGVjaWZpY1xuICAgIE9iamVjdC5hc3NpZ24obmV3UHJvcHMsIHZpZXcuZ2V0TWVyY2F0b3JQYXJhbXMoKSwge1xuICAgICAgdmlzaWJsZTogdmlldy5pc01hcFN5bmNoZWQoKVxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xvbmUgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIG5ld1Byb3BzKTtcblxuICAgIC8vIFdyYXAgaXQgaW4gYW4gYWJzb2x1dGVseSBwb3NpdGlvbmluZyBkaXZcbiAgICBjb25zdCBzdHlsZSA9IHtwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogeCwgdG9wOiB5LCB3aWR0aCwgaGVpZ2h0fTtcbiAgICBjb25zdCBrZXkgPSBgdmlldy1jaGlsZC0ke3ZpZXdJZH0tJHtpfWA7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtrZXksIGlkOiBrZXksIHN0eWxlfSwgY2xvbmUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIC8vIFJlbmRlciB0aGUgYmFja2dyb3VuZCBlbGVtZW50cyAodHlwaWNhbGx5IHJlYWN0LW1hcC1nbCBpbnN0YW5jZXMpXG4gICAgLy8gdXNpbmcgdGhlIHZpZXcgZGVzY3JpcHRvcnNcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX3JlbmRlckNoaWxkcmVuVW5kZXJWaWV3cyh0aGlzLmNoaWxkcmVuKTtcblxuICAgIC8vIE5vdGUgdGhhdCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBoYW5kbGVkIGJ5IGRlY2suZ2xcbiAgICBjb25zdCB7aWR9ID0gdGhpcy5wcm9wcztcbiAgICAvLyBUT0RPIC0gdGhpcyBzdHlsaW5nIGlzIGVuZm9yY2VkIGZvciBjb3JyZWN0IHBvc2l0aW9uaW5nIHdpdGggY2hpbGRyZW5cbiAgICAvLyBJdCBjYW4gb3ZlcnJpZGUgdGhlIHN0eWxpbmcgc2V0IGJ5IGBEZWNrYCwgdGhpcyBzaG91bGQgYmUgY29uc29saWRhdGVkLlxuICAgIGNvbnN0IHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAwLCB0b3A6IDB9LCB0aGlzLnByb3BzLnN0eWxlKTtcblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogYyA9PiAodGhpcy5kZWNrQ2FudmFzID0gYyksXG4gICAgICBrZXk6ICdkZWNrLWNhbnZhcycsXG4gICAgICBpZCxcbiAgICAgIHN0eWxlXG4gICAgfSk7XG5cbiAgICAvLyBSZW5kZXIgZGVjay5nbCBhcyBsYXN0IGNoaWxkXG4gICAgY2hpbGRyZW4ucHVzaChjYW52YXMpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtpZDogJ2RlY2tnbC13cmFwcGVyJ30sIGNoaWxkcmVuKTtcbiAgfVxufVxuXG5EZWNrR0wucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==