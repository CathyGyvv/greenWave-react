"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _mjolnir = require("mjolnir.js");

var _core = require("@deck.gl/core");

var _cursors = _interopRequireDefault(require("./utils/cursors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var propTypes = {
  viewportState: _propTypes.default.func,
  state: _propTypes.default.object,

  /** Viewport props */

  /** The width of the map. */
  width: _propTypes.default.number.isRequired,

  /** The height of the map. */
  height: _propTypes.default.number.isRequired,

  /** The longitude of the center of the map. */
  longitude: _propTypes.default.number.isRequired,

  /** The latitude of the center of the map. */
  latitude: _propTypes.default.number.isRequired,

  /** The tile zoom level of the map. */
  zoom: _propTypes.default.number.isRequired,

  /** Specify the bearing of the viewport */
  bearing: _propTypes.default.number,

  /** Specify the pitch of the viewport */
  pitch: _propTypes.default.number,

  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: _propTypes.default.number,
  // Camera position for FirstPersonViewport
  position: _propTypes.default.array,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes.default.number,
  // Min zoom level
  minZoom: _propTypes.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes.default.number,
  // Min pitch in degrees
  minPitch: _propTypes.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes.default.func,

  /** Viewport transition **/
  // transition duration for viewport change
  transitionDuration: _propTypes.default.number,
  // an instance of ViewportTransitionInterpolator, can be used to perform custom transitions.
  transitionInterpolator: _propTypes.default.object,
  // type of interruption of current transition on update.
  transitionInterruption: _propTypes.default.number,
  // easing function
  transitionEasing: _propTypes.default.func,
  // transition status update functions
  onTransitionStart: _propTypes.default.func,
  onTransitionInterrupt: _propTypes.default.func,
  onTransitionEnd: _propTypes.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes.default.bool,
  // Drag to pan
  dragPan: _propTypes.default.bool,
  // Drag to rotate
  dragRotate: _propTypes.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes.default.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes.default.func,
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  controls: _propTypes.default.shape({
    events: _propTypes.default.arrayOf(_propTypes.default.string),
    handleEvent: _propTypes.default.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? _cursors.default.GRABBING : _cursors.default.GRAB;
};

var defaultProps = {
  onViewportChange: null,
  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  getCursor: getDefaultCursor
};

var ViewportController =
/*#__PURE__*/
function (_Component) {
  _inherits(ViewportController, _Component);

  function ViewportController(props) {
    var _this;

    _classCallCheck(this, ViewportController);

    _this = _possibleConstructorReturn(this, (ViewportController.__proto__ || Object.getPrototypeOf(ViewportController)).call(this, props));
    _this.state = {
      isDragging: false // Whether the cursor is down

    };
    return _this;
  }

  _createClass(ViewportController, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._eventManager = new _mjolnir.EventManager(this.eventCanvas); // If props.controls is not provided, fallback to default MapControls instance
      // Cannot use defaultProps here because it needs to be per map instance

      this._controls = this.props.controls || new _core.MapController(this.props.viewportState);

      this._controls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: this._eventManager
      }));
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps) {
      if (this._controls) {
        this._controls.setOptions(nextProps);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._eventManager.destroy();
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref2) {
      var _ref2$isDragging = _ref2.isDragging,
          isDragging = _ref2$isDragging === void 0 ? false : _ref2$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({
          isDragging: isDragging
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height,
          getCursor = _this$props.getCursor;
      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };
      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: function ref(c) {
          return _this2.eventCanvas = c;
        },
        style: eventCanvasStyle
      }, this.props.children);
    }
  }]);

  return ViewportController;
}(_react.Component);

exports.default = ViewportController;
ViewportController.displayName = 'ViewportController';
ViewportController.propTypes = propTypes;
ViewportController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy92aWV3cG9ydC1jb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbInByb3BUeXBlcyIsInZpZXdwb3J0U3RhdGUiLCJQcm9wVHlwZXMiLCJmdW5jIiwic3RhdGUiLCJvYmplY3QiLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInpvb20iLCJiZWFyaW5nIiwicGl0Y2giLCJhbHRpdHVkZSIsInBvc2l0aW9uIiwiYXJyYXkiLCJtYXhab29tIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJvblZpZXdwb3J0Q2hhbmdlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkludGVycG9sYXRvciIsInRyYW5zaXRpb25JbnRlcnJ1cHRpb24iLCJ0cmFuc2l0aW9uRWFzaW5nIiwib25UcmFuc2l0aW9uU3RhcnQiLCJvblRyYW5zaXRpb25JbnRlcnJ1cHQiLCJvblRyYW5zaXRpb25FbmQiLCJzY3JvbGxab29tIiwiYm9vbCIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tUm90YXRlIiwiZ2V0Q3Vyc29yIiwiY29udHJvbHMiLCJzaGFwZSIsImV2ZW50cyIsImFycmF5T2YiLCJzdHJpbmciLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiQ1VSU09SIiwiR1JBQkJJTkciLCJHUkFCIiwiZGVmYXVsdFByb3BzIiwiVmlld3BvcnRDb250cm9sbGVyIiwicHJvcHMiLCJfZXZlbnRNYW5hZ2VyIiwiRXZlbnRNYW5hZ2VyIiwiZXZlbnRDYW52YXMiLCJfY29udHJvbHMiLCJWaWV3cG9ydENvbnRyb2xzIiwic2V0T3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIm9uU3RhdGVDaGFuZ2UiLCJfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlIiwiYmluZCIsImV2ZW50TWFuYWdlciIsIm5leHRQcm9wcyIsImRlc3Ryb3kiLCJzZXRTdGF0ZSIsImV2ZW50Q2FudmFzU3R5bGUiLCJjdXJzb3IiLCJrZXkiLCJyZWYiLCJjIiwic3R5bGUiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZO0FBQ2hCQyxpQkFBZUMsbUJBQVVDLElBRFQ7QUFFaEJDLFNBQU9GLG1CQUFVRyxNQUZEOztBQUloQjs7QUFDQTtBQUNBQyxTQUFPSixtQkFBVUssTUFBVixDQUFpQkMsVUFOUjs7QUFPaEI7QUFDQUMsVUFBUVAsbUJBQVVLLE1BQVYsQ0FBaUJDLFVBUlQ7O0FBU2hCO0FBQ0FFLGFBQVdSLG1CQUFVSyxNQUFWLENBQWlCQyxVQVZaOztBQVdoQjtBQUNBRyxZQUFVVCxtQkFBVUssTUFBVixDQUFpQkMsVUFaWDs7QUFhaEI7QUFDQUksUUFBTVYsbUJBQVVLLE1BQVYsQ0FBaUJDLFVBZFA7O0FBZWhCO0FBQ0FLLFdBQVNYLG1CQUFVSyxNQWhCSDs7QUFpQmhCO0FBQ0FPLFNBQU9aLG1CQUFVSyxNQWxCRDs7QUFtQmhCO0FBQ0E7QUFDQVEsWUFBVWIsbUJBQVVLLE1BckJKO0FBc0JoQjtBQUNBUyxZQUFVZCxtQkFBVWUsS0F2Qko7O0FBeUJoQjtBQUNBO0FBQ0FDLFdBQVNoQixtQkFBVUssTUEzQkg7QUE0QmhCO0FBQ0FZLFdBQVNqQixtQkFBVUssTUE3Qkg7QUE4QmhCO0FBQ0FhLFlBQVVsQixtQkFBVUssTUEvQko7QUFnQ2hCO0FBQ0FjLFlBQVVuQixtQkFBVUssTUFqQ0o7O0FBbUNoQjs7Ozs7QUFLQWUsb0JBQWtCcEIsbUJBQVVDLElBeENaOztBQTBDaEI7QUFDQTtBQUNBb0Isc0JBQW9CckIsbUJBQVVLLE1BNUNkO0FBNkNoQjtBQUNBaUIsMEJBQXdCdEIsbUJBQVVHLE1BOUNsQjtBQStDaEI7QUFDQW9CLDBCQUF3QnZCLG1CQUFVSyxNQWhEbEI7QUFp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QSxhQUFPLDBCQUNMLEtBREssRUFFTDtBQUNFZ0UsYUFBSyxjQURQO0FBRUVDLGFBQUs7QUFBQSxpQkFBTSxPQUFLaEIsV0FBTCxHQUFtQmlCLENBQXpCO0FBQUEsU0FGUDtBQUdFQyxlQUFPTDtBQUhULE9BRkssRUFPTCxLQUFLaEIsS0FBTCxDQUFXc0IsUUFQTixDQUFQO0FBU0Q7Ozs7RUEzRDZDQyxnQjs7O0FBOERoRHhCLG1CQUFtQnlCLFdBQW5CLEdBQWlDLG9CQUFqQztBQUNBekIsbUJBQW1CakQsU0FBbkIsR0FBK0JBLFNBQS9CO0FBQ0FpRCxtQkFBbUJELFlBQW5CLEdBQWtDQSxZQUFsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnbWpvbG5pci5qcyc7XG5pbXBvcnQge01hcENvbnRyb2xsZXIgYXMgVmlld3BvcnRDb250cm9sc30gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5cbmltcG9ydCBDVVJTT1IgZnJvbSAnLi91dGlscy9jdXJzb3JzJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICB2aWV3cG9ydFN0YXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3RhdGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqIFZpZXdwb3J0IHByb3BzICovXG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcC4gKi9cbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIG1hcC4gKi9cbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbG9uZ2l0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0ICovXG4gIHBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogQWx0aXR1ZGUgb2YgdGhlIHZpZXdwb3J0IGNhbWVyYS4gRGVmYXVsdCAxLjUgXCJzY3JlZW4gaGVpZ2h0c1wiICovXG4gIC8vIE5vdGU6IE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIENhbWVyYSBwb3NpdGlvbiBmb3IgRmlyc3RQZXJzb25WaWV3cG9ydFxuICBwb3NpdGlvbjogUHJvcFR5cGVzLmFycmF5LFxuXG4gIC8qKiBWaWV3cG9ydCBjb25zdHJhaW50cyAqL1xuICAvLyBNYXggem9vbSBsZXZlbFxuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gem9vbSBsZXZlbFxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNYXggcGl0Y2ggaW4gZGVncmVlc1xuICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWluIHBpdGNoIGluIGRlZ3JlZXNcbiAgbWluUGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIGBvblZpZXdwb3J0Q2hhbmdlYCBjYWxsYmFjayBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGVcbiAgICogbWFwLiBUaGUgb2JqZWN0IHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgY29udGFpbnMgdmlld3BvcnQgcHJvcGVydGllc1xuICAgKiBzdWNoIGFzIGBsb25naXR1ZGVgLCBgbGF0aXR1ZGVgLCBgem9vbWAgZXRjLlxuICAgKi9cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIFZpZXdwb3J0IHRyYW5zaXRpb24gKiovXG4gIC8vIHRyYW5zaXRpb24gZHVyYXRpb24gZm9yIHZpZXdwb3J0IGNoYW5nZVxuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGFuIGluc3RhbmNlIG9mIFZpZXdwb3J0VHJhbnNpdGlvbkludGVycG9sYXRvciwgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBjdXN0b20gdHJhbnNpdGlvbnMuXG4gIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8vIHR5cGUgb2YgaW50ZXJydXB0aW9uIG9mIGN1cnJlbnQgdHJhbnNpdGlvbiBvbiB1cGRhdGUuXG4gIHRyYW5zaXRpb25JbnRlcnJ1cHRpb246IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGVhc2luZyBmdW5jdGlvblxuICB0cmFuc2l0aW9uRWFzaW5nOiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8gdHJhbnNpdGlvbiBzdGF0dXMgdXBkYXRlIGZ1bmN0aW9uc1xuICBvblRyYW5zaXRpb25TdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkludGVycnVwdDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uVHJhbnNpdGlvbkVuZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqIEVuYWJsZXMgY29udHJvbCBldmVudCBoYW5kbGluZyAqL1xuICAvLyBTY3JvbGwgdG8gem9vbVxuICBzY3JvbGxab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byBwYW5cbiAgZHJhZ1BhbjogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERyYWcgdG8gcm90YXRlXG4gIGRyYWdSb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuICAvLyBEb3VibGUgY2xpY2sgdG8gem9vbVxuICBkb3VibGVDbGlja1pvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBQaW5jaCB0byB6b29tIC8gcm90YXRlXG4gIHRvdWNoWm9vbVJvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqIEFjY2Vzc29yIHRoYXQgcmV0dXJucyBhIGN1cnNvciBzdHlsZSB0byBzaG93IGludGVyYWN0aXZlIHN0YXRlICovXG4gIGdldEN1cnNvcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLy8gQSBtYXAgY29udHJvbCBpbnN0YW5jZSB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG1hcCBjb250cm9sc1xuICAvLyBUaGUgb2JqZWN0IG11c3QgZXhwb3NlIG9uZSBwcm9wZXJ0eTogYGV2ZW50c2AgYXMgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlZFxuICAvLyBldmVudCBuYW1lczsgYW5kIHR3byBtZXRob2RzOiBgc2V0U3RhdGUoc3RhdGUpYCBhbmQgYGhhbmRsZShldmVudClgXG4gIGNvbnRyb2xzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGV2ZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgaGFuZGxlRXZlbnQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pXG59O1xuXG5jb25zdCBnZXREZWZhdWx0Q3Vyc29yID0gKHtpc0RyYWdnaW5nfSkgPT4gKGlzRHJhZ2dpbmcgPyBDVVJTT1IuR1JBQkJJTkcgOiBDVVJTT1IuR1JBQik7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgb25WaWV3cG9ydENoYW5nZTogbnVsbCxcblxuICBzY3JvbGxab29tOiB0cnVlLFxuICBkcmFnUGFuOiB0cnVlLFxuICBkcmFnUm90YXRlOiB0cnVlLFxuICBkb3VibGVDbGlja1pvb206IHRydWUsXG4gIHRvdWNoWm9vbVJvdGF0ZTogdHJ1ZSxcblxuICBnZXRDdXJzb3I6IGdldERlZmF1bHRDdXJzb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0Q29udHJvbGxlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlIC8vIFdoZXRoZXIgdGhlIGN1cnNvciBpcyBkb3duXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcy5ldmVudENhbnZhcyk7XG5cbiAgICAvLyBJZiBwcm9wcy5jb250cm9scyBpcyBub3QgcHJvdmlkZWQsIGZhbGxiYWNrIHRvIGRlZmF1bHQgTWFwQ29udHJvbHMgaW5zdGFuY2VcbiAgICAvLyBDYW5ub3QgdXNlIGRlZmF1bHRQcm9wcyBoZXJlIGJlY2F1c2UgaXQgbmVlZHMgdG8gYmUgcGVyIG1hcCBpbnN0YW5jZVxuICAgIHRoaXMuX2NvbnRyb2xzID0gdGhpcy5wcm9wcy5jb250cm9scyB8fCBuZXcgVmlld3BvcnRDb250cm9scyh0aGlzLnByb3BzLnZpZXdwb3J0U3RhdGUpO1xuXG4gICAgdGhpcy5fY29udHJvbHMuc2V0T3B0aW9ucyhcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgIGV2ZW50TWFuYWdlcjogdGhpcy5fZXZlbnRNYW5hZ2VyXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLl9jb250cm9scykge1xuICAgICAgdGhpcy5fY29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gIH1cblxuICBfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlKHtpc0RyYWdnaW5nID0gZmFsc2V9KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNEcmFnZ2luZ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2V0Q3Vyc29yfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBldmVudENhbnZhc1N0eWxlID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuc3RhdGUpXG4gICAgfTtcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGtleTogJ21hcC1jb250cm9scycsXG4gICAgICAgIHJlZjogYyA9PiAodGhpcy5ldmVudENhbnZhcyA9IGMpLFxuICAgICAgICBzdHlsZTogZXZlbnRDYW52YXNTdHlsZVxuICAgICAgfSxcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICB9XG59XG5cblZpZXdwb3J0Q29udHJvbGxlci5kaXNwbGF5TmFtZSA9ICdWaWV3cG9ydENvbnRyb2xsZXInO1xuVmlld3BvcnRDb250cm9sbGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcblZpZXdwb3J0Q29udHJvbGxlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=