{"version":3,"sources":["../../../src/lib/attribute-transition-manager.js"],"names":["GL","Buffer","experimental","getShaders","getBuffers","padBuffer","Transition","log","assert","Transform","noop","AttributeTransitionManager","constructor","gl","id","attributeTransitions","needsRedraw","transform","numInstances","isSupported","warn","finalize","delete","attributeName","_removeTransition","update","attributes","transitions","opts","changedTransitions","hasChanged","_updateAttribute","attribute","supportsTransition","_createModel","sourceBuffers","destinationBuffers","elementCount","hasAttribute","getAttributes","animatedAttributes","transition","buffer","setCurrentTime","currentTime","uniforms","updated","time","run","_createTransition","name","_invalidateModel","_swapBuffer","settings","_getTransitionSettings","_triggerTransition","Object","keys","length","assign","_getNextTransitionStates","size","toState","isGeneric","value","getBuffer","fromState","toLength","fromLength","data","Float32Array","usage","DYNAMIC_COPY","setData","userData","accessor","Array","isArray","map","a","find","Boolean","_normalizeTransitionSettings","Number","isFinite","duration","easing","t","onStart","onEnd","onInterrupt","transitionSettings","start"],"mappings":"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","sourcesContent":["import {GL, Buffer, experimental} from 'luma.gl';\nimport {getShaders, getBuffers, padBuffer} from './attribute-transition-utils';\nimport Transition from '../transitions/transition';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst {Transform} = experimental;\n\nconst noop = () => {};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributeTransitions = {};\n    this.needsRedraw = false;\n    this.transform = null;\n    this.numInstances = 0;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else {\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    if (this.transform) {\n      this.transform.delete();\n    }\n    for (const attributeName in this.attributeTransitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    this.opts = transitions;\n    this.numInstances = numInstances;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    const {attributeTransitions} = this;\n    const changedTransitions = {};\n\n    for (const attributeName in attributes) {\n      const hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);\n\n      if (hasChanged) {\n        changedTransitions[attributeName] = attributeTransitions[attributeName];\n      }\n    }\n\n    for (const attributeName in attributeTransitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.supportsTransition()) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n\n    if (!this.transform) {\n      this._createModel();\n    } else if (this.transform) {\n      const {sourceBuffers, destinationBuffers} = getBuffers(changedTransitions);\n      this.transform.update({\n        elementCount: this.numInstances,\n        sourceBuffers,\n        destinationBuffers\n      });\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    return attributeName in this.attributeTransitions;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n\n      if (transition.buffer) {\n        animatedAttributes[attributeName] = transition.buffer;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  setCurrentTime(currentTime) {\n    if (!this.transform) {\n      return false;\n    }\n\n    const uniforms = {};\n\n    let needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n\n    for (const attributeName in this.attributeTransitions) {\n      const transition = this.attributeTransitions[attributeName];\n      const updated = transition.update(currentTime);\n      if (updated) {\n        uniforms[`${attributeName}Time`] = transition.time;\n        needsRedraw = true;\n      }\n    }\n\n    if (needsRedraw) {\n      this.transform.run({uniforms});\n    }\n\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _createTransition(attributeName, attribute) {\n    let transition = this.attributeTransitions[attributeName];\n    if (!transition) {\n      transition = new Transition({name: attributeName, attribute});\n      this.attributeTransitions[attributeName] = transition;\n      this._invalidateModel();\n      return transition;\n    }\n    return null;\n  }\n\n  _removeTransition(attributeName) {\n    const transition = this.attributeTransitions[attributeName];\n    if (transition) {\n      if (transition.buffer) {\n        transition.buffer.delete();\n      }\n      if (transition._swapBuffer) {\n        transition._swapBuffer.delete();\n      }\n      delete this.attributeTransitions[attributeName];\n      this._invalidateModel();\n    }\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute) {\n    const settings = this._getTransitionSettings(attribute);\n\n    if (settings) {\n      let hasChanged;\n      let transition = this.attributeTransitions[attributeName];\n      if (transition) {\n        hasChanged = attribute.needsRedraw();\n      } else {\n        // New animated attributes have been added\n        transition = this._createTransition(attributeName, attribute);\n        hasChanged = true;\n      }\n\n      if (hasChanged) {\n        this._triggerTransition(transition, settings);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Invalidates the current model\n  _invalidateModel() {\n    if (this.transform) {\n      this.transform.delete();\n      this.transform = null;\n    }\n  }\n\n  // Create a model for the transform feedback\n  _createModel() {\n    if (Object.keys(this.attributeTransitions).length === 0) {\n      // no transitions\n      return;\n    }\n    this.transform = new Transform(\n      this.gl,\n      Object.assign(\n        {\n          elementCount: this.numInstances\n        },\n        getBuffers(this.attributeTransitions),\n        getShaders(this.attributeTransitions)\n      )\n    );\n  }\n\n  // get current values of an attribute, clipped/padded to the size of the new buffer\n  _getNextTransitionStates(transition) {\n    const {attribute} = transition;\n    const {size} = attribute;\n\n    let toState;\n    if (attribute.isGeneric) {\n      toState = {isGeneric: true, value: attribute.value, size};\n    } else {\n      toState = {isGeneric: false, buffer: attribute.getBuffer(), size};\n    }\n    const fromState = transition.buffer || toState;\n    const toLength = this.numInstances * size;\n    const fromLength = (fromState.data && fromState.data.length) || toLength;\n\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the destination buffer.\n    let buffer = transition._swapBuffer;\n    transition._swapBuffer = transition.buffer;\n\n    if (!buffer) {\n      buffer = new Buffer(this.gl, {\n        size,\n        data: new Float32Array(toLength),\n        usage: GL.DYNAMIC_COPY\n      });\n    }\n\n    // Pad buffers to be the same length\n    if (buffer.data.length < toLength) {\n      buffer.setData({\n        data: new Float32Array(toLength)\n      });\n    }\n    padBuffer({fromState, toState, fromLength, toLength});\n\n    return {fromState, toState, buffer};\n  }\n\n  // Returns transition settings object if transition is enabled, otherwise `null`\n  _getTransitionSettings(attribute) {\n    const {opts} = this;\n    const {transition, accessor} = attribute.userData;\n\n    if (!transition) {\n      return null;\n    }\n\n    return Array.isArray(accessor) ? accessor.map(a => opts[a]).find(Boolean) : opts[accessor];\n  }\n\n  // Normalizes transition settings object, merge with default settings\n  _normalizeTransitionSettings(settings) {\n    // Shorthand: use duration instead of parameter object\n    if (Number.isFinite(settings)) {\n      settings = {duration: settings};\n    }\n\n    // Check if settings is valid\n    assert(settings && settings.duration > 0);\n\n    return {\n      duration: settings.duration,\n      easing: settings.easing || (t => t),\n      onStart: settings.onStart || noop,\n      onEnd: settings.onEnd || noop,\n      onInterrupt: settings.onInterrupt || noop\n    };\n  }\n\n  // Start a new transition using the current settings\n  // Updates transition state and from/to buffer\n  _triggerTransition(transition, settings) {\n    this.needsRedraw = true;\n\n    const transitionSettings = this._normalizeTransitionSettings(settings);\n\n    // Attribute descriptor to transition from\n    transition.start(\n      Object.assign({}, this._getNextTransitionStates(transition), transitionSettings)\n    );\n  }\n}\n"],"file":"attribute-transition-manager.js"}