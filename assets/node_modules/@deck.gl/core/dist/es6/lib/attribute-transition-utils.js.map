{"version":3,"sources":["../../../src/lib/attribute-transition-utils.js"],"names":["Buffer","fillArray","ATTRIBUTE_MAPPING","getShaders","transitions","varyings","attributeDeclarations","uniformsDeclarations","varyingDeclarations","calculations","attributeName","transition","attributeType","attribute","size","bufferIndex","length","push","vs","join","fs","getBuffers","sourceBuffers","destinationBuffers","fromState","toState","buffer","padBuffer","fromLength","toLength","data","Float32Array","set","getData","isGeneric","target","source","value","start","count","subarray","setData"],"mappings":"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","sourcesContent":["import {Buffer} from 'luma.gl';\nimport {fillArray} from '../utils/flatten';\n\nconst ATTRIBUTE_MAPPING = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nexport function getShaders(transitions) {\n  // Build shaders\n  const varyings = [];\n  const attributeDeclarations = [];\n  const uniformsDeclarations = [];\n  const varyingDeclarations = [];\n  const calculations = [];\n\n  for (const attributeName in transitions) {\n    const transition = transitions[attributeName];\n    const attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];\n\n    if (attributeType) {\n      transition.bufferIndex = varyings.length;\n      varyings.push(attributeName);\n\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}From;`);\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}To;`);\n      uniformsDeclarations.push(`uniform float ${attributeName}Time;`);\n      varyingDeclarations.push(`varying ${attributeType} ${attributeName};`);\n      calculations.push(`${attributeName} = mix(${attributeName}From, ${attributeName}To,\n        ${attributeName}Time);`);\n    }\n  }\n\n  const vs = `\n#define SHADER_NAME feedback-vertex-shader\n${attributeDeclarations.join('\\n')}\n${uniformsDeclarations.join('\\n')}\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  ${calculations.join('\\n')}\n  gl_Position = vec4(0.0);\n}\n`;\n\n  const fs = `\\\n#define SHADER_NAME feedback-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n`;\n  return {vs, fs, varyings};\n}\n\nexport function getBuffers(transitions) {\n  const sourceBuffers = {};\n  const destinationBuffers = {};\n  for (const attributeName in transitions) {\n    const {fromState, toState, buffer} = transitions[attributeName];\n    sourceBuffers[`${attributeName}From`] = fromState;\n    sourceBuffers[`${attributeName}To`] = toState;\n    destinationBuffers[`${attributeName}`] = buffer;\n  }\n  return {sourceBuffers, destinationBuffers};\n}\n\nexport function padBuffer({fromState, toState, fromLength, toLength}) {\n  // check if buffer needs to be padded\n  if (fromLength >= toLength || !(fromState instanceof Buffer)) {\n    return;\n  }\n\n  const data = new Float32Array(toLength);\n  // copy the currect values\n  data.set(fromState.getData({}));\n\n  if (toState.isGeneric) {\n    fillArray({\n      target: data,\n      source: toState.value,\n      start: fromLength,\n      count: (toLength - fromLength) / toState.size\n    });\n  } else {\n    data.set(toState.buffer.data.subarray(fromLength), fromLength);\n  }\n\n  fromState.setData({data});\n}\n"],"file":"attribute-transition-utils.js"}