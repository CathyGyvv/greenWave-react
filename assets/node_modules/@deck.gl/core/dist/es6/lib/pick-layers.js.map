{"version":3,"sources":["../../../src/lib/pick-layers.js"],"names":["drawPickingBuffer","getPixelRatio","log","assert","NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","pickObject","gl","layers","viewports","x","y","radius","layerFilter","depth","mode","onViewportActive","pickingFBO","lastPickedInfo","useDevicePixels","pixelRatio","deviceX","Math","round","deviceY","canvas","height","deviceRadius","deviceRect","getPickingRect","deviceWidth","width","deviceHeight","result","affectedLayers","i","pickedColors","drawAndSamplePickingBuffer","redrawReason","pickInfo","getClosestFromPickingBuffer","layerId","copyPickingColors","clearPickingColor","processedPickInfos","processPickInfo","forEach","info","push","Object","keys","restorePickingColors","pickVisibleObjects","deviceLeft","deviceBottom","deviceRight","deviceTop","pickInfos","getUniquesFromPickingBuffer","uniqueInfos","Map","color","layer","index","picked","getLayerPickingInfo","has","object","set","Array","from","values","Number","isFinite","pickableLayers","filter","isPickable","length","Uint8Array","readPixels","pixelArray","getViewportFromCoordinates","viewport","valid","max","min","lastPickedObjectIndex","lastPickedLayerId","pickedLayerId","props","id","lastPickedLayer","find","unshift","baseInfo","pixel","lngLat","unproject","devicePixel","infos","assign","pickingSelectedColor","autoHighlight","pickingParameters","model","getModels","updateModuleSettings","unhandledPickInfos","callLayerPickingCallbacks","handled","onClick","onHover","Error","minSquareDistanceToCenter","closestPixelIndex","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","decodePickingColor","error","uniqueColors","colorKey","join","sourceLayer","pickLayer","parent"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {drawPickingBuffer, getPixelRatio} from './draw-layers';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\nexport function pickObject(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    radius,\n    layerFilter,\n    depth = 1,\n    mode,\n    onViewportActive,\n    pickingFBO,\n    lastPickedInfo,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n  const deviceX = Math.round(x * pixelRatio);\n  const deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRadius = Math.round(radius * pixelRatio);\n\n  const deviceRect = getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth: pickingFBO.width,\n    deviceHeight: pickingFBO.height\n  });\n\n  const result = [];\n  const affectedLayers = {};\n\n  for (let i = 0; i < depth; i++) {\n    const pickedColors =\n      deviceRect &&\n      drawAndSamplePickingBuffer(gl, {\n        layers,\n        viewports,\n        onViewportActive,\n        useDevicePixels,\n        pickingFBO,\n        deviceRect,\n        layerFilter,\n        redrawReason: mode\n      });\n\n    const pickInfo =\n      (pickedColors &&\n        getClosestFromPickingBuffer(gl, {\n          pickedColors,\n          layers,\n          deviceX,\n          deviceY,\n          deviceRadius,\n          deviceRect\n        })) ||\n      NO_PICKED_OBJECT;\n\n    // Only exclude if we need to run picking again.\n    // We need to run picking again if an object is detected AND\n    // we have not exhausted the requested depth.\n    if (pickInfo.pickedColor && i + 1 < depth) {\n      const layerId = pickInfo.pickedColor[3] - 1;\n      if (!affectedLayers[layerId]) {\n        // backup original colors\n        affectedLayers[layerId] = layers[layerId].copyPickingColors();\n      }\n      layers[layerId].clearPickingColor(pickInfo.pickedColor);\n    }\n\n    // This logic needs to run even if no object is picked.\n    const processedPickInfos = processPickInfo({\n      pickInfo,\n      lastPickedInfo,\n      mode,\n      layers,\n      viewports,\n      x,\n      y,\n      deviceX,\n      deviceY,\n      pixelRatio\n    });\n\n    if (processedPickInfos) {\n      processedPickInfos.forEach(info => result.push(info));\n    }\n\n    // If no object is picked stop.\n    if (!pickInfo.pickedColor) {\n      break;\n    }\n  }\n\n  // reset only affected buffers\n  Object.keys(affectedLayers).forEach(layerId =>\n    layers[layerId].restorePickingColors(affectedLayers[layerId])\n  );\n\n  return result;\n}\n\n// Pick all objects within the given bounding box\nexport function pickVisibleObjects(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    width,\n    height,\n    mode,\n    layerFilter,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n\n  const deviceLeft = Math.round(x * pixelRatio);\n  const deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRight = Math.round((x + width) * pixelRatio);\n  const deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n\n  const deviceRect = {\n    x: deviceLeft,\n    y: deviceTop,\n    width: deviceRight - deviceLeft,\n    height: deviceBottom - deviceTop\n  };\n\n  const pickedColors = drawAndSamplePickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels,\n    deviceRect,\n    layerFilter,\n    redrawReason: mode\n  });\n\n  const pickInfos = getUniquesFromPickingBuffer(gl, {pickedColors, layers});\n\n  // Only return unique infos, identified by info.object\n  const uniqueInfos = new Map();\n\n  pickInfos.forEach(pickInfo => {\n    let info = {\n      color: pickInfo.pickedColor,\n      layer: null,\n      index: pickInfo.pickedObjectIndex,\n      picked: true,\n      x,\n      y,\n      width,\n      height,\n      pixelRatio\n    };\n\n    info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n\n  return Array.from(uniqueInfos.values());\n}\n\n// HELPER METHODS\n\n// returns pickedColor or null if no pickable layers found.\nfunction drawAndSamplePickingBuffer(\n  gl,\n  {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  }\n) {\n  assert(deviceRect);\n  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n\n  const pickableLayers = layers.filter(layer => layer.isPickable());\n  if (pickableLayers.length < 1) {\n    return null;\n  }\n\n  drawPickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  });\n\n  // Read from an already rendered picking buffer\n  // Returns an Uint8ClampedArray of picked pixels\n  const {x, y, width, height} = deviceRect;\n  const pickedColors = new Uint8Array(width * height * 4);\n  pickingFBO.readPixels({x, y, width, height, pixelArray: pickedColors});\n  return pickedColors;\n}\n\n// Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\nfunction getViewportFromCoordinates({viewports}) {\n  const viewport = viewports[0];\n  return viewport;\n}\n\n// Calculate a picking rect centered on deviceX and deviceY and clipped to device\n// Returns null if pixel is outside of device\nfunction getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n  const valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;\n\n  // x, y out of bounds.\n  if (!valid) {\n    return null;\n  }\n\n  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n  const x = Math.max(0, deviceX - deviceRadius);\n  const y = Math.max(0, deviceY - deviceRadius);\n  const width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;\n  const height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;\n\n  return {x, y, width, height};\n}\n\n// TODO - break this monster function into 3+ parts\nfunction processPickInfo({\n  pickInfo,\n  lastPickedInfo,\n  mode,\n  layers,\n  viewports,\n  x,\n  y,\n  deviceX,\n  deviceY,\n  pixelRatio\n}) {\n  const {pickedColor, pickedLayer, pickedObjectIndex} = pickInfo;\n\n  const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    const lastPickedObjectIndex = lastPickedInfo.index;\n    const lastPickedLayerId = lastPickedInfo.layerId;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n\n    // proceed only if picked object changed\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  const viewport = getViewportFromCoordinates({viewports}); // TODO - add coords\n\n  const baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x,\n    y,\n    pixel: [x, y],\n    lngLat: viewport.unproject([x, y]),\n    devicePixel: [deviceX, deviceY],\n    pixelRatio\n  };\n\n  // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n  const infos = new Map();\n\n  affectedLayers.forEach(layer => {\n    let info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({layer, info, mode});\n\n    // This guarantees that there will be only one copy of info for\n    // one composite layer\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    const pickingSelectedColor =\n      layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;\n\n    const pickingParameters = {\n      pickingSelectedColor\n    };\n\n    for (const model of layer.getModels()) {\n      model.updateModuleSettings(pickingParameters);\n    }\n  });\n\n  const unhandledPickInfos = callLayerPickingCallbacks(infos, mode);\n\n  return unhandledPickInfos;\n}\n\n// Per-layer event handlers (e.g. onClick, onHover) are provided by the\n// user and out of deck.gl's control. It's very much possible that\n// the user calls React lifecycle methods in these function, such as\n// ReactComponent.setState(). React lifecycle methods sometimes induce\n// a re-render and re-generation of props of deck.gl and its layers,\n// which invalidates all layers currently passed to this very function.\n\n// Therefore, per-layer event handlers must be invoked at the end\n// of the picking operation. NO operation that relies on the states of current\n// layers should be called after this code.\nfunction callLayerPickingCallbacks(infos, mode) {\n  const unhandledPickInfos = [];\n\n  infos.forEach(info => {\n    let handled = false;\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n      case 'query':\n        break;\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n\n  return unhandledPickInfos;\n}\n\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestFromPickingBuffer(\n  gl,\n  {pickedColors, layers, deviceX, deviceY, deviceRadius, deviceRect}\n) {\n  assert(pickedColors);\n\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedLayer = layers[pickedLayerIndex];\n    if (pickedLayer) {\n      const pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n      return {pickedColor, pickedLayer, pickedObjectIndex};\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n\n  return NO_PICKED_OBJECT;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nfunction getUniquesFromPickingBuffer(gl, {pickedColors, layers}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedLayer = layers[pickedLayerIndex];\n          // eslint-disable-next-line\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor,\n              pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n\n// Walk up the layer composite chain to populate the info object\nfunction getLayerPickingInfo({layer, info, mode}) {\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    const sourceLayer = info.layer || layer;\n    info.layer = layer;\n    // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n    info = layer.pickLayer({info, mode, sourceLayer});\n    layer = layer.parent;\n  }\n  return info;\n}\n"],"file":"pick-layers.js"}