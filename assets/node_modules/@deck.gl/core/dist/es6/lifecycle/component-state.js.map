{"version":3,"sources":["../../../src/lifecycle/component-state.js"],"names":["log","assert","EMPTY_PROPS","Object","freeze","ComponentState","constructor","component","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","getOldProps","resetOldProps","props","freezeAsyncOldProps","propName","hasAsyncProp","getAsyncProp","asyncProp","resolvedValue","isAsyncPropLoading","Boolean","pendingLoadCount","resolvedLoadCount","setAsyncProps","resolvedValues","_asyncPropResolvedValues","originalValues","_asyncPropOriginalValues","defaultValues","_asyncPropDefaultValues","value","_createAsyncPropData","_updateAsyncProp","_didAsyncInputValueChange","fetch","layer","url","Promise","_watchPromise","_setPropValue","lastValue","_setAsyncPropValue","loadCount","undefined","_postProcessValue","promise","then","data","catch","error","dataTransform","defaultValue"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport default class ComponentState {\n  constructor(component = null) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = EMPTY_PROPS; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  freezeAsyncOldProps() {\n    if (!this.oldAsyncProps) {\n      // Make sure oldProps is set\n      this.oldProps = this.oldProps || this.component.props;\n\n      // Deep copy props (Object.assign only handles shallow props)\n      // TODO - Alternatively, just reconfigure the async prop descriptors to fixed values?\n      this.oldAsyncProps = {};\n      for (const propName in this.oldProps) {\n        this.oldAsyncProps[propName] = this.oldProps[propName];\n      }\n    }\n  }\n\n  // ASYNC PROP HANDLING\n  //\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return Boolean(\n      asyncProp &&\n        asyncProp.pendingLoadCount > 0 &&\n        asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n    );\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props._asyncPropResolvedValues || {};\n    const originalValues = props._asyncPropOriginalValues || props;\n    const defaultValues = props._asyncPropDefaultValues || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, value, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      const {fetch} = this.layer.props;\n      const url = value;\n      value = fetch(url);\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.value = value;\n    asyncProp.resolvedValue = value;\n    asyncProp.pendingLoadCount++;\n    asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {\n      assert(value !== undefined);\n\n      // A chance to copy old props before updating\n      this.freezeAsyncOldProps();\n\n      value = this._postProcessValue(propName, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    promise\n      .then(data => this._setAsyncPropValue(propName, data, loadCount))\n      .catch(error => log.error(error));\n  }\n\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(propName, value) {\n    const {dataTransform} = this.component ? this.component.props : {};\n    if (propName === 'data' && dataTransform) {\n      value = dataTransform(value);\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, value, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"],"file":"component-state.js"}