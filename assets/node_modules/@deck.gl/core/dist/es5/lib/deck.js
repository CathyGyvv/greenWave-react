"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layerManager = _interopRequireDefault(require("../lib/layer-manager"));

var _effectManager = _interopRequireDefault(require("../experimental/lib/effect-manager"));

var _effect = _interopRequireDefault(require("../experimental/lib/effect"));

var _log = _interopRequireDefault(require("../utils/log"));

var _luma = require("luma.gl");

var _probe = require("probe.gl");

var _mjolnir = require("mjolnir.js");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _mapController = require("../controllers/map-controller");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function noop() {}

function getPropTypes(PropTypes) {
  // Note: Arrays (layers, views, ) can contain falsy values
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    // layer/view/controller settings
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    controller: PropTypes.func,
    onViewStateChange: PropTypes.func,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    // GL settings
    glOptions: PropTypes.object,
    gl: PropTypes.object,
    pickingRadius: PropTypes.number,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLayerClick: PropTypes.func,
    onLayerHover: PropTypes.func,
    useDevicePixels: PropTypes.bool,
    // Debug settings
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool
  };
}

var defaultProps = {
  id: 'deckgl-overlay',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  onWebGLInitialized: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null,
  useDevicePixels: true,
  debug: false,
  drawPickingColors: false
};
var PREFIX = '-webkit-';
var CURSOR = {
  GRABBING: "".concat(PREFIX, "grabbing"),
  GRAB: "".concat(PREFIX, "grab"),
  POINTER: 'pointer'
};

var getCursor = function getCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
}; // TODO - move into Controller classes


var defaultControllerProps = Object.assign({}, _mapController.MAPBOX_LIMITS, {
  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  getCursor: getCursor
});

var Deck =
/*#__PURE__*/
function () {
  function Deck(props) {
    _classCallCheck(this, Deck);

    props = Object.assign({}, defaultProps, props);
    this.width = 0; // "read-only", auto-updated from canvas

    this.height = 0; // "read-only", auto-updated from canvas

    this.needsRedraw = true;
    this.layerManager = null;
    this.effectManager = null;
    this.controller = null;
    this.stats = new _probe.Stats({
      id: 'deck.gl'
    });
    this.viewState = props.initialViewState || null; // Internal view state if no callback is supplied

    this.interactiveState = {
      isDragging: false // Whether the cursor is down

    }; // Bind methods

    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);
    this._onViewStateChange = this._onViewStateChange.bind(this);
    this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this); // Note: LayerManager creation deferred until gl context available

    this.canvas = this._createCanvas(props);
    this.controller = this._createController(props);
    this.animationLoop = this._createAnimationLoop(props);
    this.setProps(props);
    this.animationLoop.start();
  }

  _createClass(Deck, [{
    key: "finalize",
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }

      if (this.controller) {
        this.controller.finalize();
        this.controller = null;
      }

      if (this.eventManager) {
        this.eventManager.destroy();
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.stats.timeStart('deck.setProps');
      props = Object.assign({}, this.props, props);
      this.props = props; // Update CSS size of canvas

      this._setCanvasSize(props); // We need to overwrite CSS style width and height with actual, numeric values


      var newProps = Object.assign({}, props, {
        viewState: this._getViewState(props),
        width: this.width,
        height: this.height
      }); // Update layer manager props (but not size)

      if (this.layerManager) {
        this.layerManager.setParameters(newProps);
      } // Update animation loop


      if (this.animationLoop) {
        this.animationLoop.setProps(newProps);
      } // Update controller props


      if (this.controller) {
        this.controller.setProps(Object.assign(newProps, {
          onViewStateChange: this._onViewStateChange
        }));
      }

      this.stats.timeEnd('deck.setProps');
    } // Public API

  }, {
    key: "pickObject",
    value: function pickObject(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
      this.stats.timeStart('deck.pickObject');
      var selectedInfos = this.layerManager.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        mode: 'query',
        depth: 1
      });
      this.stats.timeEnd('deck.pickObject');
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$radius = _ref3.radius,
          radius = _ref3$radius === void 0 ? 0 : _ref3$radius,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds,
          _ref3$depth = _ref3.depth,
          depth = _ref3$depth === void 0 ? 10 : _ref3$depth;
      this.stats.timeStart('deck.pickMultipleObjects');
      var selectedInfos = this.layerManager.pickObject({
        x: x,
        y: y,
        radius: radius,
        layerIds: layerIds,
        mode: 'query',
        depth: depth
      });
      this.stats.timeEnd('deck.pickMultipleObjects');
      return selectedInfos;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height,
          _ref4$layerIds = _ref4.layerIds,
          layerIds = _ref4$layerIds === void 0 ? null : _ref4$layerIds;
      this.stats.timeStart('deck.pickObjects');
      var infos = this.layerManager.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layerIds: layerIds
      });
      this.stats.timeEnd('deck.pickObjects');
      return infos;
    }
  }, {
    key: "getViewports",
    value: function getViewports() {
      return this.layerManager ? this.layerManager.getViewports() : [];
    } // Private Methods
    // canvas, either string, canvas or `null`

  }, {
    key: "_createCanvas",
    value: function _createCanvas(props) {
      var canvas = props.canvas; // TODO EventManager should accept element id

      if (typeof canvas === 'string') {
        /* global document */
        canvas = document.getElementById(canvas);
        (0, _assert.default)(canvas);
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        var parent = props.parent || document.body;
        parent.appendChild(canvas);
      }

      var id = props.id,
          style = props.style;
      canvas.id = id;
      Object.assign(canvas.style, style);
      return canvas;
    } // Updates canvas width and/or height, if provided as props

  }, {
    key: "_setCanvasSize",
    value: function _setCanvasSize(props) {
      var canvas = this.canvas;
      var width = props.width,
          height = props.height; // Set size ONLY if props are being provided, otherwise let canvas be layouted freely

      if (width || width === 0) {
        width = Number.isFinite(width) ? "".concat(width, "px") : width;
        canvas.style.width = width;
      }

      if (height || height === 0) {
        height = Number.isFinite(height) ? "".concat(height, "px") : height; // Note: position==='absolute' required for height 100% to work

        canvas.style.position = 'absolute';
        canvas.style.height = height;
      }
    } // If canvas size has changed, updates

  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        var width = this.width,
            height = this.height;
        this.layerManager.setParameters({
          width: width,
          height: height
        });

        if (this.controller) {
          this.controller.setProps({
            viewState: this._getViewState(this.props),
            width: this.width,
            height: this.height
          });
        }

        if (this.props.onResize) {
          this.props.onResize({
            width: this.width,
            height: this.height
          });
        }
      }
    } // If canvas size has changed, reads out the new size and returns true

  }, {
    key: "_checkForCanvasSizeChange",
    value: function _checkForCanvasSizeChange() {
      var canvas = this.canvas;

      if (canvas && (this.width !== canvas.clientWidth || this.height !== canvas.clientHeight)) {
        this.width = canvas.clientWidth;
        this.height = canvas.clientHeight;
        return true;
      }

      return false;
    } // Note: props.controller must be a class constructor, not an already created instance

  }, {
    key: "_createController",
    value: function _createController(props) {
      var controller = null;

      if (props.controller) {
        var Controller = props.controller;
        controller = new Controller(props);
        controller.setProps(Object.assign({}, this.props, defaultControllerProps, {
          eventManager: this.eventManager,
          viewState: this._getViewState(props),
          // Set an internal callback that calls the prop callback if provided
          onViewStateChange: this._onViewStateChange,
          onStateChange: this._onInteractiveStateChange
        }));
      }

      return controller;
    }
  }, {
    key: "_createAnimationLoop",
    value: function _createAnimationLoop(props) {
      var _this = this;

      var width = props.width,
          height = props.height,
          gl = props.gl,
          glOptions = props.glOptions,
          debug = props.debug,
          useDevicePixels = props.useDevicePixels,
          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      return new _luma.AnimationLoop({
        width: width,
        height: height,
        useDevicePixels: useDevicePixels,
        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
        onCreateContext: function onCreateContext(opts) {
          return gl || (0, _luma.createGLContext)(Object.assign({}, glOptions, opts, {
            canvas: _this.canvas,
            debug: debug
          }));
        },
        onInitialize: this._onRendererInitialized,
        onRender: this._onRenderFrame,
        onBeforeRender: props.onBeforeRender,
        onAfterRender: props.onAfterRender
      });
    } // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
    // TODO: For backwards compatibility ensure numeric width and height is added to the viewState

  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      return Object.assign({}, props.viewState || this.viewState || {}, {
        width: this.width,
        height: this.height
      });
    } // Callbacks

  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(_ref5) {
      var viewState = _ref5.viewState;

      // Let app know that view state is changing, and give it a chance to change it
      if (this.props.onViewStateChange) {
        var _this$props;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        viewState = (_this$props = this.props).onViewStateChange.apply(_this$props, [{
          viewState: viewState
        }].concat(args)) || viewState;
      } // If initialViewState was set on creation, auto track position


      if (this.viewState) {
        this.viewState = viewState;
        this.layerManager.setParameters({
          viewState: viewState
        });
        this.controller.setProps({
          viewState: viewState
        });
      }
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref6) {
      var _ref6$isDragging = _ref6.isDragging,
          isDragging = _ref6$isDragging === void 0 ? false : _ref6$isDragging;

      if (isDragging !== this.interactiveState.isDragging) {
        this.interactiveState.isDragging = isDragging;

        if (this.props.getCursor) {
          this.canvas.style.cursor = this.props.getCursor(this.interactiveState);
        }
      }
    }
  }, {
    key: "_onRendererInitialized",
    value: function _onRendererInitialized(_ref7) {
      var gl = _ref7.gl,
          canvas = _ref7.canvas;
      (0, _luma.setParameters)(gl, {
        blend: true,
        blendFunc: [_luma.GL.SRC_ALPHA, _luma.GL.ONE_MINUS_SRC_ALPHA, _luma.GL.ONE, _luma.GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: _luma.GL.LEQUAL
      });
      this.props.onWebGLInitialized(gl);
      this.eventManager = new _mjolnir.EventManager(canvas);

      if (this.controller) {
        this.controller.setProps({
          eventManager: this.eventManager
        });
      } // Note: avoid React setState due GL animation loop / setState timing issue


      this.layerManager = new _layerManager.default(gl, {
        eventManager: this.eventManager,
        stats: this.stats
      });
      this.effectManager = new _effectManager.default({
        gl: gl,
        layerManager: this.layerManager
      });
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setProps(this.props);

      this._updateCanvasSize();
    }
  }, {
    key: "_onRenderFrame",
    value: function _onRenderFrame(_ref8) {
      var gl = _ref8.gl;

      if (this.stats.oneSecondPassed()) {
        var table = this.stats.getStatsTable();
        this.stats.reset();

        _log.default.table(1, table)();
      }

      this._updateCanvasSize(); // Update layers if needed (e.g. some async prop has loaded)


      this.layerManager.updateLayers();
      this.stats.bump('fps');
      var redrawReason = this.layerManager.needsRedraw({
        clearRedrawFlags: true
      });

      if (!redrawReason) {
        return;
      }

      this.stats.bump('render-fps');

      if (this.props.onBeforeRender) {
        this.props.onBeforeRender({
          gl: gl
        }); // TODO - should be called by AnimationLoop
      }

      this.layerManager.drawLayers({
        pass: 'screen',
        redrawReason: redrawReason,
        // Helps debug layer picking, especially in framebuffer powered layers
        drawPickingColors: this.props.drawPickingColors
      });

      if (this.props.onAfterRender) {
        this.props.onAfterRender({
          gl: gl
        }); // TODO - should be called by AnimationLoop
      }
    }
  }]);

  return Deck;
}();

exports.default = Deck;
Deck.displayName = 'Deck';
Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
//# sourceMappingURL=deck.js.map