{"version":3,"sources":["../../../src/lib/pick-layers.js"],"names":["NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","pickObject","gl","layers","viewports","x","y","radius","layerFilter","depth","mode","onViewportActive","pickingFBO","lastPickedInfo","useDevicePixels","pixelRatio","deviceX","Math","round","deviceY","canvas","height","deviceRadius","deviceRect","getPickingRect","deviceWidth","width","deviceHeight","result","affectedLayers","i","pickedColors","drawAndSamplePickingBuffer","redrawReason","pickInfo","getClosestFromPickingBuffer","layerId","copyPickingColors","clearPickingColor","processedPickInfos","processPickInfo","forEach","push","info","Object","keys","restorePickingColors","pickVisibleObjects","deviceLeft","deviceBottom","deviceRight","deviceTop","pickInfos","getUniquesFromPickingBuffer","uniqueInfos","Map","color","layer","index","picked","getLayerPickingInfo","has","object","set","Array","from","values","Number","isFinite","pickableLayers","filter","isPickable","length","Uint8Array","readPixels","pixelArray","getViewportFromCoordinates","viewport","valid","max","min","lastPickedObjectIndex","lastPickedLayerId","pickedLayerId","props","id","lastPickedLayer","find","unshift","baseInfo","pixel","lngLat","unproject","devicePixel","infos","assign","pickingSelectedColor","autoHighlight","pickingParameters","getModels","model","updateModuleSettings","unhandledPickInfos","callLayerPickingCallbacks","handled","onClick","onHover","Error","minSquareDistanceToCenter","closestPixelIndex","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","decodePickingColor","log","error","uniqueColors","colorKey","join","sourceLayer","pickLayer","parent"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {drawPickingBuffer, getPixelRatio} from './draw-layers';\nimport log from '../utils/log';\nimport assert from '../utils/assert';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\nexport function pickObject(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    radius,\n    layerFilter,\n    depth = 1,\n    mode,\n    onViewportActive,\n    pickingFBO,\n    lastPickedInfo,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n  const deviceX = Math.round(x * pixelRatio);\n  const deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRadius = Math.round(radius * pixelRatio);\n\n  const deviceRect = getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth: pickingFBO.width,\n    deviceHeight: pickingFBO.height\n  });\n\n  const result = [];\n  const affectedLayers = {};\n\n  for (let i = 0; i < depth; i++) {\n    const pickedColors =\n      deviceRect &&\n      drawAndSamplePickingBuffer(gl, {\n        layers,\n        viewports,\n        onViewportActive,\n        useDevicePixels,\n        pickingFBO,\n        deviceRect,\n        layerFilter,\n        redrawReason: mode\n      });\n\n    const pickInfo =\n      (pickedColors &&\n        getClosestFromPickingBuffer(gl, {\n          pickedColors,\n          layers,\n          deviceX,\n          deviceY,\n          deviceRadius,\n          deviceRect\n        })) ||\n      NO_PICKED_OBJECT;\n\n    // Only exclude if we need to run picking again.\n    // We need to run picking again if an object is detected AND\n    // we have not exhausted the requested depth.\n    if (pickInfo.pickedColor && i + 1 < depth) {\n      const layerId = pickInfo.pickedColor[3] - 1;\n      if (!affectedLayers[layerId]) {\n        // backup original colors\n        affectedLayers[layerId] = layers[layerId].copyPickingColors();\n      }\n      layers[layerId].clearPickingColor(pickInfo.pickedColor);\n    }\n\n    // This logic needs to run even if no object is picked.\n    const processedPickInfos = processPickInfo({\n      pickInfo,\n      lastPickedInfo,\n      mode,\n      layers,\n      viewports,\n      x,\n      y,\n      deviceX,\n      deviceY,\n      pixelRatio\n    });\n\n    if (processedPickInfos) {\n      processedPickInfos.forEach(info => result.push(info));\n    }\n\n    // If no object is picked stop.\n    if (!pickInfo.pickedColor) {\n      break;\n    }\n  }\n\n  // reset only affected buffers\n  Object.keys(affectedLayers).forEach(layerId =>\n    layers[layerId].restorePickingColors(affectedLayers[layerId])\n  );\n\n  return result;\n}\n\n// Pick all objects within the given bounding box\nexport function pickVisibleObjects(\n  gl,\n  {\n    layers,\n    viewports,\n    x,\n    y,\n    width,\n    height,\n    mode,\n    layerFilter,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels\n  }\n) {\n  // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n  const pixelRatio = getPixelRatio({useDevicePixels});\n\n  const deviceLeft = Math.round(x * pixelRatio);\n  const deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  const deviceRight = Math.round((x + width) * pixelRatio);\n  const deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n\n  const deviceRect = {\n    x: deviceLeft,\n    y: deviceTop,\n    width: deviceRight - deviceLeft,\n    height: deviceBottom - deviceTop\n  };\n\n  const pickedColors = drawAndSamplePickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    useDevicePixels,\n    deviceRect,\n    layerFilter,\n    redrawReason: mode\n  });\n\n  const pickInfos = getUniquesFromPickingBuffer(gl, {pickedColors, layers});\n\n  // Only return unique infos, identified by info.object\n  const uniqueInfos = new Map();\n\n  pickInfos.forEach(pickInfo => {\n    let info = {\n      color: pickInfo.pickedColor,\n      layer: null,\n      index: pickInfo.pickedObjectIndex,\n      picked: true,\n      x,\n      y,\n      width,\n      height,\n      pixelRatio\n    };\n\n    info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n\n  return Array.from(uniqueInfos.values());\n}\n\n// HELPER METHODS\n\n// returns pickedColor or null if no pickable layers found.\nfunction drawAndSamplePickingBuffer(\n  gl,\n  {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  }\n) {\n  assert(deviceRect);\n  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n\n  const pickableLayers = layers.filter(layer => layer.isPickable());\n  if (pickableLayers.length < 1) {\n    return null;\n  }\n\n  drawPickingBuffer(gl, {\n    layers,\n    viewports,\n    onViewportActive,\n    useDevicePixels,\n    pickingFBO,\n    deviceRect,\n    layerFilter,\n    redrawReason\n  });\n\n  // Read from an already rendered picking buffer\n  // Returns an Uint8ClampedArray of picked pixels\n  const {x, y, width, height} = deviceRect;\n  const pickedColors = new Uint8Array(width * height * 4);\n  pickingFBO.readPixels({x, y, width, height, pixelArray: pickedColors});\n  return pickedColors;\n}\n\n// Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\nfunction getViewportFromCoordinates({viewports}) {\n  const viewport = viewports[0];\n  return viewport;\n}\n\n// Calculate a picking rect centered on deviceX and deviceY and clipped to device\n// Returns null if pixel is outside of device\nfunction getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n  const valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;\n\n  // x, y out of bounds.\n  if (!valid) {\n    return null;\n  }\n\n  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n  const x = Math.max(0, deviceX - deviceRadius);\n  const y = Math.max(0, deviceY - deviceRadius);\n  const width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;\n  const height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;\n\n  return {x, y, width, height};\n}\n\n// TODO - break this monster function into 3+ parts\nfunction processPickInfo({\n  pickInfo,\n  lastPickedInfo,\n  mode,\n  layers,\n  viewports,\n  x,\n  y,\n  deviceX,\n  deviceY,\n  pixelRatio\n}) {\n  const {pickedColor, pickedLayer, pickedObjectIndex} = pickInfo;\n\n  const affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    const lastPickedObjectIndex = lastPickedInfo.index;\n    const lastPickedLayerId = lastPickedInfo.layerId;\n    const pickedLayerId = pickedLayer && pickedLayer.props.id;\n\n    // proceed only if picked object changed\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      }\n\n      // Update layer manager context\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  const viewport = getViewportFromCoordinates({viewports}); // TODO - add coords\n\n  const baseInfo = {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x,\n    y,\n    pixel: [x, y],\n    lngLat: viewport.unproject([x, y]),\n    devicePixel: [deviceX, deviceY],\n    pixelRatio\n  };\n\n  // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n  const infos = new Map();\n\n  affectedLayers.forEach(layer => {\n    let info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({layer, info, mode});\n\n    // This guarantees that there will be only one copy of info for\n    // one composite layer\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    const pickingSelectedColor =\n      layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;\n\n    const pickingParameters = {\n      pickingSelectedColor\n    };\n\n    for (const model of layer.getModels()) {\n      model.updateModuleSettings(pickingParameters);\n    }\n  });\n\n  const unhandledPickInfos = callLayerPickingCallbacks(infos, mode);\n\n  return unhandledPickInfos;\n}\n\n// Per-layer event handlers (e.g. onClick, onHover) are provided by the\n// user and out of deck.gl's control. It's very much possible that\n// the user calls React lifecycle methods in these function, such as\n// ReactComponent.setState(). React lifecycle methods sometimes induce\n// a re-render and re-generation of props of deck.gl and its layers,\n// which invalidates all layers currently passed to this very function.\n\n// Therefore, per-layer event handlers must be invoked at the end\n// of the picking operation. NO operation that relies on the states of current\n// layers should be called after this code.\nfunction callLayerPickingCallbacks(infos, mode) {\n  const unhandledPickInfos = [];\n\n  infos.forEach(info => {\n    let handled = false;\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n      case 'query':\n        break;\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n\n  return unhandledPickInfos;\n}\n\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestFromPickingBuffer(\n  gl,\n  {pickedColors, layers, deviceX, deviceY, deviceRadius, deviceRect}\n) {\n  assert(pickedColors);\n\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedLayer = layers[pickedLayerIndex];\n    if (pickedLayer) {\n      const pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n      return {pickedColor, pickedLayer, pickedObjectIndex};\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n\n  return NO_PICKED_OBJECT;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nfunction getUniquesFromPickingBuffer(gl, {pickedColors, layers}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedLayer = layers[pickedLayerIndex];\n          // eslint-disable-next-line\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor,\n              pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n\n// Walk up the layer composite chain to populate the info object\nfunction getLayerPickingInfo({layer, info, mode}) {\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    const sourceLayer = info.layer || layer;\n    info.layer = layer;\n    // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n    info = layer.pickLayer({info, mode, sourceLayer});\n    layer = layer.parent;\n  }\n  return info;\n}\n"],"file":"pick-layers.js"}