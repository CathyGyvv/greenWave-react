"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShaders = getShaders;
exports.getBuffers = getBuffers;
exports.padBuffer = padBuffer;

var _luma = require("luma.gl");

var _flatten = require("../utils/flatten");

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

var ATTRIBUTE_MAPPING = {
  1: 'float',
  2: 'vec2',
  3: 'vec3',
  4: 'vec4'
};

function getShaders(transitions) {
  // Build shaders
  var varyings = [];
  var attributeDeclarations = [];
  var uniformsDeclarations = [];
  var varyingDeclarations = [];
  var calculations = [];

  for (var attributeName in transitions) {
    var transition = transitions[attributeName];
    var attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];

    if (attributeType) {
      transition.bufferIndex = varyings.length;
      varyings.push(attributeName);
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "From;"));
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "To;"));
      uniformsDeclarations.push("uniform float ".concat(attributeName, "Time;"));
      varyingDeclarations.push("varying ".concat(attributeType, " ").concat(attributeName, ";"));
      calculations.push("".concat(attributeName, " = mix(").concat(attributeName, "From, ").concat(attributeName, "To,\n        ").concat(attributeName, "Time);"));
    }
  }

  var vs = "\n#define SHADER_NAME feedback-vertex-shader\n".concat(attributeDeclarations.join('\n'), "\n").concat(uniformsDeclarations.join('\n'), "\n").concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  ").concat(calculations.join('\n'), "\n  gl_Position = vec4(0.0);\n}\n");
  var fs = "#define SHADER_NAME feedback-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n".concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n");
  return {
    vs: vs,
    fs: fs,
    varyings: varyings
  };
}

function getBuffers(transitions) {
  var sourceBuffers = {};
  var destinationBuffers = {};

  for (var attributeName in transitions) {
    var _transitions$attribut = transitions[attributeName],
        fromState = _transitions$attribut.fromState,
        toState = _transitions$attribut.toState,
        buffer = _transitions$attribut.buffer;
    sourceBuffers["".concat(attributeName, "From")] = fromState;
    sourceBuffers["".concat(attributeName, "To")] = toState;
    destinationBuffers["".concat(attributeName)] = buffer;
  }

  return {
    sourceBuffers: sourceBuffers,
    destinationBuffers: destinationBuffers
  };
}

function padBuffer(_ref) {
  var fromState = _ref.fromState,
      toState = _ref.toState,
      fromLength = _ref.fromLength,
      toLength = _ref.toLength;

  // check if buffer needs to be padded
  if (fromLength >= toLength || !_instanceof(fromState, _luma.Buffer)) {
    return;
  }

  var data = new Float32Array(toLength); // copy the currect values

  data.set(fromState.getData({}));

  if (toState.isGeneric) {
    (0, _flatten.fillArray)({
      target: data,
      source: toState.value,
      start: fromLength,
      count: (toLength - fromLength) / toState.size
    });
  } else {
    data.set(toState.buffer.data.subarray(fromLength), fromLength);
  }

  fromState.setData({
    data: data
  });
}
//# sourceMappingURL=attribute-transition-utils.js.map