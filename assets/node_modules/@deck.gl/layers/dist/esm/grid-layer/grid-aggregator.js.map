{"version":3,"sources":["../../../src/grid-layer/grid-aggregator.js"],"names":["R_EARTH","pointToDensityGridData","points","cellSize","getPosition","_pointsToGridHashing","gridHash","gridOffset","layerData","_getGridLayerDataFromGridHash","latMin","Infinity","latMax","pLat","p","length","Number","isFinite","centerLat","_calculateGridLatLonOffset","xOffset","yOffset","reduce","accu","pt","lat","lng","latIdx","Math","floor","lonIdx","key","count","push","Object","keys","i","idxs","split","parseInt","assign","index","position","latitude","_calculateLatOffset","_calculateLonOffset","dy","PI","dx","cos"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nconst R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {array} points\n * @param {number} cellSize - cell size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridData(points, cellSize, getPosition) {\n  const {gridHash, gridOffset} = _pointsToGridHashing(points, cellSize, getPosition);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n\n  return {\n    gridOffset,\n    layerData\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {array} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\nfunction _pointsToGridHashing(points = [], cellSize, getPosition) {\n  // find the geometric center of sample points\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n\n  for (let p = 0; p < points.length; p++) {\n    pLat = getPosition(points[p])[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n\n  const centerLat = (latMin + latMax) / 2;\n\n  const gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n  // calculate count per cell\n  const gridHash = points.reduce((accu, pt) => {\n    const lat = getPosition(pt)[1];\n    const lng = getPosition(pt)[0];\n\n    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {\n      return accu;\n    }\n\n    const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n    const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n    const key = `${latIdx}-${lonIdx}`;\n\n    accu[key] = accu[key] || {count: 0, points: []};\n    accu[key].count += 1;\n    accu[key].points.push(pt);\n\n    return accu;\n  }, {});\n\n  return {gridHash, gridOffset};\n}\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(\n      Object.assign(\n        {\n          index: i,\n          position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n        },\n        gridHash[key]\n      )\n    );\n\n    return accu;\n  }, []);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\n"],"file":"grid-aggregator.js"}