{"version":3,"sources":["../../../src/solid-polygon-layer/polygon.js"],"names":["experimental","flattenVertices","earcut","isSimple","polygon","length","Number","isFinite","normalize","dimensions","getVertexCount","reduce","simplePolygon","getTriangleCount","triangleCount","first","size","forEachVertex","visitor","forEach","getHoleIndices","complexPolygon","holeIndices","polygonStartIndex","push","pop","getSurfaceIndices","verts","result"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,YAAR,QAA2B,eAA3B;MACOC,e,GAAmBD,Y,CAAnBC,e;AACP,OAAOC,MAAP,MAAmB,QAAnB,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AAKA,OAAO,SAASC,QAAT,CAAkBC,OAAlB,EAA2B;AAChC,SAAOA,QAAQC,MAAR,IAAkB,CAAlB,IAAuBD,QAAQ,CAAR,EAAWC,MAAX,IAAqB,CAA5C,IAAiDC,OAAOC,QAAP,CAAgBH,QAAQ,CAAR,EAAW,CAAX,CAAhB,CAAxD;AACD;AAED;;;;;;;;AAOA,OAAO,SAASI,SAAT,CAAmBJ,OAAnB,EAA4B;AAACK,eAAa;AAAd,IAAmB,EAA/C,EAAmD;AACxD,SAAON,SAASC,OAAT,IAAoB,CAACA,OAAD,CAApB,GAAgCA,OAAvC;AACD;AAED;;;;;;AAKA,OAAO,SAASM,cAAT,CAAwBN,OAAxB,EAAiC;AACtC,SAAOD,SAASC,OAAT,IACHA,QAAQC,MADL,GAEHD,QAAQO,MAAR,CAAe,CAACN,MAAD,EAASO,aAAT,KAA2BP,SAASO,cAAcP,MAAjE,EAAyE,CAAzE,CAFJ;AAGD,C,CAED;;AACA,OAAO,SAASQ,gBAAT,CAA0BT,OAA1B,EAAmC;AACxC,MAAIU,gBAAgB,CAApB;AACA,MAAIC,QAAQ,IAAZ;;AACA,OAAK,MAAMH,aAAX,IAA4BJ,UAAUJ,OAAV,CAA5B,EAAgD;AAC9C,UAAMY,OAAOJ,cAAcP,MAA3B;;AACA,QAAIU,KAAJ,EAAW;AACTD,uBAAiBE,QAAQ,CAAR,GAAYA,OAAO,CAAnB,GAAuB,CAAxC;AACD,KAFD,MAEO;AACLF,uBAAiBE,OAAO,CAAxB;AACD;;AACDD,YAAQ,KAAR;AACD;;AACD,SAAOD,aAAP;AACD;AAED,OAAO,SAASG,aAAT,CAAuBb,OAAvB,EAAgCc,OAAhC,EAAyC;AAC9C,MAAIf,SAASC,OAAT,CAAJ,EAAuB;AACrBA,YAAQe,OAAR,CAAgBD,OAAhB;AACA;AACD;;AAEDd,UAAQe,OAAR,CAAgBP,iBAAiB;AAC/BA,kBAAcO,OAAd,CAAsBD,OAAtB;AACD,GAFD;AAGD,C,CAED;;AACA,SAASE,cAAT,CAAwBC,cAAxB,EAAwC;AACtC,MAAIC,cAAc,IAAlB;;AACA,MAAID,eAAehB,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,QAAIkB,oBAAoB,CAAxB;AACAD,kBAAc,EAAd;AACAD,mBAAeF,OAAf,CAAuBf,WAAW;AAChCmB,2BAAqBnB,QAAQC,MAA7B;AACAiB,kBAAYE,IAAZ,CAAiBD,iBAAjB;AACD,KAHD,EAH6B,CAO7B;;AACAD,gBAAYG,GAAZ;AACD;;AACD,SAAOH,WAAP;AACD;AAED;;;;;;;;AAMA,OAAO,SAASI,iBAAT,CAA2BL,cAA3B,EAA2C;AAChD;AACA,QAAMC,cAAcF,eAAeC,cAAf,CAApB,CAFgD,CAGhD;;AACA,QAAMM,QAAQ1B,gBAAgBoB,cAAhB,EAAgC;AAACZ,gBAAY,CAAb;AAAgBmB,YAAQ;AAAxB,GAAhC,CAAd,CAJgD,CAKhD;;AACA,SAAO1B,OAAOyB,KAAP,EAAcL,WAAd,EAA2B,CAA3B,CAAP;AACD","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {experimental} from '@deck.gl/core';\nconst {flattenVertices} = experimental;\nimport earcut from 'earcut';\n\n// Basic polygon support\n//\n// Handles simple and complex polygons\n// Simple polygons are arrays of vertices, implicitly \"closed\"\n// Complex polygons are arrays of simple polygons, with the first polygon\n// representing the outer hull and other polygons representing holes\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nexport function isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Normalize to ensure that all polygons in a list are complex - simplifies processing\n * @param {Array} polygon - either a complex or a simple polygon\n * @param {Object} opts\n * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed\n * @return {Array} - returns a complex polygons\n */\nexport function normalize(polygon, {dimensions = 3} = {}) {\n  return isSimple(polygon) ? [polygon] : polygon;\n}\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nexport function getVertexCount(polygon) {\n  return isSimple(polygon)\n    ? polygon.length\n    : polygon.reduce((length, simplePolygon) => length + simplePolygon.length, 0);\n}\n\n// Return number of triangles needed to tesselate the polygon\nexport function getTriangleCount(polygon) {\n  let triangleCount = 0;\n  let first = true;\n  for (const simplePolygon of normalize(polygon)) {\n    const size = simplePolygon.length;\n    if (first) {\n      triangleCount += size >= 3 ? size - 2 : 0;\n    } else {\n      triangleCount += size + 1;\n    }\n    first = false;\n  }\n  return triangleCount;\n}\n\nexport function forEachVertex(polygon, visitor) {\n  if (isSimple(polygon)) {\n    polygon.forEach(visitor);\n    return;\n  }\n\n  polygon.forEach(simplePolygon => {\n    simplePolygon.forEach(visitor);\n  });\n}\n\n// Returns the offset of each hole polygon in the flattened array for that polygon\nfunction getHoleIndices(complexPolygon) {\n  let holeIndices = null;\n  if (complexPolygon.length > 1) {\n    let polygonStartIndex = 0;\n    holeIndices = [];\n    complexPolygon.forEach(polygon => {\n      polygonStartIndex += polygon.length;\n      holeIndices.push(polygonStartIndex);\n    });\n    // Last element points to end of the flat array, remove it\n    holeIndices.pop();\n  }\n  return holeIndices;\n}\n\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\nexport function getSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  const holeIndices = getHoleIndices(complexPolygon);\n  // Flatten the polygon as expected by earcut\n  const verts = flattenVertices(complexPolygon, {dimensions: 2, result: []});\n  // Let earcut triangulate the polygon\n  return earcut(verts, holeIndices, 2);\n}\n"],"file":"polygon.js"}