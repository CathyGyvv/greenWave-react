"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _luma = require("luma.gl");

var _polygonTesselator = require("./polygon-tesselator");

var _solidPolygonLayerVertex = _interopRequireDefault(require("./solid-polygon-layer-vertex.glsl"));

var _solidPolygonLayerFragment = _interopRequireDefault(require("./solid-polygon-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) { return o.__proto__; }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var defaultLineColor = [0x0, 0x0, 0x0, 0xff];
var defaultFillColor = [0x0, 0x0, 0x0, 0xff];
var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,
  // elevation multiplier
  elevationScale: 1,
  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return f.polygon;
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return f.elevation || 0;
  },
  // Accessor for colors
  getFillColor: function getFillColor(f) {
    return f.fillColor || defaultFillColor;
  },
  getLineColor: function getLineColor(f) {
    return f.lineColor || defaultLineColor;
  },
  // Optional settings for 'lighting' shader module
  lightSettings: {}
}; // Side model attributes

var SIDE_FILL_POSITIONS = new Float32Array([// top left corner
0, 1, // bottom left corner
0, 0, // top right corner
1, 1, // bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([// top right corner
1, 1, // top left corner
0, 1, // bottom left corner
0, 0, // bottom right corner
1, 0]); // Model types

var ATTRIBUTE_OVERRIDES = {
  TOP: null,
  SIDE: {
    instanced: 1
  },
  WIRE: {
    instanced: 1
  }
};
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: 'indices',
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    elevations: 'elevations',
    colors: 'fillColors',
    pickingColors: 'pickingColors'
  },
  SIDE: {
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    nextPositions: 'nextPositions',
    nextPositions64xyLow: 'nextPositions64xyLow',
    elevations: 'elevations',
    colors: 'fillColors',
    pickingColors: 'pickingColors'
  },
  WIRE: {
    positions: 'positions',
    positions64xyLow: 'positions64xyLow',
    nextPositions: 'nextPositions',
    nextPositions64xyLow: 'nextPositions64xyLow',
    elevations: 'elevations',
    colors: 'lineColors',
    pickingColors: 'pickingColors'
  }
};

var SolidPolygonLayer =
/*#__PURE__*/
function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.is64bitEnabled() ? 'project64' : 'project32';
      return {
        vs: _solidPolygonLayerVertex.default,
        fs: _solidPolygonLayerFragment.default,
        modules: [projectModule, 'lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var gl = this.context.gl;
      this.setState({
        numInstances: 0,
        IndexType: (0, _luma.hasFeature)(gl, _luma.FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      });
      var attributeManager = this.getAttributeManager();
      var noAlloc = true;
      /* eslint-disable max-len */

      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc: noAlloc
        },
        positions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        positions64xyLow: {
          size: 2,
          accessor: 'fp64',
          update: this.calculatePositionsLow
        },
        nextPositions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        nextPositions64xyLow: {
          size: 2,
          accessor: 'fp64',
          update: this.calculateNextPositionsLow
        },
        elevations: {
          size: 1,
          accessor: ['extruded', 'getElevation'],
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          defaultValue: defaultFillColor,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          defaultValue: defaultLineColor,
          noAlloc: noAlloc
        },
        pickingColors: {
          size: 3,
          type: _luma.GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: noAlloc
        }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          extruded = _this$props.extruded,
          elevationScale = _this$props.elevationScale;
      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      });
      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: "updateState",
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), "updateState", this).call(this, updateParams);

      this.updateGeometry(updateParams);
      var props = updateParams.props,
          oldProps = updateParams.oldProps;
      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        if (this.state.models) {
          this.state.models.forEach(function (model) {
            return model.delete();
          });
        }

        this.setState(Object.assign({
          // Set a flag to set attributes to new models
          modelsChanged: true
        }, this._getModels(this.context.gl)));
      }

      if (props.extruded !== oldProps.extruded) {
        this.state.attributeManager.invalidate('extruded');
      }

      if (props.fp64 !== oldProps.fp64) {
        this.state.attributeManager.invalidate('fp64');
      }
    }
  }, {
    key: "updateGeometry",
    value: function updateGeometry(_ref2) {
      var props = _ref2.props,
          oldProps = _ref2.oldProps,
          changeFlags = _ref2.changeFlags;
      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon); // When the geometry config  or the data is changed,
      // tessellator needs to be invoked

      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);
        this.setState({
          polygonTesselator: this._getPolygonTesselator(polygons, this.state.IndexType)
        });
        this.state.attributeManager.invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: props.fp64,
          extruded: props.extruded
        });
      }
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(props) {
      var _this$state = this.state,
          attributeManager = _this$state.attributeManager,
          modelsChanged = _this$state.modelsChanged; // Figure out data length

      attributeManager.update({
        data: props.data,
        numInstances: 0,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (modelsChanged) {
        this._updateAttributes(attributeManager.getAttributes()); // clear the flag


        this.setState({
          modelsChanged: false
        });
      } else {
        var changedAttributes = attributeManager.getChangedAttributes({
          clearChangedFlags: true
        });

        this._updateAttributes(changedAttributes);
      }
    } // "Experimental" method indended to make it easier to support non-nested arrays in subclasses

  }, {
    key: "_getPolygonTesselator",
    value: function _getPolygonTesselator(polygons, IndexType) {
      return new _polygonTesselator.PolygonTesselator({
        polygons: polygons,
        IndexType: this.state.IndexType
      });
    }
  }, {
    key: "_updateAttributes",
    value: function _updateAttributes(attributes) {
      var modelsByName = this.state.modelsByName;

      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var attributeOverride = ATTRIBUTE_OVERRIDES[modelName];
        var newAttributes = {};

        for (var attributeName in attributeMap) {
          var attribute = attributes[attributeMap[attributeName]];

          if (attribute) {
            newAttributes[attributeName] = attributeOverride ? Object.assign({}, attribute, attributeOverride, {
              buffer: attribute.getBuffer()
            }) : attribute;
          }
        }

        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: "_getModels",
    value: function _getModels(gl) {
      var _this$props2 = this.props,
          id = _this$props2.id,
          filled = _this$props2.filled,
          extruded = _this$props2.extruded,
          wireframe = _this$props2.wireframe;
      var models = {};

      if (filled) {
        models.TOP = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-top"),
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLES,
            attributes: {
              vertexPositions: {
                size: 2,
                isGeneric: true,
                value: new Float32Array([0, 1])
              },
              nextPositions: {
                size: 3,
                isGeneric: true,
                value: new Float32Array(3)
              },
              nextPositions64xyLow: {
                size: 2,
                isGeneric: true,
                value: new Float32Array(2)
              }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }

      if (filled && extruded) {
        models.SIDE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-side"),
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: SIDE_FILL_POSITIONS
              }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      if (extruded && wireframe) {
        models.WIRE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: "".concat(id, "-wire"),
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: SIDE_WIRE_POSITIONS
              }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      var numVertex = attribute.value.length / attribute.size;
      this.setState({
        numVertex: numVertex
      });
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions();
      var numInstances = attribute.value.length / attribute.size;
      this.setState({
        numInstances: numInstances
      });
    }
  }, {
    key: "calculatePositionsLow",
    value: function calculatePositionsLow(attribute) {
      var isFP64 = this.is64bitEnabled();
      attribute.isGeneric = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: "calculateNextPositions",
    value: function calculateNextPositions(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions();
    }
  }, {
    key: "calculateNextPositionsLow",
    value: function calculateNextPositionsLow(attribute) {
      var isFP64 = this.is64bitEnabled();
      attribute.isGeneric = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: "calculateElevations",
    value: function calculateElevations(attribute) {
      var _this = this;

      var _this$props3 = this.props,
          extruded = _this$props3.extruded,
          _getElevation = _this$props3.getElevation;

      if (extruded && typeof _getElevation === 'function') {
        attribute.isGeneric = false;
        attribute.value = this.state.polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _getElevation(_this.props.data[polygonIndex]);
          }
        });
      } else {
        var elevation = extruded ? _getElevation : 0;
        attribute.isGeneric = true;
        attribute.value = new Float32Array([elevation]);
      }
    }
  }, {
    key: "calculateFillColors",
    value: function calculateFillColors(attribute) {
      var _this2 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this2.props.getFillColor(_this2.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: "calculateLineColors",
    value: function calculateLineColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getLineColor(_this3.props.data[polygonIndex]);
        }
      });
    } // Override the default picking colors calculation

  }, {
    key: "calculatePickingColors",
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(_core.Layer);

exports.default = SolidPolygonLayer;
SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=solid-polygon-layer.js.map