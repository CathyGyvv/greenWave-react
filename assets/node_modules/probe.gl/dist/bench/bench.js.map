{"version":3,"sources":["../../src/bench/bench.js"],"names":["logResultsAsMarkdownTable","logResultsAsTree","logResultsAsTreeWithElapsed","noop","TIME_THRESHOLD_MS","TIME_COOLDOWN_MS","MIN_ITERATIONS","LOG_ENTRY","GROUP","TEST","COMPLETE","CALIBRATION_TESTS","id","initFunc","testFunc","opts","Bench","log","time","delay","minIterations","markdown","global","probe","tests","results","table","Object","seal","Math","round","timer","Date","onBenchmarkComplete","promise","runAsyncTests","then","elapsed","logEntry","entry","message","onSuiteComplete","group","priority","func1","func2","iterations","itersPerSecond","current","percent","max","localStorage","LocalStorage","saved","getConfiguration","updateTable","updateConfiguration","console","delta","runCalibrationTests","Promise","resolve","test","runAsyncTest","silent","setTimeout","runBenchTest","iterationsPerSecond","elapsedMillis","multiplier","runBenchTestIterations","testArgs","context","i","call","COL1","toFixed"],"mappings":"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","file":"bench.js","sourcesContent":["/* eslint-disable no-console */\n/* global setTimeout, console */\nimport {formatSI, rightPad} from '../lib/utils/formatters';\nimport {global} from '../lib/utils/globals';\nimport {autobind} from '../lib/utils/autobind';\nimport LocalStorage from '../lib/utils/local-storage';\nimport assert from 'assert';\n\nconst noop = () => {};\n\nconst TIME_THRESHOLD_MS = 80; // Minimum number of milliseconds to iterate each bench test\nconst TIME_COOLDOWN_MS = 5; // milliseconds of \"cooldown\" between tests\nconst MIN_ITERATIONS = 1; // Increase if OK to let slow benchmarks take long time\n\nexport const LOG_ENTRY = {\n  GROUP: 'group',\n  TEST: 'test',\n  COMPLETE: 'complete'\n};\n\nconst CALIBRATION_TESTS = [\n  {\n    id: 'warmup',\n    initFunc: noop,\n    testFunc: () => 100,\n    opts: {}\n  }\n];\n\nexport default class Bench {\n  constructor({\n    id, // Name is needed for regression (storing/loading)\n    log,\n    time = TIME_THRESHOLD_MS,\n    delay = TIME_COOLDOWN_MS,\n    minIterations = MIN_ITERATIONS\n  } = {}) {\n    if (!log) {\n      const markdown = global.probe && global.probe.markdown;\n      log = markdown ? logResultsAsMarkdownTable : logResultsAsTree;\n    }\n\n    this.id = id;\n    this.opts = {log, time, delay, minIterations};\n    this.tests = {};\n    this.results = {};\n    this.table = {};\n    autobind(this);\n    Object.seal(this);\n  }\n\n  calibrate(id, func1, func2, opts) {\n    return this;\n  }\n\n  run() {\n    const timer = new Date();\n\n    const {tests, onBenchmarkComplete} = this;\n    const promise = runAsyncTests({tests, onBenchmarkComplete});\n\n    promise.then(() => {\n      const elapsed = (new Date() - timer) / 1000;\n      logEntry(this, {entry: LOG_ENTRY.COMPLETE, time: elapsed, message: 'Complete'});\n      this.onSuiteComplete();\n    });\n\n    return promise;\n  }\n\n  group(id) {\n    assert(!this.tests[id], 'tests need unique id strings');\n    this.tests[id] = {id, group: true, opts: this.opts};\n    return this;\n  }\n\n  // Signatures:\n  // add(priority, id, initFunc, testFunc)\n  // add(priority, id, testFunc)\n  // add(id, initFunc, testFunc)\n  // add(id, testFunc)\n  add(priority, id, func1, func2) {\n    if (typeof priority === 'string') {\n      func2 = func1;\n      func1 = id;\n      id = priority;\n      priority = 0;\n    }\n\n    assert(id);\n    assert(typeof func1 === 'function');\n\n    let initFunc = null;\n    let testFunc = func1;\n    if (typeof func2 === 'function') {\n      initFunc = func1;\n      testFunc = func2;\n    }\n\n    assert(!this.tests[id], 'tests need unique id strings');\n    this.tests[id] = {id, priority, initFunc, testFunc, opts: this.opts};\n    return this;\n  }\n\n  onBenchmarkComplete({id, time, iterations, itersPerSecond}) {\n    // calculate iterations per second, save as numeric value\n    const current = Math.round(iterations / time);\n    // Format as human readable strings\n    this.table[id] = {\n      percent: '',\n      iterations: `${itersPerSecond}/s`,\n      current,\n      max: ''\n    };\n  }\n\n  onSuiteComplete() {\n    const localStorage = new LocalStorage({id: this.id});\n    const saved = localStorage.getConfiguration();\n    const current = this.updateTable(this.table, saved);\n    localStorage.updateConfiguration(current);\n    console.table(current);\n  }\n\n  updateTable(current, saved) {\n    for (const id in this.table) {\n      if (saved[id] && saved[id].max !== undefined) {\n        current[id].max = Math.max(current[id].current, saved[id].max);\n        const delta = current[id].current / saved[id].max;\n        current[id].percent = `${Math.round(delta * 100 - 100)}%`;\n      } else {\n        current[id].max = current[id].current;\n      }\n    }\n    return current;\n  }\n}\n\n// Helper methods\n\nfunction runCalibrationTests({tests}) {\n  let promise = Promise.resolve(true);\n\n  // Run default warm up and calibration tests\n  for (const test of CALIBRATION_TESTS) {\n    promise = promise.then(() => runAsyncTest({test, silent: true}));\n  }\n\n  return promise;\n}\n\n// Run a list of bench test case async\nfunction runAsyncTests({tests, onBenchmarkComplete = noop}) {\n  // Run default warm up and calibration tests\n  let promise = runCalibrationTests({tests, onBenchmarkComplete});\n\n  // Run the suite tests\n  for (const id in tests) {\n    const test = tests[id];\n    promise = promise.then(() => runAsyncTest({test, onBenchmarkComplete}));\n  }\n  return promise;\n}\n\nfunction runAsyncTest({test, onBenchmarkComplete, silent = false}) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      try {\n        if (test.group) {\n          logEntry(test, {entry: LOG_ENTRY.GROUP, id: test.id, message: test.id});\n        } else {\n          const {time, iterations} = runBenchTest(test);\n\n          const iterationsPerSecond = iterations / time;\n          const itersPerSecond = formatSI(iterationsPerSecond);\n          if (!silent) {\n            logEntry(test, {\n              entry: LOG_ENTRY.TEST, id: test.id, priority: test.priority, itersPerSecond, time,\n              message: `${test.id} ${itersPerSecond}/s`\n            });\n          }\n\n          if (onBenchmarkComplete) {\n            onBenchmarkComplete({\n              id: test.id,\n              time,\n              iterations,\n              iterationsPerSecond,\n              itersPerSecond\n            });\n          }\n        }\n      } finally {\n        resolve(true);\n      }\n    }, test.opts.delay); // small delay between each test. System cools and DOM console updates...\n  });\n}\n\n// Run a test func for an increasing amount of iterations until time threshold exceeded\nfunction runBenchTest(test) {\n  let iterations = test.opts.minIterations / 10;\n  let elapsedMillis = 0;\n\n  // Run increasing amount of interations until we reach time threshold, default at least 100ms\n  while (elapsedMillis < test.opts.time) {\n    let multiplier = 10;\n    if (elapsedMillis > 10) {\n      multiplier = (test.opts.time / elapsedMillis) * 1.25;\n    }\n    iterations *= multiplier;\n    const timer = new Date();\n    runBenchTestIterations(test, iterations);\n    elapsedMillis = new Date() - timer;\n  }\n\n  const time = elapsedMillis / 1000;\n\n  return {time, iterations};\n}\n\n// Run a test func for a specific amount of iterations\nfunction runBenchTestIterations(test, iterations) {\n  const testArgs = test.initFunc && test.initFunc();\n\n  const {context, testFunc} = test;\n  if (context && testArgs) {\n    for (let i = 0; i < iterations; i++) {\n      testFunc.call(context, testArgs);\n    }\n  } else {\n    for (let i = 0; i < iterations; i++) {\n      testFunc.call(context);\n    }\n  }\n}\n\nfunction logEntry(test, opts) {\n  const priority = (global.probe && global.probe.priority) | 10;\n  if ((opts.priority | 0) <= priority) {\n    test.opts.log(opts);\n  }\n}\n\nexport function logResultsAsMarkdownTable({entry, id, itersPerSecond, time}) {\n  const COL1 = 50;\n  const COL2 = 12;\n  switch (entry) {\n  case LOG_ENTRY.GROUP:\n    console.log('');\n    console.log(`| ${rightPad(id, COL1)} | iterations/s |`);\n    console.log(`| ${rightPad('---', COL1)} | ---          |`);\n    break;\n  case LOG_ENTRY.TEST:\n    console.log(`| ${rightPad(id, COL1)} | ${rightPad(itersPerSecond, COL2)} |`);\n    break;\n  case LOG_ENTRY.COMPLETE:\n    console.log('');\n    console.log(`Completed benchmark in ${time}s`);\n    break;\n  default:\n  }\n}\n\nexport function logResultsAsTree({entry, id, itersPerSecond, time}) {\n  switch (entry) {\n  case LOG_ENTRY.GROUP:\n    console.log('');\n    console.log(`${id}`);\n    break;\n  case LOG_ENTRY.TEST:\n    console.log(`├─ ${id}: ${itersPerSecond} iterations/s`);\n    break;\n  case LOG_ENTRY.COMPLETE:\n    console.log('');\n    console.log(`Completed benchmark in ${time}s`);\n    break;\n  default:\n  }\n}\n\nexport function logResultsAsTreeWithElapsed({entry, id, itersPerSecond, time}) {\n  switch (entry) {\n  case LOG_ENTRY.TEST:\n    console.log(`├─ ${id}: ${itersPerSecond} iterations/s (${time.toFixed(2)}s elapsed)`);\n    break;\n  default:\n    logResultsAsTree({entry, id, itersPerSecond, time});\n  }\n}\n\n"]}