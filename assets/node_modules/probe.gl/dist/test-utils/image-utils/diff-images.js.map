{"version":3,"sources":["../../../src/test-utils/image-utils/diff-images.js"],"names":["diffImagePixels","DEFAULT_THRESHOLD","getY","r","g","b","getI","getQ","getESq","dY","dI","dQ","applyAlpha","c","a","colorDelta","img1","img2","index","Math","sqrt","colorDeltaSq","i","a1","a2","r1","g1","b1","r2","g2","b2","data1","data2","delta","colorDeltaThreshold","pixelCount","data","length","badPixels","percentage"],"mappings":"4EA+CgBA,e,CAAAA,e,IA1CVC,mBAA0B,GAAN,I,CAEpBC,KAAO,SAACC,CAAD,CAAIC,CAAJ,CAAOC,CAAP,QAAiB,UAAJ,GAAqB,SAAJ,EAAjB,CAAsC,SAAJ,EAA/C,C,CACPC,KAAO,SAACH,CAAD,CAAIC,CAAJ,CAAOC,CAAP,QAAiB,UAAJ,GAAqB,QAAJ,EAAjB,CAAqC,SAAJ,EAA9C,C,CACPE,KAAO,SAACJ,CAAD,CAAIC,CAAJ,CAAOC,CAAP,QAAiB,UAAJ,GAAqB,SAAJ,EAAjB,CAAsC,SAAJ,EAA/C,C,CACPG,OAAS,SAACC,EAAD,CAAKC,EAAL,CAASC,EAAT,QAAgB,OAASF,EAAT,CAAcA,EAAd,CAAmB,KAAQC,EAAR,CAAaA,EAAhC,CAAqC,MAASC,EAAT,CAAcA,EAAnE,C,CAGTC,WAAa,SAACC,CAAD,CAAIC,CAAJ,QAAU,KAAM,CAACD,EAAI,GAAL,EAAYC,CAAZ,CAAgB,GAAhC,C,CAQnB,QAASC,WAAT,CAAoBC,IAApB,CAA0BC,IAA1B,CAAgCC,KAAhC,CAAuC,CACrC,MAAOC,MAAKC,IAAL,CAAUC,aAAaL,IAAb,CAAmBC,IAAnB,CAAyBC,KAAzB,CAAV,CACR,CAED,QAASG,aAAT,CAAsBL,IAAtB,CAA4BC,IAA5B,CAAkCC,KAAlC,CAAyC,IACjCI,GAAY,CAAR,MAD6B,CAEjCC,GAAKP,KAAKM,EAAI,CAAT,CAF4B,CAGjCE,GAAKP,KAAKK,EAAI,CAAT,CAH4B,CAKjCG,GAAKb,WAAWI,KAAKM,EAAI,CAAT,CAAX,CAAwBC,EAAxB,CAL4B,CAMjCG,GAAKd,WAAWI,KAAKM,EAAI,CAAT,CAAX,CAAwBC,EAAxB,CAN4B,CAOjCI,GAAKf,WAAWI,KAAKM,EAAI,CAAT,CAAX,CAAwBC,EAAxB,CAP4B,CASjCK,GAAKhB,WAAWK,KAAKK,EAAI,CAAT,CAAX,CAAwBE,EAAxB,CAT4B,CAUjCK,GAAKjB,WAAWK,KAAKK,EAAI,CAAT,CAAX,CAAwBE,EAAxB,CAV4B,CAWjCM,GAAKlB,WAAWK,KAAKK,EAAI,CAAT,CAAX,CAAwBE,EAAxB,CAX4B,CAavC,MAAOhB,QACLN,KAAKuB,EAAL,CAASC,EAAT,CAAaC,EAAb,EAAmBzB,KAAK0B,EAAL,CAASC,EAAT,CAAaC,EAAb,CADd,CAELxB,KAAKmB,EAAL,CAASC,EAAT,CAAaC,EAAb,EAAmBrB,KAAKsB,EAAL,CAASC,EAAT,CAAaC,EAAb,CAFd,CAGLvB,KAAKkB,EAAL,CAASC,EAAT,CAAaC,EAAb,EAAmBpB,KAAKqB,EAAL,CAASC,EAAT,CAAaC,EAAb,CAHd,CAKR,CAIM,QAAS9B,gBAAT,CAAyB+B,KAAzB,CAAgCC,KAAhC,CAAgF,CAIrF,OACQC,MADR,CAJ4CC,mBAI5C,wDAJkEjC,iBAIlE,CAHMkC,WAAaJ,MAAMK,IAAN,CAAWC,MAAX,CAAoB,CAGvC,CADIC,UAAY,CAChB,CAAShB,EAAI,CAAb,CAAgBA,EAAIa,UAApB,CAAgCb,GAAhC,CACQW,KADR,CACgBZ,aAAaU,MAAMK,IAAnB,CAAyBJ,MAAMI,IAA/B,CAAqCd,CAArC,CADhB,CAEMW,MAJaC,oBAAsBA,mBAEzC,EAGII,WAHJ,CAMA,GAAMC,YAAa,EAAID,UAAYH,UAAnC,CACA,MAAOI,WACR","file":"diff-images.js","sourcesContent":["/*\n * Calculate perceived color difference using YIQ NTSC transmission color space\n * Based on 2010 paper by Yuriy Kotsarenko and Fernando Ramos\n * http://www.progmat.uaem.mx:8080/artVol2Num2/Articulo3Vol2Num2.pdf\n */\nconst DEFAULT_THRESHOLD = 255 * 0.05;\n\nconst getY = (r, g, b) => r * 0.29889531 + g * 0.58662247 + b * 0.11448223;\nconst getI = (r, g, b) => r * 0.59597799 - g * 0.2741761 - b * 0.32180189;\nconst getQ = (r, g, b) => r * 0.21147017 - g * 0.52261711 + b * 0.31114694;\nconst getESq = (dY, dI, dQ) => 0.5053 * dY * dY + 0.299 * dI * dI + 0.1957 * dQ * dQ;\n\n// Get blended r/g/b value after applying alpha\nconst applyAlpha = (c, a) => 255 + (c - 255) * a / 255;\n\n/**\n * Get dE square at given index from two pixel arrays\n * @param {Uint8ClampedArray} img1 - pixel data of first image\n * @param {Uint8ClampedArray} img2 - pixel data of second image\n * @param {Number} i - pixel index\n */\nfunction colorDelta(img1, img2, index) {\n  return Math.sqrt(colorDeltaSq(img1, img2, index));\n}\n\nfunction colorDeltaSq(img1, img2, index) {\n  const i = index * 4;\n  const a1 = img1[i + 3];\n  const a2 = img2[i + 3];\n\n  const r1 = applyAlpha(img1[i + 0], a1);\n  const g1 = applyAlpha(img1[i + 1], a1);\n  const b1 = applyAlpha(img1[i + 2], a1);\n\n  const r2 = applyAlpha(img2[i + 0], a2);\n  const g2 = applyAlpha(img2[i + 1], a2);\n  const b2 = applyAlpha(img2[i + 2], a2);\n\n  return getESq(\n    getY(r1, g1, b1) - getY(r2, g2, b2),\n    getI(r1, g1, b1) - getI(r2, g2, b2),\n    getQ(r1, g1, b1) - getQ(r2, g2, b2)\n  );\n}\n\n// TODO - expects imagedata structs\n// may need a helper func to accept different arguments types\nexport function diffImagePixels(data1, data2, colorDeltaThreshold = DEFAULT_THRESHOLD) {\n  const pixelCount = data1.data.length / 4;\n  const maxDeltaSq = colorDeltaThreshold * colorDeltaThreshold;\n  let badPixels = 0;\n  for (let i = 0; i < pixelCount; i++) {\n    const delta = colorDeltaSq(data1.data, data2.data, i);\n    if (delta > maxDeltaSq) {\n      badPixels++;\n    }\n  }\n  const percentage = 1 - badPixels / pixelCount;\n  return percentage;\n}\n"]}