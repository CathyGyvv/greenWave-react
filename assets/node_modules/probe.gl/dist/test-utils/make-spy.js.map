{"version":3,"sources":["../../src/test-utils/make-spy.js"],"names":["makeSpy","obj","func","methodName","name","wrapFunction","spy","callCount","called","args","returnValue","apply","Object","assign","reset","restore","returns","method"],"mappings":"4EAMgBA,O,CAAAA,O,CAAT,QAASA,QAAT,CAAiBC,GAAjB,CAAsBC,IAAtB,CAA4B,CACjC,GAAIC,WAAJ,CAeA,MAbKF,IAAD,EAASC,IAab,CAT0B,UAAf,QAAOD,IAAP,EAA8BC,IASzC,EAJEC,WAAaD,IAIf,CAHEA,KAAOD,IAAIE,UAAJ,CAGT,GARED,KAAOD,GAQT,CAPEA,IAAM,EAOR,CANEE,WAAgBD,KAAKE,IAArB,OAMF,GAZEF,KAAO,UAAgB,CAAE,CAY3B,CAXED,IAAM,EAWR,CAVEE,WAAa,KAUf,EAAOE,aAAaJ,GAAb,CAAkBC,IAAlB,CAAwBC,UAAxB,CACR,CAED,QAASE,aAAT,CAAsBJ,GAAtB,CAA2BC,IAA3B,CAAiCC,UAAjC,CAA6C,CAO3C,QAASG,IAAT,EAAsB,CACpBA,IAAIC,SAAJ,EADoB,CAEpBD,IAAIE,MAAJ,GAFoB,+BAANC,IAAM,qCAANA,IAAM,uBAIpB,MAAO,eAAiBH,IAAjB,CAAuBA,IAAII,WAA3B,CAAyCR,KAAKS,KAAL,CAAW,IAAX,CAAiBF,IAAjB,CACjD,CAZ0C,MAEvC,eAAKP,IAFkC,EAe3CU,OAAOC,MAAP,CAAcP,GAAd,CAAmB,CACjBQ,KADiB,iBACT,CACNR,IAAIC,SAAJ,CAAgB,CADV,CAEND,IAAIE,MAAJ,GACD,CAJgB,CAMjBO,OANiB,mBAMP,CACRd,IAAIE,UAAJ,EAAkBD,IACnB,CARgB,CAUjBc,OAViB,kBAUTN,WAVS,CAUI,CACnBJ,IAAII,WAAJ,CAAkBA,WACnB,CAZgB,CAcjBT,OAdiB,CAejBE,qBAfiB,CAgBjBD,SAhBiB,CAiBjBe,OAAQf,IAjBS,CAAnB,CAf2C,CAmC3CI,IAAIQ,KAAJ,EAnC2C,CAsC3Cb,IAAIE,UAAJ,EAAkBG,GAtCyB,CAuCpCA,GAvCoC,EAGlCJ,IAqCV","file":"make-spy.js","sourcesContent":["// Inspired by https://github.com/popomore/spy\n// Attach a spy to the function. The spy has the following methods and fields\n//  * restore() - remove spy completely\n//  * reset() - reset call count\n//  * callCount - number of calls\n//  * called - whether spy was called\nexport function makeSpy(obj, func) {\n  let methodName;\n\n  if (!obj && !func) {\n    func = function mock() {};\n    obj = {};\n    methodName = 'spy';\n  } else if (typeof obj === 'function' && !func) {\n    func = obj;\n    obj = {};\n    methodName = `${func.name}-spy`;\n  } else {\n    methodName = func;\n    func = obj[methodName];\n  }\n\n  return wrapFunction(obj, func, methodName);\n}\n\nfunction wrapFunction(obj, func, methodName) {\n  // will not wrap more than once\n  if (func.func !== undefined) {\n    return func;\n  }\n\n  // create a local function\n  function spy(...args) {\n    spy.callCount++;\n    spy.called = true;\n    /* eslint-disable no-invalid-this */\n    return 'returnValue' in spy ? spy.returnValue : func.apply(this, args);\n  }\n\n  // Add functions and members\n  Object.assign(spy, {\n    reset() {\n      spy.callCount = 0;\n      spy.called = false;\n    },\n\n    restore() {\n      obj[methodName] = func;\n    },\n\n    returns(returnValue) {\n      spy.returnValue = returnValue;\n    },\n\n    obj,\n    methodName,\n    func,\n    method: func\n  });\n\n  spy.reset();\n\n  // Overwrite the spy on the object\n  obj[methodName] = spy;\n  return spy;\n}\n"]}