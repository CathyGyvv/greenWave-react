{"version":3,"sources":["../../src/stats-widgets/stats-widget.js"],"names":["TEXT_SIZE","TEXT_START","TEXT_SPACING","HEADER_SIZE","BOTTOM_SPACING","HEADER_POS","BG","FG","WIDTH","HEIGHT","items","length","StatsWidget","prevGpuTimes","i","totalFrameTime","avgFrameTime","Math","round","deltaTime","totalTime","_clearTextArea","frameTimeCount","drawCalls","drawCall","frameTime","stats","gpuTime","N","pr","window","devicePixelRatio","container","document","createElement","style","cssText","canvas","context","getContext","width","height","fillStyle","fillRect","appendChild","body","font","textBaseline","fillText","textCursor","str"],"mappings":"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","file":"stats-widget.js","sourcesContent":["// Built on https://github.com/Erkaman/regl-stats-widget (MIT license)\n\n// widget styling constants.\nconst TEXT_SIZE = 10;\nconst TEXT_START = [7, 37];\nconst TEXT_SPACING = 6;\nconst HEADER_SIZE = 20;\nconst BOTTOM_SPACING = 20\nconst HEADER_POS = [3, 3];\nconst BG = '#000';\nconst FG = '#ccc';\n\nconst WIDTH = 160;\nconst HEIGHT = items =>\n  items.length * TEXT_SIZE +\n  (items.length - 1) * TEXT_SPACING +\n  TEXT_START[1] +\n  BOTTOM_SPACING;\n\n\nclass StatsWidget {\n\n  constructor(items) {\n    // the widget keeps track of the previous values of gpuTime,\n    // in order to compute the frame time.\n    const prevGpuTimes = []\n    for (let i = 0; i < items.length; i++) {\n      prevGpuTimes[i] = 0\n    }\n\n    // we update the widget every second, we need to keep track of the time:\n    const totalTime = 1.1\n\n    // we show the average frametime to the user.\n    const N = 50\n    const totalFrameTime = []\n    const frameTimeCount = 0\n    const avgFrameTime = []\n    for (i = 0; i < items.length; ++i) {\n      totalFrameTime[i] = 0.0\n      avgFrameTime[i] = 0.0\n    }\n  }\n\n  update(deltaTime) {\n    totalTime += deltaTime\n    if (totalTime > 1.0) {\n      totalTime = 0\n\n\n      // make sure that we clear the old text before drawing new text.\n      _clearTextArea();\n\n      // const frameTime;\n      // for (let i = 0; i < drawCalls.length; i++) {\n      //   const drawCall = drawCalls[i];\n\n      //   this._drawTextItem(context, i, drawCalls[i], avgFrameTime[i]);\n    }\n\n    frameTimeCount++\n    // make sure to update the previous gpuTime, and to compute the average.\n    for (i = 0; i < drawCalls.length; i++) {\n      drawCall = drawCalls[i];\n\n      frameTime = drawCall[0].stats.gpuTime - prevGpuTimes[i];\n      totalFrameTime[i] += frameTime;\n\n      if (frameTimeCount === N) {\n        avgFrameTime[i] = totalFrameTime[i] / N;\n        totalFrameTime[i] = 0.0;\n      }\n\n      prevGpuTimes[i] = drawCall[0].stats.gpuTime;\n    }\n\n    // reset avg calculation.\n    if (frameTimeCount === N) {\n      frameTimeCount = 0;\n    }\n  }\n\n  _createDOM() {\n    const pr = Math.round(window.devicePixelRatio || 1);\n\n    // the widget is contained in a <div>\n    const container = document.createElement('div');\n    container.style.cssText = 'position:fixed;top:20px;left:20px;opacity:0.8;z-index:10000;';\n\n    // we draw the widget on a canvas.\n    const canvas = document.createElement('canvas');\n\n    const context = canvas.getContext('2d');\n\n    // set canvas size\n    canvas.width = WIDTH * pr;\n    canvas.height = HEIGHT * pr;\n    canvas.style.cssText = `width: ${WIDTH}px;height: ${HEIGHT}px`;\n\n    // draw background.\n    context.fillStyle = BG;\n    context.fillRect(0, 0, WIDTH * pr, HEIGHT * pr);\n\n    container.appendChild(canvas);\n    document.body.appendChild(container);\n\n    this.context = context;\n  }\n\n  _drawHeader(context) {\n    const pr = Math.round(window.devicePixelRatio || 1);\n    context.font = `bold ${HEADER_SIZE * pr}px Helvetica,Arial,sans-serif`;\n    context.textBaseline = 'top';\n    context.fillStyle = FG;\n    context.fillText('Stats', HEADER_POS[0] * pr, HEADER_POS[1] * pr);\n  }\n\n  _clearTextArea(context) {\n    const pr = Math.round(window.devicePixelRatio || 1);\n    context.fillStyle = BG;\n    context.fillRect(\n      TEXT_START[0] * pr,\n      TEXT_START[1] * pr,\n      (WIDTH - TEXT_START[0]) * pr,\n      (HEIGHT - TEXT_START[1]) * pr\n    );\n    context.font = `bold ${TEXT_SIZE * pr}px Helvetica,Arial,sans-serif`;\n    context.fillStyle = FG;\n  }\n\n  _drawTextItem(context, i, title, value) {\n    const pr = Math.round(window.devicePixelRatio || 1);\n    // context, i, drawCalls[i], avgFrameTime[i]);\n    const textCursor = [TEXT_START[0], TEXT_START[1]];\n    const str = `${drawCall[1]} : ${Math.round(100.0 * avgFrameTime[i]) / 100.0}ms`\n    context.fillText(str, textCursor[0] * pr, textCursor[1] * pr)\n\n    // next line\n    textCursor[1] += TEXT_SIZE + TEXT_SPACING\n  }\n}\n"]}