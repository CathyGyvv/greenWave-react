{"version":3,"sources":["../../../../src/shadertools/lib/assemble-shaders.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","SHADER_TYPE","MODULE_INJECTORS","MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","FRAGMENT_SHADER_PROLOGUE","getShaderName","id","source","type","injectShaderName","indexOf","getApplicationDefines","defines","count","sourceText","define","toUpperCase","checkDeprecation","moduleName","shaderSource","shaderModule","deprecations","forEach","def","regex","test","deprecated","log","old","new","removed","getModuleSource","moduleSource","vs","vertexShader","fs","fragmentShader","assembleShader","gl","modules","sourceLines","split","versionLine","coreSource","slice","join","assembledSource","inject","replace","assembleGetUniforms","getUniforms","opts","uniforms","moduleUniforms","Object","assign","assembleModuleMap","result","assembleShaders"],"mappings":"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","sourcesContent":["import {resolveModules, getShaderModule} from './shader-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport assert from '../../utils/assert';\nimport {log} from '../../utils';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n`;\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n` : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\n// Warn about deprecated uniforms or functions\nfunction checkDeprecation(moduleName, shaderSource) {\n  const shaderModule = getShaderModule(moduleName);\n\n  shaderModule.deprecations.forEach(def => {\n    if (def.regex.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n\n// Extracts the source code chunk for the specified shader type from the named shader module\nfunction getModuleSource(moduleName, type) {\n  const shaderModule = getShaderModule(moduleName);\n  let moduleSource;\n  switch (type) {\n  case VERTEX_SHADER:\n    moduleSource = shaderModule.vs || shaderModule.vertexShader;\n    break;\n  case FRAGMENT_SHADER:\n    moduleSource = shaderModule.fs || shaderModule.fragmentShader;\n    break;\n  default:\n    assert(false);\n  }\n\n  if (typeof moduleSource !== 'string') {\n    return '';\n  }\n\n  return `\\\n#define MODULE_${moduleName.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${moduleName}\n\n`;\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(gl, {\n  id,\n  source,\n  type,\n  modules = [],\n  defines = {}\n}) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceLines = source.split('\\n');\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = `\\\n${getShaderName({id, source, type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl)}\n${getApplicationDefines(defines)}\n${type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : ''}\n`;\n\n  // Add source of dependent modules in resolved order\n  let inject = false;\n  for (const moduleName of modules) {\n    switch (moduleName) {\n    case 'inject':\n      inject = true;\n      break;\n    default:\n      checkDeprecation(moduleName, coreSource);\n      // Add the module source, and a #define that declares it presence\n      assembledSource += getModuleSource(moduleName, type);\n    }\n  }\n\n  // Add the version directive and actual source of this shader\n  assembledSource = versionLine + assembledSource + coreSource;\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (inject) {\n    assembledSource.replace('}\\s*$', MODULE_INJECTORS);\n  }\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const moduleName of modules) {\n      const shaderModule = getShaderModule(moduleName);\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = shaderModule.getUniforms ?\n        shaderModule.getUniforms(opts, uniforms) : {};\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\n/**\n * Apply set of modules\n */\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n"],"file":"assemble-shaders.js"}