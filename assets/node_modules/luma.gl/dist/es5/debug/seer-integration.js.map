{"version":3,"sources":["../../../src/debug/seer-integration.js"],"names":["models","addModel","model","id","seer","listItem","logModel","uniforms","isReady","throttle","attributesObject","geometry","Object","assign","attributes","uniformsObject","multiUpdate","path","data","removeModel","deleteItem","recursiveSet","obj","value","length","slice","overrides","Map","setOverride","valuePath","window","__SEER_INITIALIZED__","has","set","get","getOverrides","overs","forEach","listenFor","payload","itemKey","type","getUniforms","setUniforms"],"mappings":"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","sourcesContent":["import seer from 'seer';\n\nimport {window} from '../utils/globals';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1E3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry ?\n    Object.assign({}, model.geometry.attributes, model.attributes) :\n    model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n"],"file":"seer-integration.js"}