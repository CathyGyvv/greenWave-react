{"version":3,"sources":["../../../src/webgl/functions.js"],"names":["readPixels","gl","x","y","width","height","data","dataOffset","type","GL","UNSIGNED_BYTE","sourceHeight","format","RGBA","Uint8Array","readPixelsToBuffer","buffer","bindBuffer","PIXEL_PACK_BUFFER","handle","blitFramebuffer","source","sourceX","sourceY","sourceWidth","dest","destX","destY","destWidth","destHeight","mask","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","filter","LINEAR"],"mappings":";;;;;;;;;AAGA;;AACA;;AACA;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;AAmBO,SAASA,UAAT,CAAoBC,EAApB,QAUJ;AAAA,MATDC,CASC,QATDA,CASC;AAAA,MARDC,CAQC,QARDA,CAQC;AAAA,wBAPDC,KAOC;AAAA,MAPDA,KAOC,2BAPO,CAOP;AAAA,yBANDC,MAMC;AAAA,MANDA,MAMC,4BANQ,CAMR;AAAA,MALDC,IAKC,QALDA,IAKC;AAAA,6BAJDC,UAIC;AAAA,MAJDA,UAIC,gCAJY,CAIZ;AAAA,uBAHDC,IAGC;AAAA,MAHDA,IAGC,0BAHMC,mBAAGC,aAGT;AAAA,MAFDC,YAEC,QAFDA,YAEC;AAAA,yBADDC,MACC;AAAA,MADDA,MACC,4BADQH,mBAAGI,IACX;AACD;AACAP,SAAOA,QAAQ,IAAIQ,UAAJ,CAAe,IAAIV,KAAJ,GAAYC,MAA3B,CAAf,CAFC,CAGD;;AACAF,MAAIQ,eAAeA,eAAeR,CAA9B,GAAkCA,CAAtC;;AACA,MAAII,UAAJ,EAAgB;AACd,yCAAoBN,EAApB;AACAA,OAAGD,UAAH,CAAcE,CAAd,EAAiBC,CAAjB,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmCO,MAAnC,EAA2CJ,IAA3C,EAAiDF,IAAjD,EAAuDC,UAAvD;AACD,GAHD,MAGO;AACLN,OAAGD,UAAH,CAAcE,CAAd,EAAiBC,CAAjB,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmCO,MAAnC,EAA2CJ,IAA3C,EAAiDF,IAAjD;AACD;;AACD,SAAOA,IAAP;AACD;AAED;;;;;;;;;;AAQO,SAASS,kBAAT,CAA4Bd,EAA5B,SAUJ;AAAA,MATDC,CASC,SATDA,CASC;AAAA,MARDC,CAQC,SARDA,CAQC;AAAA,0BAPDC,KAOC;AAAA,MAPDA,KAOC,4BAPO,CAOP;AAAA,2BANDC,MAMC;AAAA,MANDA,MAMC,6BANQ,CAMR;AAAA,MALDW,MAKC,SALDA,MAKC;AAAA,+BAJDT,UAIC;AAAA,MAJDA,UAIC,iCAJY,CAIZ;AAAA,yBAHDC,IAGC;AAAA,MAHDA,IAGC,2BAHMC,mBAAGC,aAGT;AAAA,MAFDC,YAEC,SAFDA,YAEC;AAAA,2BADDC,MACC;AAAA,MADDA,MACC,6BADQH,mBAAGI,IACX;AACD,uCAAoBZ,EAApB,EADC,CAGD;;AACAE,MAAIQ,eAAeA,eAAeR,CAA9B,GAAkCA,CAAtC;AAEAF,KAAGgB,UAAH,CAAcR,mBAAGS,iBAAjB,EAAoCF,OAAOG,MAA3C;AAEAlB,KAAGD,UAAH,CAAcE,CAAd,EAAiBC,CAAjB,EAAoBC,KAApB,EAA2BC,MAA3B,EAAmCO,MAAnC,EAA2CJ,IAA3C,EAAiDD,UAAjD;AAEAN,KAAGgB,UAAH,CAAcR,mBAAGS,iBAAjB,EAAoC,IAApC;AAEA,SAAOF,MAAP;AACD;AAED;;;;;AAGO,SAASI,eAAT,CAAyBnB,EAAzB,SAKJ;AAAA,0CAJDoB,MAIC;AAAA,MAJQC,OAIR;AAAA,MAJiBC,OAIjB;AAAA,MAJ0BC,WAI1B;AAAA,MAJuCb,YAIvC;AAAA,wCAHDc,IAGC;AAAA,MAHMC,KAGN;AAAA,MAHaC,KAGb;AAAA,MAHoBC,SAGpB;AAAA,MAH+BC,UAG/B;AAAA,yBAFDC,IAEC;AAAA,MAFDA,IAEC,2BAFMrB,mBAAGsB,gBAAH,GAAsBtB,mBAAGuB,gBAAzB,GAA4CvB,mBAAGwB,kBAErD;AAAA,2BADDC,MACC;AAAA,MADDA,MACC,6BADQzB,mBAAG0B,MACX;AACF","sourcesContent":["/* eslint-disable */\n// TODO - generic draw call\n// One of the good things about GL is that there are so many ways to draw things\nimport GL from '../constants';\nimport {withParameters} from '../webgl-context';\nimport {assertWebGLContext, assertWebGL2Context, getKey} from '../webgl-utils';\nimport assert from '../utils/assert';\n\n/**\n * Read pixels from a target\n *\n * Will read from the currently bound framebuffer, or the currently bound\n *  drawing buffer - if context has been created with\n *  preserveDrawingBuffers\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} opts\n * @param {Number} opts.x - leftmost coord to be read\n * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)\n * @param {Number} opts.width=1 - width of area to be read\n * @param {Number} opts.height=1 - height of area to be read\n * @param {Number} opts.sourceHeight= - target height, implies top left coords\n * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array\n * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA\n *\n * @return {ArrayView} - types array, either passed in or autoallocated\n */\nexport function readPixels(gl, {\n  x,\n  y,\n  width = 1,\n  height = 1,\n  data,\n  dataOffset = 0,\n  type = GL.UNSIGNED_BYTE,\n  sourceHeight,\n  format = GL.RGBA\n}) {\n  // Read color in the central pixel, to be mapped with picking colors\n  data = data || new Uint8Array(4 * width * height);\n  // If source height is specified, a top left coordinate system is used\n  y = sourceHeight ? sourceHeight - y : y;\n  if (dataOffset) {\n    assertWebGL2Context(gl);\n    gl.readPixels(x, y, width, height, format, type, data, dataOffset);\n  } else {\n    gl.readPixels(x, y, width, height, format, type, data);\n  }\n  return data;\n}\n\n/**\n * Read pixels directly into webgl buffer\n * NOTE: WebGL2 only\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} options\n * @return {WebGLBuffer} the passed in buffer\n */\nexport function readPixelsToBuffer(gl, {\n  x,\n  y,\n  width = 1,\n  height = 1,\n  buffer,\n  dataOffset = 0,\n  type = GL.UNSIGNED_BYTE,\n  sourceHeight,\n  format = GL.RGBA\n}) {\n  assertWebGL2Context(gl);\n\n  // If source height is specified, a top left coordinate system is used\n  y = sourceHeight ? sourceHeight - y : y;\n\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, buffer.handle);\n\n  gl.readPixels(x, y, width, height, format, type, dataOffset);\n\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n\n  return buffer;\n}\n\n/*\n* @param {} opt.filter\n */\nexport function blitFramebuffer(gl, {\n  source: [sourceX, sourceY, sourceWidth, sourceHeight],\n  dest: [destX, destY, destWidth, destHeight],\n  mask = GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT,\n  filter = GL.LINEAR\n}) {\n}\n"],"file":"functions.js"}