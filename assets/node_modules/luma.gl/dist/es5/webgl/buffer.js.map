{"version":3,"sources":["../../../src/webgl/buffer.js"],"names":["GL_COPY_READ_BUFFER","GL_COPY_WRITE_BUFFER","GL_TRANSFORM_FEEDBACK_BUFFER","GL_UNIFORM_BUFFER","GL_ARRAY_BUFFER","GL_STATIC_DRAW","GL_FLOAT","BufferLayout","type","size","offset","stride","normalized","integer","instanced","Buffer","gl","opts","target","webgl2","setData","Object","seal","layout","assign","data","bytes","usage","index","arguments","Float32Array","byteLength","bytesUsed","setDataLayout","bindBuffer","handle","bufferData","options","initialize","srcOffset","length","undefined","bufferSubData","sourceBuffer","readOffset","writeOffset","copyBufferSubData","dstData","srcByteOffset","dstOffset","ArrayType","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstAvailableElementCount","dstElementCount","dstElementOffset","Math","min","copyElementCount","getBufferSubData","bindBufferBase","bindBufferRange","isIndexedBuffer","binding","getIndexedParameter","createBuffer","deleteBuffer","pname","value","getBufferParameter","sourceElementCount","BYTES_PER_ELEMENT","sourceElementOffset","Resource"],"mappings":"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","sourcesContent":["import Resource from './resource';\nimport {assertWebGL2Context} from '../webgl-utils';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport assert from '../utils/assert';\n\nconst GL_COPY_READ_BUFFER = 0x8F36;\nconst GL_COPY_WRITE_BUFFER = 0x8F37;\nconst GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;\nconst GL_UNIFORM_BUFFER = 0x8A11;\nconst GL_ARRAY_BUFFER = 0x8892;\n\nconst GL_STATIC_DRAW = 0x88E4;\nconst GL_FLOAT = 0x1406;\n\nexport class BufferLayout {\n  /**\n   * @classdesc\n   * Store characteristics of a data layout\n   * This data can be used when updating vertex attributes with\n   * the associated buffer, freeing the application from keeping\n   * track of this metadata.\n   *\n   * @class\n   * @param {GLuint} size - number of values per element (1-4)\n   * @param {GLuint} type - type of values (e.g. gl.FLOAT)\n   * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]\n   * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion\n   * @param {GLuint} stride=0 - supports strided arrays\n   * @param {GLuint} offset=0 - supports strided arrays\n   */\n  constructor({\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0\n  } = {}) {\n    this.type = type;\n    this.size = size;\n    this.offset = offset;\n    this.stride = stride;\n    this.normalized = normalized;\n    this.integer = integer;\n    this.instanced = instanced;\n  }\n}\n\nexport default class Buffer extends Resource {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n    // In WebGL1, we need to make sure we use GL.ELEMENT_ARRAY_BUFFER when\n    // initializing element buffers, otherwise the buffer type will be locked\n    // to a generic (non-element) buffer.\n    // In WebGL2, we can use GL_COPY_READ_BUFFER which avoids locking the type here\n    this.target = opts.target || (this.gl.webgl2 ? GL_COPY_READ_BUFFER : GL_ARRAY_BUFFER);\n    this.setData(opts);\n    Object.seal(this);\n  }\n\n  // Stores the layout of data with the buffer, makes it easy to e.g. set it as an attribute later\n  setDataLayout({\n    layout,\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0\n  }) {\n    this.layout = layout || new BufferLayout({\n      type: type || this.type, // Use autodeduced type if available\n      size,\n      offset,\n      stride,\n      normalized,\n      integer,\n      instanced\n    });\n    return this;\n  }\n\n  updateLayout(opts) {\n    Object.assign(this.layout, opts);\n  }\n  // Creates and initializes the buffer object's data store.\n  initialize({\n    data,\n    bytes,\n    usage = GL_STATIC_DRAW,\n    // Layout of stored data\n    layout,\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0,\n    index = null\n  } = {}) {\n    const opts = arguments[0];\n\n    if (!data) {\n      type = type || GL_FLOAT;\n\n      // Workaround needed for Safari (#291):\n      // gl.bufferData with size (second argument) equal to 0 crashes.\n      // hence create zero sized array.\n      if (!bytes || bytes === 0) {\n        bytes = 0;\n        data = new Float32Array(0);\n      }\n    } else {\n      type = type || getGLTypeFromTypedArray(data);\n      bytes = data.byteLength;\n      assert(type);\n    }\n\n    this.bytes = bytes;\n    this.bytesUsed = bytes;\n    this.data = data;\n    this.type = type;\n    this.usage = usage;\n    this.index = index;\n\n    // Call after type is set\n    this.setDataLayout(Object.assign(opts));\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data || bytes, usage);\n    this.gl.bindBuffer(target, null);\n\n    return this;\n  }\n\n  // DEPRECATED - Can we change to call `subData`?\n  setData(options) {\n    return this.initialize(options);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  subData({\n    data,          // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n    offset = 0,    // Offset into buffer\n    srcOffset = 0, // WebGL2 only: Offset into srcData\n    length         // WebGL2 only: Number of bytes to be copied\n  } = {}) {\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || length !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({\n    sourceBuffer,\n    readOffset = 0,\n    writeOffset = 0,\n    size\n  }) {\n    assertWebGL2Context(this.gl);\n\n    // Use GL_COPY_READ_BUFFER+GL_COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, sourceBuffer.handle);\n    this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, this.handle);\n\n    this.gl.copyBufferSubData(\n      GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER,\n      readOffset, writeOffset, size);\n\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n    this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, null);\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({\n    dstData = null,\n    srcByteOffset = 0,\n    dstOffset = 0,\n    length = 0\n  } = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.type, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n    let dstAvailableElementCount;\n    let dstElementCount;\n    const dstElementOffset = dstOffset;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount = Math.min(\n        sourceAvailableElementCount,\n        length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(\n      sourceAvailableElementCount,\n      dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount,\n      'Invalid srcByteOffset, dstOffset and length combination');\n    dstData = dstData || new ArrayType(dstElementCount);\n    // Use GL_COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL_COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   *\n   * @param {Glenum} target - target for the bind operation.\n   *\n   * @param {GLuint} index= - the index of the target.\n   *   - GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   * @param {GLuint} offset=0 - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   * @param {GLuint} size= - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   * @returns {Buffer} - Returns itself for chaining.\n   */\n  bind({target = this.target, index = this.index, offset = 0, size} = {}) {\n    // NOTE: While GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    const type = (target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER) ?\n      (size !== undefined ? 'ranged' : 'indexed') : 'non-indexed';\n\n    switch (type) {\n    case 'non-indexed':\n      this.gl.bindBuffer(target, this.handle);\n      break;\n    case 'indexed':\n      assertWebGL2Context(this.gl);\n      assert(offset === 0); // Make sure offset wasn't supplied\n      this.gl.bindBufferBase(target, index, this.handle);\n      break;\n    case 'ranged':\n      assertWebGL2Context(this.gl);\n      this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      break;\n    default:\n      assert(false);\n    }\n\n    return this;\n  }\n\n  unbind({target = this.target, index = this.index} = {}) {\n    const isIndexedBuffer = target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // TODO - is this the right place?\n  // gl.TRANSFORM_FEEDBACK_BUFFER_BINDING: Returns a WebGLBuffer.\n  // gl.TRANSFORM_FEEDBACK_BUFFER_SIZE: Returns a GLsizeiptr.\n  // gl.TRANSFORM_FEEDBACK_BUFFER_START: Returns a GLintptr.\n  // gl.UNIFORM_BUFFER_BINDING: Returns a WebGLBuffer.\n  // gl.UNIFORM_BUFFER_SIZE: Returns a GLsizeiptr.\n  // gl.UNIFORM_BUFFER_START: Returns a GLintptr.\n  getIndexedParameter(binding, index) {\n    // Create the buffer - if binding it here for the first time, this locks the type\n    // In WebGL2, use GL_COPY_READ_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_READ_BUFFER : this.target;\n    this.gl.bindBuffer(target, index);\n    return this.gl.getIndexedParameter(binding, index);\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.type, {clamped: false});\n    const sourceElementCount = this.bytes / ArrayType.BYTES_PER_ELEMENT;\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return sourceElementCount - sourceElementOffset;\n  }\n}\n"],"file":"buffer.js"}