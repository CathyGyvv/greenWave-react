{"version":3,"sources":["../../../src/webgl/buffer.js"],"names":["Resource","assertWebGL2Context","getGLTypeFromTypedArray","getTypedArrayFromGLType","assert","GL_COPY_READ_BUFFER","GL_COPY_WRITE_BUFFER","GL_TRANSFORM_FEEDBACK_BUFFER","GL_UNIFORM_BUFFER","GL_ARRAY_BUFFER","GL_STATIC_DRAW","GL_FLOAT","BufferLayout","constructor","type","size","offset","stride","normalized","integer","instanced","Buffer","gl","opts","target","webgl2","setData","Object","seal","setDataLayout","layout","updateLayout","assign","initialize","data","bytes","usage","index","arguments","Float32Array","byteLength","bytesUsed","bindBuffer","handle","bufferData","options","subData","srcOffset","length","undefined","bufferSubData","copyData","sourceBuffer","readOffset","writeOffset","copyBufferSubData","getData","dstData","srcByteOffset","dstOffset","ArrayType","clamped","sourceAvailableElementCount","_getAvailableElementCount","dstAvailableElementCount","dstElementCount","dstElementOffset","Math","min","copyElementCount","getBufferSubData","bind","bindBufferBase","bindBufferRange","unbind","isIndexedBuffer","getIndexedParameter","binding","_createHandle","createBuffer","_deleteHandle","deleteBuffer","_getParameter","pname","value","getBufferParameter","sourceElementCount","BYTES_PER_ELEMENT","sourceElementOffset"],"mappings":"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","sourcesContent":["import Resource from './resource';\nimport {assertWebGL2Context} from '../webgl-utils';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from '../webgl-utils/typed-array-utils';\nimport assert from '../utils/assert';\n\nconst GL_COPY_READ_BUFFER = 0x8F36;\nconst GL_COPY_WRITE_BUFFER = 0x8F37;\nconst GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;\nconst GL_UNIFORM_BUFFER = 0x8A11;\nconst GL_ARRAY_BUFFER = 0x8892;\n\nconst GL_STATIC_DRAW = 0x88E4;\nconst GL_FLOAT = 0x1406;\n\nexport class BufferLayout {\n  /**\n   * @classdesc\n   * Store characteristics of a data layout\n   * This data can be used when updating vertex attributes with\n   * the associated buffer, freeing the application from keeping\n   * track of this metadata.\n   *\n   * @class\n   * @param {GLuint} size - number of values per element (1-4)\n   * @param {GLuint} type - type of values (e.g. gl.FLOAT)\n   * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]\n   * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion\n   * @param {GLuint} stride=0 - supports strided arrays\n   * @param {GLuint} offset=0 - supports strided arrays\n   */\n  constructor({\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0\n  } = {}) {\n    this.type = type;\n    this.size = size;\n    this.offset = offset;\n    this.stride = stride;\n    this.normalized = normalized;\n    this.integer = integer;\n    this.instanced = instanced;\n  }\n}\n\nexport default class Buffer extends Resource {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n    // In WebGL1, we need to make sure we use GL.ELEMENT_ARRAY_BUFFER when\n    // initializing element buffers, otherwise the buffer type will be locked\n    // to a generic (non-element) buffer.\n    // In WebGL2, we can use GL_COPY_READ_BUFFER which avoids locking the type here\n    this.target = opts.target || (this.gl.webgl2 ? GL_COPY_READ_BUFFER : GL_ARRAY_BUFFER);\n    this.setData(opts);\n    Object.seal(this);\n  }\n\n  // Stores the layout of data with the buffer, makes it easy to e.g. set it as an attribute later\n  setDataLayout({\n    layout,\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0\n  }) {\n    this.layout = layout || new BufferLayout({\n      type: type || this.type, // Use autodeduced type if available\n      size,\n      offset,\n      stride,\n      normalized,\n      integer,\n      instanced\n    });\n    return this;\n  }\n\n  updateLayout(opts) {\n    Object.assign(this.layout, opts);\n  }\n  // Creates and initializes the buffer object's data store.\n  initialize({\n    data,\n    bytes,\n    usage = GL_STATIC_DRAW,\n    // Layout of stored data\n    layout,\n    type,\n    size = 1,\n    offset = 0,\n    stride = 0,\n    normalized = false,\n    integer = false,\n    instanced = 0,\n    index = null\n  } = {}) {\n    const opts = arguments[0];\n\n    if (!data) {\n      type = type || GL_FLOAT;\n\n      // Workaround needed for Safari (#291):\n      // gl.bufferData with size (second argument) equal to 0 crashes.\n      // hence create zero sized array.\n      if (!bytes || bytes === 0) {\n        bytes = 0;\n        data = new Float32Array(0);\n      }\n    } else {\n      type = type || getGLTypeFromTypedArray(data);\n      bytes = data.byteLength;\n      assert(type);\n    }\n\n    this.bytes = bytes;\n    this.bytesUsed = bytes;\n    this.data = data;\n    this.type = type;\n    this.usage = usage;\n    this.index = index;\n\n    // Call after type is set\n    this.setDataLayout(Object.assign(opts));\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    this.gl.bufferData(target, data || bytes, usage);\n    this.gl.bindBuffer(target, null);\n\n    return this;\n  }\n\n  // DEPRECATED - Can we change to call `subData`?\n  setData(options) {\n    return this.initialize(options);\n  }\n\n  // Updates a subset of a buffer object's data store.\n  subData({\n    data,          // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n    offset = 0,    // Offset into buffer\n    srcOffset = 0, // WebGL2 only: Offset into srcData\n    length         // WebGL2 only: Number of bytes to be copied\n  } = {}) {\n    assert(data);\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n    this.gl.bindBuffer(target, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || length !== undefined) {\n      assertWebGL2Context(this.gl);\n      this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);\n    } else {\n      this.gl.bufferSubData(target, offset, data);\n    }\n    this.gl.bindBuffer(target, null);\n    return this;\n  }\n\n  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n  copyData({\n    sourceBuffer,\n    readOffset = 0,\n    writeOffset = 0,\n    size\n  }) {\n    assertWebGL2Context(this.gl);\n\n    // Use GL_COPY_READ_BUFFER+GL_COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, sourceBuffer.handle);\n    this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, this.handle);\n\n    this.gl.copyBufferSubData(\n      GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER,\n      readOffset, writeOffset, size);\n\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n    this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, null);\n\n    return this;\n  }\n\n  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n  getData({\n    dstData = null,\n    srcByteOffset = 0,\n    dstOffset = 0,\n    length = 0\n  } = {}) {\n    assertWebGL2Context(this.gl);\n\n    const ArrayType = getTypedArrayFromGLType(this.type, {clamped: false});\n    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n    let dstAvailableElementCount;\n    let dstElementCount;\n    const dstElementOffset = dstOffset;\n    if (dstData) {\n      dstElementCount = dstData.length;\n      dstAvailableElementCount = dstElementCount - dstElementOffset;\n    } else {\n      // Allocate ArrayBufferView with enough size to copy all eligible data.\n      dstAvailableElementCount = Math.min(\n        sourceAvailableElementCount,\n        length || sourceAvailableElementCount);\n      dstElementCount = dstElementOffset + dstAvailableElementCount;\n    }\n\n    const copyElementCount = Math.min(\n      sourceAvailableElementCount,\n      dstAvailableElementCount);\n    length = length || copyElementCount;\n    assert(length <= copyElementCount,\n      'Invalid srcByteOffset, dstOffset and length combination');\n    dstData = dstData || new ArrayType(dstElementCount);\n    // Use GL_COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL_COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n    this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n    return dstData;\n  }\n\n  /**\n   * Binds a buffer to a given binding point (target).\n   *   GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n   *\n   * @param {Glenum} target - target for the bind operation.\n   *\n   * @param {GLuint} index= - the index of the target.\n   *   - GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n   * @param {GLuint} offset=0 - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n   * @param {GLuint} size= - the index of the target.\n   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n   * @returns {Buffer} - Returns itself for chaining.\n   */\n  bind({target = this.target, index = this.index, offset = 0, size} = {}) {\n    // NOTE: While GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n    // be used as direct binding points, they will not affect transform feedback or\n    // uniform buffer state. Instead indexed bindings need to be made.\n    const type = (target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER) ?\n      (size !== undefined ? 'ranged' : 'indexed') : 'non-indexed';\n\n    switch (type) {\n    case 'non-indexed':\n      this.gl.bindBuffer(target, this.handle);\n      break;\n    case 'indexed':\n      assertWebGL2Context(this.gl);\n      assert(offset === 0); // Make sure offset wasn't supplied\n      this.gl.bindBufferBase(target, index, this.handle);\n      break;\n    case 'ranged':\n      assertWebGL2Context(this.gl);\n      this.gl.bindBufferRange(target, index, this.handle, offset, size);\n      break;\n    default:\n      assert(false);\n    }\n\n    return this;\n  }\n\n  unbind({target = this.target, index = this.index} = {}) {\n    const isIndexedBuffer = target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER;\n    if (isIndexedBuffer) {\n      this.gl.bindBufferBase(target, index, null);\n    } else {\n      this.gl.bindBuffer(target, null);\n    }\n    return this;\n  }\n\n  // TODO - is this the right place?\n  // gl.TRANSFORM_FEEDBACK_BUFFER_BINDING: Returns a WebGLBuffer.\n  // gl.TRANSFORM_FEEDBACK_BUFFER_SIZE: Returns a GLsizeiptr.\n  // gl.TRANSFORM_FEEDBACK_BUFFER_START: Returns a GLintptr.\n  // gl.UNIFORM_BUFFER_BINDING: Returns a WebGLBuffer.\n  // gl.UNIFORM_BUFFER_SIZE: Returns a GLsizeiptr.\n  // gl.UNIFORM_BUFFER_START: Returns a GLintptr.\n  getIndexedParameter(binding, index) {\n    // Create the buffer - if binding it here for the first time, this locks the type\n    // In WebGL2, use GL_COPY_READ_BUFFER to avoid locking the type\n    const target = this.gl.webgl2 ? GL_COPY_READ_BUFFER : this.target;\n    this.gl.bindBuffer(target, index);\n    return this.gl.getIndexedParameter(binding, index);\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createBuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteBuffer(this.handle);\n  }\n\n  _getParameter(pname) {\n    this.gl.bindBuffer(this.target, this.handle);\n    const value = this.gl.getBufferParameter(this.target, pname);\n    this.gl.bindBuffer(this.target, null);\n    return value;\n  }\n\n  _getAvailableElementCount(srcByteOffset) {\n    const ArrayType = getTypedArrayFromGLType(this.type, {clamped: false});\n    const sourceElementCount = this.bytes / ArrayType.BYTES_PER_ELEMENT;\n    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n    return sourceElementCount - sourceElementOffset;\n  }\n}\n"],"file":"buffer.js"}