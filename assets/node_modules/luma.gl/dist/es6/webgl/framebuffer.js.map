{"version":3,"sources":["../../../src/webgl/framebuffer.js"],"names":["GL","Resource","Texture2D","Renderbuffer","Buffer","clear","clearBuffer","withParameters","getFeatures","getTypedArrayFromGLType","getGLTypeFromTypedArray","glFormatToComponents","glTypeToBytes","isWebGL2","assertWebGL2Context","flipRows","scalePixels","log","assert","GL_FRAMEBUFFER","GL_DRAW_FRAMEBUFFER","GL_READ_FRAMEBUFFER","GL_COLOR_ATTACHMENT0","GL_DEPTH_ATTACHMENT","GL_STENCIL_ATTACHMENT","GL_RENDERBUFFER","GL_TEXTURE_3D","GL_TEXTURE_2D_ARRAY","GL_TEXTURE_2D","GL_TEXTURE_CUBE_MAP","GL_TEXTURE_CUBE_MAP_POSITIVE_X","GL_DEPTH_BUFFER_BIT","GL_STENCIL_BUFFER_BIT","GL_COLOR_BUFFER_BIT","ERR_MULTIPLE_RENDERTARGETS","Framebuffer","isSupported","gl","colorBufferFloat","colorBufferHalfFloat","supported","getExtension","getDefaultFramebuffer","luma","defaultFramebuffer","handle","attachments","MAX_COLOR_ATTACHMENTS","getParameter","MAX_DRAW_BUFFERS","constructor","opts","width","height","readBuffer","drawBuffers","initialize","Object","seal","color","texture","depth","stencil","check","attachment","target","object","Array","isArray","resize","_createDefaultAttachments","update","clearAttachments","checkStatus","attach","prevHandle","bindFramebuffer","_setReadBuffer","_setDrawBuffers","undefined","drawingBufferWidth","drawingBufferHeight","id","attachmentPoint","newAttachments","keys","forEach","key","assign","descriptor","_unattach","_attachRenderbuffer","renderbuffer","layer","level","_attachTexture","filter","status","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Error","_getFrameBufferStatus","value","drawBuffer","readPixels","x","y","format","RGBA","type","pixelArray","COLOR_ATTACHMENT0","FRONT","UNSIGNED_BYTE","ArrayType","clamped","components","readPixelsToBuffer","buffer","byteOffset","byteCount","bytes","size","bind","PIXEL_PACK_BUFFER","framebuffer","unbind","copyToDataUrl","maxHeight","Number","MAX_SAFE_INTEGER","data","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","image","dataUrl","readDataUrl","Image","src","copyToTexture","xoffset","yoffset","zoffset","mipmapLevel","prevBuffer","isFinite","copyTexSubImage2D","copyTexSubImage3D","blit","srcFramebuffer","srcX0","srcY0","srcX1","srcY1","dstX0","dstY0","dstX1","dstY1","mask","NEAREST","prevDrawHandle","prevReadHandle","blitFramebuffer","invalidate","invalidateAll","invalidateFramebuffer","getAttachmentParameter","pname","_getAttachmentParameterFallback","bindTexture","getFramebufferAttachmentParameter","getAttachmentParameters","parameters","ATTACHMENT_PARAMETERS","values","show","window","open","priority","message","defaultAttachments","pixels","mipmaps","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","DEPTH_COMPONENT16","bindRenderbuffer","framebufferRenderbuffer","framebufferTextureLayer","face","mapIndexToCubeMapFace","framebufferTexture2D","BACK","ext","drawBuffersWEBGL","length","caps","FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER","webgl2","FRAMEBUFFER_ATTACHMENT_RED_SIZE","FRAMEBUFFER_ATTACHMENT_GREEN_SIZE","FRAMEBUFFER_ATTACHMENT_BLUE_SIZE","FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE","FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE","FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE","FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE","UNSIGNED_INT","FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING","EXT_sRGB","LINEAR","_createHandle","createFramebuffer","_deleteHandle","deleteFramebuffer","STATUS"],"mappings":"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","sourcesContent":["import GL from '../constants';\n\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport Buffer from './buffer';\nimport {clear, clearBuffer} from './clear';\n\nimport {withParameters} from '../webgl-context';\nimport {getFeatures} from '../webgl-context/context-features';\n\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {isWebGL2, assertWebGL2Context} from '../webgl-utils';\nimport {flipRows, scalePixels} from '../webgl-utils';\n\nimport {log} from '../utils';\nimport assert from '../utils/assert';\n\n// Local constants - will collapse during minification\nconst GL_FRAMEBUFFER = 0x8D40;\nconst GL_DRAW_FRAMEBUFFER = 0x8CA8;\nconst GL_READ_FRAMEBUFFER = 0x8CA9;\n\nconst GL_COLOR_ATTACHMENT0 = 0x8CE0;\nconst GL_DEPTH_ATTACHMENT = 0x8D00;\nconst GL_STENCIL_ATTACHMENT = 0x8D20;\n// const GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\nconst GL_RENDERBUFFER = 0x8D41;\n\nconst GL_TEXTURE_3D = 0x806F;\nconst GL_TEXTURE_2D_ARRAY = 0x8C1A;\nconst GL_TEXTURE_2D = 0x0DE1;\nconst GL_TEXTURE_CUBE_MAP = 0x8513;\n\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\n\nconst GL_DEPTH_BUFFER_BIT = 0x00000100;\nconst GL_STENCIL_BUFFER_BIT = 0x00000400;\nconst GL_COLOR_BUFFER_BIT = 0x00004000;\n\nconst ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\n\nexport default class Framebuffer extends Resource {\n\n  static isSupported(gl, {\n    colorBufferFloat,    // Whether floating point textures can be rendered and read\n    colorBufferHalfFloat // Whether half float textures can be rendered and read\n  } = {}) {\n    let supported = true;\n    supported = colorBufferFloat &&\n      gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'WEBGL_color_buffer_float');\n    supported = colorBufferHalfFloat &&\n      gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');\n    return supported;\n  }\n\n  // Create a Framebuffer wrapper for the default framebuffer (target === null)\n  static getDefaultFramebuffer(gl) {\n    gl.luma = gl.luma || {};\n    if (!gl.luma.defaultFramebuffer) {\n      gl.luma.defaultFramebuffer = new Framebuffer(gl, {handle: null, attachments: {}});\n    }\n    // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?\n    return gl.luma.defaultFramebuffer;\n  }\n\n  get MAX_COLOR_ATTACHMENTS() {\n    return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);\n  }\n\n  get MAX_DRAW_BUFFERS() {\n    return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);\n  }\n\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    // Public members\n    this.width = null;\n    this.height = null;\n    this.attachments = {};\n    this.readBuffer = GL_COLOR_ATTACHMENT0;\n    this.drawBuffers = [GL_COLOR_ATTACHMENT0];\n    this.initialize(opts);\n\n    Object.seal(this);\n  }\n\n  get color() {\n    return this.attachments[GL_COLOR_ATTACHMENT0] || null;\n  }\n\n  get texture() {\n    return this.attachments[GL_COLOR_ATTACHMENT0] || null;\n  }\n\n  get depth() {\n    return this.attachments[GL_DEPTH_ATTACHMENT] || null;\n  }\n\n  get stencil() {\n    return this.attachments[GL_STENCIL_ATTACHMENT] || null;\n  }\n\n  initialize({\n    width = 1,\n    height = 1,\n    attachments = null,\n    color = true,\n    depth = true,\n    stencil = false,\n    check = true,\n    readBuffer,\n    drawBuffers\n  }) {\n    assert(width >= 0 && height >= 0, 'Width and height need to be integers');\n\n    // Store actual width and height for diffing\n    this.width = width;\n    this.height = height;\n\n    // Resize any provided attachments - note that resize only resizes if needed\n    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)\n    if (attachments) {\n      for (const attachment in attachments) {\n        const target = attachments[attachment];\n        const object = Array.isArray(target) ? target[0] : target;\n        object.resize({width, height});\n      }\n    } else {\n      // Create any requested default attachments\n      attachments = this._createDefaultAttachments({color, depth, stencil, width, height});\n    }\n\n    this.update({clearAttachments: true, attachments, readBuffer, drawBuffers});\n\n    // Checks that framebuffer was properly set up, if not, throws an explanatory error\n    if (attachments && check) {\n      this.checkStatus();\n    }\n  }\n\n  update({\n    attachments = {},\n    readBuffer,\n    drawBuffers,\n    clearAttachments = false\n  }) {\n    this.attach(attachments, {clearAttachments});\n\n    const {gl} = this;\n    // Multiple render target support, set read buffer and draw buffers\n    const prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n    if (readBuffer) {\n      this._setReadBuffer(readBuffer);\n    }\n    if (drawBuffers) {\n      this._setDrawBuffers(drawBuffers);\n    }\n    gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // Attachment resize is expected to be a noop if size is same\n  resize({width, height} = {}) {\n    // for default framebuffer, just update the stored size\n    if (this.handle === null) {\n      assert(width === undefined && height === undefined);\n      this.width = this.gl.drawingBufferWidth;\n      this.height = this.gl.drawingBufferHeight;\n      return this;\n    }\n\n    if (width === undefined) {\n      width = this.gl.drawingBufferWidth;\n    }\n    if (height === undefined) {\n      height = this.gl.drawingBufferHeight;\n    }\n\n    if (width !== this.width && height !== this.height) {\n      log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`);\n    }\n    for (const attachmentPoint in this.attachments) {\n      this.attachments[attachmentPoint].resize({width, height});\n    }\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  // Attach from a map of attachments\n  attach(attachments, {\n    clearAttachments = false\n  } = {}) {\n    const newAttachments = {};\n\n    // Any current attachments need to be removed, add null values to map\n    if (clearAttachments) {\n      Object.keys(this.attachments).forEach(key => {\n        newAttachments[key] = null;\n      });\n    }\n\n    // Overlay the new attachments\n    Object.assign(newAttachments, attachments);\n\n    const prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n\n    // Walk the attachments\n    for (const attachment in newAttachments) {\n      // Ensure key is not undefined\n      assert(attachment !== 'undefined', 'Misspelled framebuffer binding point?');\n\n      const descriptor = newAttachments[attachment];\n      let object = descriptor;\n      if (!object) {\n        this._unattach({attachment});\n      } else if (object instanceof Renderbuffer) {\n        this._attachRenderbuffer({attachment, renderbuffer: object});\n      } else if (Array.isArray(descriptor)) {\n        const [texture, layer = 0, level = 0] = descriptor;\n        object = texture;\n        this._attachTexture({attachment, texture, layer, level});\n      } else {\n        this._attachTexture({attachment, texture: object, layer: 0, level: 0});\n      }\n\n      // Resize objects\n      if (object) {\n        object.resize({width: this.width, height: this.height});\n      }\n    }\n\n    this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n\n    // Assign to attachments and remove any nulls to get a clean attachment map\n    Object.assign(this.attachments, attachments);\n    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {\n      delete this.attachments[key];\n    });\n  }\n\n  checkStatus() {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n    const status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n    gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n      throw new Error(_getFrameBufferStatus(status));\n    }\n    return this;\n  }\n\n  clear({\n    color,\n    depth,\n    stencil,\n    drawBuffers = []\n  } = {}) {\n    // Bind framebuffer and delegate to global clear functions\n    const prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n\n    if (color || depth || stencil) {\n      clear(this.gl, {color, depth, stencil});\n    }\n\n    drawBuffers.forEach((value, drawBuffer) => {\n      clearBuffer({drawBuffer, value});\n    });\n\n    this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n\n    return this;\n  }\n\n  // NOTE: Slow requires roundtrip to GPU\n  // App can provide pixelArray or have it auto allocated by this method\n  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n  //  newly allocated by this method unless provided by app.\n  readPixels({\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    format = GL.RGBA,\n    type, // Auto deduced from pixelArray or gl.UNSIGNED_BYTE\n    pixelArray = null,\n    attachment = GL_COLOR_ATTACHMENT0 // TODO - support gl.readBuffer\n  }) {\n    const {gl} = this;\n\n    // TODO - Set and unset gl.readBuffer\n    if (attachment === GL.COLOR_ATTACHMENT0 && this.handle === null) {\n      attachment = GL.FRONT;\n    }\n\n    // Deduce type and allocated pixelArray if needed\n    if (!pixelArray) {\n      // Allocate pixel array if not already available, using supplied type\n      type = type || gl.UNSIGNED_BYTE;\n      const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n      const components = glFormatToComponents(format);\n      // TODO - check for composite type (components = 1).\n      pixelArray = pixelArray || new ArrayType(width * height * components);\n    }\n\n    // Pixel array available, if necessary, deduce type from it.\n    type = type || getGLTypeFromTypedArray(pixelArray);\n\n    const prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n    this.gl.readPixels(x, y, width, height, format, type, pixelArray);\n    this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n\n    return pixelArray;\n  }\n\n  // Reads data into provided buffer object asynchronously\n  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n  readPixelsToBuffer({\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    format = GL.RGBA,\n    type, // When not provided, auto deduced from buffer or GL.UNSIGNED_BYTE\n    buffer = null, // A new Buffer object is created when not provided.\n    byteOffset = 0 // byte offset in buffer object\n  }) {\n    const {gl} = this;\n\n    // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n    assertWebGL2Context(gl);\n\n    // deduce type if not available.\n    type = type || (buffer ? buffer.type : GL.UNSIGNED_BYTE);\n\n    if (!buffer) {\n      // Create new buffer with enough size\n      const components = glFormatToComponents(format);\n      const byteCount = glTypeToBytes(type);\n      const bytes = byteOffset + (width * height * components * byteCount);\n      buffer = new Buffer(gl, {\n        bytes,\n        type,\n        size: components\n      });\n    }\n\n    buffer.bind({target: GL.PIXEL_PACK_BUFFER});\n    withParameters(gl, {framebuffer: this}, () => {\n      gl.readPixels(x, y, width, height, format, type, byteOffset);\n    });\n    buffer.unbind({target: GL.PIXEL_PACK_BUFFER});\n\n    return buffer;\n  }\n\n  // Reads pixels as a dataUrl\n  copyToDataUrl({\n    attachment = GL_COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    maxHeight = Number.MAX_SAFE_INTEGER\n  } = {}) {\n    let data = this.readPixels({attachment});\n\n    // Scale down\n    let {width, height} = this;\n    while (height > maxHeight) {\n      ({data, width, height} = scalePixels({data, width, height}));\n    }\n\n    // Flip to top down coordinate system\n    flipRows({data, width, height});\n\n    /* global document */\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d');\n\n    // Copy the pixels to a 2D canvas\n    const imageData = context.createImageData(width, height);\n    imageData.data.set(data);\n    context.putImageData(imageData, 0, 0);\n\n    return canvas.toDataURL();\n  }\n\n  // Reads pixels into an HTML Image\n  copyToImage({\n    image = null,\n    attachment = GL_COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    maxHeight = Number.MAX_SAFE_INTEGER\n  } = {}) {\n    /* global Image */\n    const dataUrl = this.readDataUrl({attachment});\n    image = image || new Image();\n    image.src = dataUrl;\n    return image;\n  }\n\n  // copyToFramebuffer({width, height}) {\n  //   const scaleX = width / this.width;\n  //   const scaleY = height / this.height;\n  //   const scale = Math.min(scaleX, scaleY);\n  //   width = width * scale;\n  //   height = height * scale;\n  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});\n  //   this.blit();\n  // }\n\n  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)\n  copyToTexture({\n    // Target\n    texture,\n    target, // for cubemaps\n    xoffset = 0,\n    yoffset = 0,\n    zoffset = 0,\n    mipmapLevel = 0,\n\n    // Source\n    attachment = GL_COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    x = 0,\n    y = 0,\n    width, // defaults to texture width\n    height // defaults to texture height\n  }) {\n    const {gl} = this;\n    const prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n    const prevBuffer = gl.readBuffer(attachment);\n\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n\n    // target\n    switch (texture.target) {\n    case GL_TEXTURE_2D:\n    case GL_TEXTURE_CUBE_MAP:\n      gl.copyTexSubImage2D(\n        target || texture.target,\n        mipmapLevel,\n        xoffset,\n        yoffset,\n        x,\n        y,\n        width,\n        height\n      );\n      break;\n    case GL_TEXTURE_2D_ARRAY:\n    case GL_TEXTURE_3D:\n      gl.copyTexSubImage3D(\n        target || texture.target,\n        mipmapLevel,\n        xoffset,\n        yoffset,\n        zoffset,\n        x,\n        y,\n        width,\n        height\n      );\n      break;\n    default:\n    }\n\n    gl.readBuffer(prevBuffer);\n    gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);\n    return texture;\n  }\n\n  // WEBGL2 INTERFACE\n\n  // Copies a rectangle of pixels between framebuffers\n  blit({\n    srcFramebuffer,\n    attachment = GL_COLOR_ATTACHMENT0,\n    srcX0 = 0, srcY0 = 0, srcX1, srcY1,\n    dstX0 = 0, dstY0 = 0, dstX1, dstY1,\n    color = true,\n    depth = false,\n    stencil = false,\n    mask = 0,\n    filter = GL.NEAREST\n  }) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n\n    if (!srcFramebuffer.handle && attachment === GL_COLOR_ATTACHMENT0) {\n      attachment = GL.FRONT;\n    }\n\n    if (color) {\n      mask |= GL_COLOR_BUFFER_BIT;\n    }\n    if (depth) {\n      mask |= GL_DEPTH_BUFFER_BIT;\n    }\n    if (stencil) {\n      mask |= GL_STENCIL_BUFFER_BIT;\n    }\n    assert(mask);\n\n    srcX1 = srcX1 === undefined ? srcFramebuffer.width : srcX1;\n    srcY1 = srcY1 === undefined ? srcFramebuffer.height : srcY1;\n    dstX1 = dstX1 === undefined ? this.width : dstX1;\n    dstY1 = dstY1 === undefined ? this.height : dstY1;\n\n    const prevDrawHandle = gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, this.handle);\n    const prevReadHandle = gl.bindFramebuffer(GL_READ_FRAMEBUFFER, srcFramebuffer.handle);\n    gl.readBuffer(attachment);\n    gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n    gl.readBuffer(this.readBuffer);\n    gl.bindFramebuffer(GL_READ_FRAMEBUFFER, prevReadHandle || null);\n    gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, prevDrawHandle || null);\n\n    return this;\n  }\n\n  // signals to the GL that it need not preserve all pixels of a specified region\n  // of the framebuffer\n  invalidate({\n    attachments = [],\n    x = 0,\n    y = 0,\n    width,\n    height\n  }) {\n    const {gl} = this;\n    assertWebGL2Context(gl);\n    const prevHandle = gl.bindFramebuffer(GL_READ_FRAMEBUFFER, this.handle);\n    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n    if (invalidateAll) {\n      gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments);\n    } else {\n      gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments, x, y, width, height);\n    }\n    gl.bindFramebuffer(GL_READ_FRAMEBUFFER, prevHandle);\n    return this;\n  }\n\n  // Return the value for `pname` of the specified attachment.\n  // The type returned is the type of the requested pname\n  getAttachmentParameter({\n    attachment = GL_COLOR_ATTACHMENT0,\n    pname\n  } = {}) {\n    let value = this._getAttachmentParameterFallback(pname);\n    if (value === null) {\n      this.gl.bindTexture(GL_FRAMEBUFFER, this.handle);\n      value = this.gl.getFramebufferAttachmentParameter(GL_FRAMEBUFFER, attachment, pname);\n      this.gl.bindTexture(GL_FRAMEBUFFER, null);\n    }\n    return value;\n  }\n\n  getAttachmentParameters(\n    attachment = GL_COLOR_ATTACHMENT0,\n    parameters = this.constructor.ATTACHMENT_PARAMETERS || {}\n  ) {\n    const values = {};\n    for (const pname in parameters) {\n      values[pname] = this.getAttachmentParameter(pname);\n    }\n    return this;\n  }\n\n  // DEBUG\n\n  // Note: Will only work when called in an event handler\n  show() {\n    /* global window */\n    if (typeof window !== 'undefined') {\n      window.open(this.copyToDataUrl(), 'luma-debug-texture');\n    }\n    return this;\n  }\n\n  log({priority = 0, message = ''} = {}) {\n    if (priority > log.priority || typeof window === 'undefined') {\n      return this;\n    }\n    message = message || `Framebuffer ${this.id}`;\n    const image = this.copyToDataUrl({maxHeight: 100});\n    log.image({priority, message, image}, message)();\n    return this;\n  }\n\n  // WEBGL INTERFACE\n  bind({target = GL_FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, this.handle);\n    return this;\n  }\n\n  unbind({target = GL_FRAMEBUFFER} = {}) {\n    this.gl.bindFramebuffer(target, null);\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  _createDefaultAttachments({color, depth, stencil, width, height}) {\n    let defaultAttachments = null;\n\n    // Add a color buffer if requested and not supplied\n    if (color) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL_COLOR_ATTACHMENT0] = new Texture2D(this.gl, {\n        pixels: null, // reserves texture memory, but texels are undefined\n        format: GL.RGBA,\n        type: GL.UNSIGNED_BYTE,\n        width,\n        height,\n        // Note: Mipmapping can be disabled by texture resource when we resize the texture\n        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant\n        // behavior we always disable mipmaps.\n        mipmaps: false,\n        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.\n        // Set WRAP modes that support NPOT textures too.\n        parameters: {\n          [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n          [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n          [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n          [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n        }\n      });\n    }\n\n    // Add a depth buffer if requested and not supplied\n    if (depth) {\n      defaultAttachments = defaultAttachments || {};\n      defaultAttachments[GL_DEPTH_ATTACHMENT] =\n        new Renderbuffer(this.gl, {format: GL.DEPTH_COMPONENT16, width, height});\n    }\n\n    // TODO - handle stencil and combined depth and stencil\n\n    return defaultAttachments;\n  }\n\n  _unattach({attachment}) {\n    this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);\n    this.gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, null);\n    delete this.attachments[attachment];\n  }\n\n  _attachRenderbuffer({attachment = GL_COLOR_ATTACHMENT0, renderbuffer}) {\n    const {gl} = this;\n    // TODO - is the bind needed?\n    // gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.handle);\n    gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderbuffer.handle);\n    // TODO - is the unbind needed?\n    // gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n\n    this.attachments[attachment] = renderbuffer;\n  }\n\n  // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`\n  // level = 0 - mipmapLevel (must be 0 in WebGL1)\n  _attachTexture({attachment = GL_COLOR_ATTACHMENT0, texture, layer, level}) {\n    const {gl} = this;\n    gl.bindTexture(texture.target, texture.handle);\n\n    switch (texture.target) {\n    case GL_TEXTURE_2D_ARRAY:\n    case GL_TEXTURE_3D:\n      gl.framebufferTextureLayer(GL_FRAMEBUFFER, attachment, texture.target, level, layer);\n      break;\n\n    case GL_TEXTURE_CUBE_MAP:\n      // layer must be a cubemap face (or if index, converted to cube map face)\n      const face = mapIndexToCubeMapFace(layer);\n      gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, face, texture.handle, level);\n      break;\n\n    case GL_TEXTURE_2D:\n      gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texture.handle, level);\n      break;\n\n    default:\n      assert(false, 'Illegal texture type');\n    }\n\n    gl.bindTexture(texture.target, null);\n    this.attachments[attachment] = texture;\n  }\n\n  // Expects framebuffer to be bound\n  _setReadBuffer(gl, readBuffer) {\n    if (isWebGL2(gl)) {\n      gl.readBuffer(readBuffer);\n    } else {\n      // Setting to color attachment 0 is a noop, so allow it in WebGL1\n      assert(readBuffer === GL_COLOR_ATTACHMENT0 || readBuffer === GL.BACK,\n        ERR_MULTIPLE_RENDERTARGETS);\n    }\n    this.readBuffer = readBuffer;\n  }\n\n  // Expects framebuffer to be bound\n  _setDrawBuffers(gl, drawBuffers) {\n    if (isWebGL2(gl)) {\n      gl.drawBuffers(drawBuffers);\n    } else {\n      const ext = gl.getExtension('WEBGL_draw_buffers');\n      if (ext) {\n        ext.drawBuffersWEBGL(drawBuffers);\n      } else {\n        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1\n        assert(drawBuffers.length === 1 &&\n          (drawBuffers[0] === GL_COLOR_ATTACHMENT0 || drawBuffers[0] === GL.BACK),\n          ERR_MULTIPLE_RENDERTARGETS);\n      }\n    }\n    this.drawBuffers = drawBuffers;\n  }\n\n  // Attempt to provide workable defaults for WebGL2 symbols under WebGL1\n  // null means OK to query\n  /* eslint-disable complexity */\n  _getAttachmentParameterFallback(pname) {\n    const caps = getFeatures(this.gl);\n\n    switch (pname) {\n    case GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint\n      return !caps.webgl2 ? 0 : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint\n    case GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: // GLint\n      return !caps.webgl2 ? 8 : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: // GLenum\n      return !caps.webgl2 ? GL.UNSIGNED_INT : null;\n    case GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:\n      return !caps.webgl2 && !caps.EXT_sRGB ? GL.LINEAR : null;\n    default:\n      return null;\n    }\n  }\n  /* eslint-enable complexity */\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createFramebuffer();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteFramebuffer(this.handle);\n  }\n}\n\n// PUBLIC METHODS\n\n// Map an index to a cube map face constant\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < GL_TEXTURE_CUBE_MAP_POSITIVE_X ?\n    layer + GL_TEXTURE_CUBE_MAP_POSITIVE_X :\n    layer;\n}\n\n// Helper METHODS\n// Get a string describing the framebuffer error if installed\nfunction _getFrameBufferStatus(status) {\n  // Use error mapping if installed\n  const STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || `Framebuffer error ${status}`;\n}\n"],"file":"framebuffer.js"}