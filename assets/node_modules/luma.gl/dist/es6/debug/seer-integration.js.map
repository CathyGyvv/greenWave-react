{"version":3,"sources":["../../../src/debug/seer-integration.js"],"names":["seer","window","models","addModel","model","id","listItem","logModel","uniforms","isReady","throttle","attributesObject","geometry","Object","assign","attributes","uniformsObject","multiUpdate","path","data","removeModel","deleteItem","recursiveSet","obj","value","length","slice","overrides","Map","setOverride","valuePath","__SEER_INITIALIZED__","has","set","get","getOverrides","overs","forEach","listenFor","payload","itemKey","type","getUniforms","setUniforms"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AAEA,SAAQC,MAAR,QAAqB,kBAArB;AAEA,MAAMC,SAAS,EAAf;AAEA;;;;AAGA,OAAO,MAAMC,WAAWC,SAAS;AAC/B,MAAIF,OAAOE,MAAMC,EAAb,CAAJ,EAAsB;AACpB;AACD;;AACDH,SAAOE,MAAMC,EAAb,IAAmBD,KAAnB;AAEAJ,OAAKM,QAAL,CAAc,SAAd,EAAyBF,MAAMC,EAA/B;AACD,CAPM;AASP;;;;AAGA,OAAO,MAAME,WAAW,CAACH,KAAD,EAAQI,QAAR,KAAqB;AAC3C,MAAI,CAACR,KAAKS,OAAL,EAAD,IAAmBT,KAAKU,QAAL,CAAe,WAAUN,MAAMC,EAAG,EAAlC,EAAqC,GAArC,CAAvB,EAAkE;AAChE;AACD;;AAED,QAAMM,mBAAmBP,MAAMQ,QAAN,GACvBC,OAAOC,MAAP,CAAc,EAAd,EAAkBV,MAAMQ,QAAN,CAAeG,UAAjC,EAA6CX,MAAMW,UAAnD,CADuB,GAEvBX,MAAMW,UAFR;AAGA,QAAMC,iBAAiBH,OAAOC,MAAP,CAAc,EAAd,EAAkBV,MAAMI,QAAxB,EAAkCA,QAAlC,CAAvB;AAEAR,OAAKiB,WAAL,CAAiB,SAAjB,EAA4Bb,MAAMC,EAAlC,EAAsC,CACpC;AAACa,UAAM,kBAAP;AAA2BC,UAAMH;AAAjC,GADoC,EAEpC;AAACE,UAAM,oBAAP;AAA6BC,UAAMR;AAAnC,GAFoC,CAAtC;AAID,CAdM;AAgBP;;;;AAGA,OAAO,MAAMS,cAAcf,MAAM;AAC/B,SAAOH,OAAOG,EAAP,CAAP;AACAL,OAAKqB,UAAL,CAAgB,SAAhB,EAA2BhB,EAA3B;AACD,CAHM;AAKP;;;;AAGA,MAAMiB,eAAe,CAACC,GAAD,EAAML,IAAN,EAAYM,KAAZ,KAAsB;AACzC,MAAI,CAACD,GAAL,EAAU;AACR;AACD;;AAED,MAAIL,KAAKO,MAAL,GAAc,CAAlB,EAAqB;AACnBH,iBAAaC,IAAIL,KAAK,CAAL,CAAJ,CAAb,EAA2BA,KAAKQ,KAAL,CAAW,CAAX,CAA3B,EAA0CF,KAA1C;AACD,GAFD,MAEO;AACLD,QAAIL,KAAK,CAAL,CAAJ,IAAeM,KAAf;AACD;AACF,CAVD;;AAYA,MAAMG,YAAY,IAAIC,GAAJ,EAAlB;AAEA;;;;;AAIA,OAAO,MAAMC,cAAc,CAACxB,EAAD,EAAKyB,SAAL,EAAgBN,KAAhB,KAA0B;AACnD,MAAI,CAACvB,OAAO8B,oBAAZ,EAAkC;AAChC;AACD;;AAED,MAAI,CAACJ,UAAUK,GAAV,CAAc3B,EAAd,CAAL,EAAwB;AACtBsB,cAAUM,GAAV,CAAc5B,EAAd,EAAkB,IAAIuB,GAAJ,EAAlB;AACD;;AAED,QAAMpB,WAAWmB,UAAUO,GAAV,CAAc7B,EAAd,CAAjB;AACAG,WAASyB,GAAT,CAAaH,SAAb,EAAwBN,KAAxB;AACD,CAXM;AAaP;;;;AAGA,OAAO,MAAMW,eAAe,CAAC9B,EAAD,EAAKG,QAAL,KAAkB;AAC5C,MAAI,CAACP,OAAO8B,oBAAR,IAAgC,CAAC1B,EAArC,EAAyC;AACvC;AACD;;AAED,QAAM+B,QAAQT,UAAUO,GAAV,CAAc7B,EAAd,CAAd;;AACA,MAAI,CAAC+B,KAAL,EAAY;AACV;AACD;;AAEDA,QAAMC,OAAN,CAAc,CAACb,KAAD,EAAQM,SAAR,KAAsB;AAClCR,iBAAad,QAAb,EAAuBsB,SAAvB,EAAkCN,KAAlC;AACD,GAFD;AAGD,CAbM;AAeP;;;;AAGAxB,KAAKsC,SAAL,CAAe,SAAf,EAA0BC,WAAW;AACnC,QAAMnC,QAAQF,OAAOqC,QAAQC,OAAf,CAAd;;AACA,MAAI,CAACpC,KAAD,IAAUmC,QAAQE,IAAR,KAAiB,MAA3B,IAAqCF,QAAQT,SAAR,CAAkB,CAAlB,MAAyB,UAAlE,EAA8E;AAC5E;AACD;;AAED,QAAMA,YAAYS,QAAQT,SAAR,CAAkBJ,KAAlB,CAAwB,CAAxB,CAAlB;AACAG,cAAYU,QAAQC,OAApB,EAA6BV,SAA7B,EAAwCS,QAAQf,KAAhD;AAEA,QAAMhB,WAAWJ,MAAMsC,WAAN,EAAjB;AACApB,eAAad,QAAb,EAAuBsB,SAAvB,EAAkCS,QAAQf,KAA1C;AACApB,QAAMuC,WAAN,CAAkBnC,QAAlB;AACD,CAZD","sourcesContent":["import seer from 'seer';\n\nimport {window} from '../utils/globals';\n\nconst models = {};\n\n/**\n * Add a model to our cache indexed by id\n */\nexport const addModel = model => {\n  if (models[model.id]) {\n    return;\n  }\n  models[model.id] = model;\n\n  seer.listItem('luma.gl', model.id);\n};\n\n/**\n * Log a model uniforms and attributes.\n */\nexport const logModel = (model, uniforms) => {\n  if (!seer.isReady() || seer.throttle(`luma.gl:${model.id}`, 1E3)) {\n    return;\n  }\n\n  const attributesObject = model.geometry ?\n    Object.assign({}, model.geometry.attributes, model.attributes) :\n    model.attributes;\n  const uniformsObject = Object.assign({}, model.uniforms, uniforms);\n\n  seer.multiUpdate('luma.gl', model.id, [\n    {path: 'objects.uniforms', data: uniformsObject},\n    {path: 'objects.attributes', data: attributesObject}\n  ]);\n};\n\n/**\n * Remove a previously set model from the cache\n */\nexport const removeModel = id => {\n  delete models[id];\n  seer.deleteItem('luma.gl', id);\n};\n\n/**\n * Recursively traverse an object given a path of properties and set the given value\n */\nconst recursiveSet = (obj, path, value) => {\n  if (!obj) {\n    return;\n  }\n\n  if (path.length > 1) {\n    recursiveSet(obj[path[0]], path.slice(1), value);\n  } else {\n    obj[path[0]] = value;\n  }\n};\n\nconst overrides = new Map();\n\n/**\n * Create an override on the specify layer, indexed by a valuePath array.\n * Do nothing in case Seer as not been initialized to prevent any preformance drawback.\n */\nexport const setOverride = (id, valuePath, value) => {\n  if (!window.__SEER_INITIALIZED__) {\n    return;\n  }\n\n  if (!overrides.has(id)) {\n    overrides.set(id, new Map());\n  }\n\n  const uniforms = overrides.get(id);\n  uniforms.set(valuePath, value);\n};\n\n/**\n * Apply overrides to a specific model's uniforms\n */\nexport const getOverrides = (id, uniforms) => {\n  if (!window.__SEER_INITIALIZED__ || !id) {\n    return;\n  }\n\n  const overs = overrides.get(id);\n  if (!overs) {\n    return;\n  }\n\n  overs.forEach((value, valuePath) => {\n    recursiveSet(uniforms, valuePath, value);\n  });\n};\n\n/**\n * Listen for luma.gl edit events\n */\nseer.listenFor('luma.gl', payload => {\n  const model = models[payload.itemKey];\n  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {\n    return;\n  }\n\n  const valuePath = payload.valuePath.slice(1);\n  setOverride(payload.itemKey, valuePath, payload.value);\n\n  const uniforms = model.getUniforms();\n  recursiveSet(uniforms, valuePath, payload.value);\n  model.setUniforms(uniforms);\n});\n"],"file":"seer-integration.js"}