{"version":3,"sources":["../../../../src/shadertools/lib/assemble-shaders.js"],"names":["resolveModules","getShaderModule","getPlatformShaderDefines","getVersionDefines","MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","assert","log","VERTEX_SHADER","FRAGMENT_SHADER","SHADER_TYPE","MODULE_INJECTORS","FRAGMENT_SHADER_PROLOGUE","getShaderName","id","source","type","injectShaderName","indexOf","getApplicationDefines","defines","count","sourceText","define","toUpperCase","checkDeprecation","moduleName","shaderSource","shaderModule","deprecations","forEach","def","regex","test","deprecated","old","new","removed","getModuleSource","moduleSource","vs","vertexShader","fs","fragmentShader","assembleShader","gl","modules","sourceLines","split","versionLine","coreSource","slice","join","assembledSource","inject","replace","assembleGetUniforms","getUniforms","opts","uniforms","moduleUniforms","Object","assign","assembleModuleMap","result","assembleShaders"],"mappings":"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","sourcesContent":["import {resolveModules, getShaderModule} from './shader-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport assert from '../../utils/assert';\nimport {log} from '../../utils';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n`;\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n` : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n    sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\n// Warn about deprecated uniforms or functions\nfunction checkDeprecation(moduleName, shaderSource) {\n  const shaderModule = getShaderModule(moduleName);\n\n  shaderModule.deprecations.forEach(def => {\n    if (def.regex.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n\n// Extracts the source code chunk for the specified shader type from the named shader module\nfunction getModuleSource(moduleName, type) {\n  const shaderModule = getShaderModule(moduleName);\n  let moduleSource;\n  switch (type) {\n  case VERTEX_SHADER:\n    moduleSource = shaderModule.vs || shaderModule.vertexShader;\n    break;\n  case FRAGMENT_SHADER:\n    moduleSource = shaderModule.fs || shaderModule.fragmentShader;\n    break;\n  default:\n    assert(false);\n  }\n\n  if (typeof moduleSource !== 'string') {\n    return '';\n  }\n\n  return `\\\n#define MODULE_${moduleName.toUpperCase()}\n${moduleSource}\\\n// END MODULE_${moduleName}\n\n`;\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(gl, {\n  id,\n  source,\n  type,\n  modules = [],\n  defines = {}\n}) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceLines = source.split('\\n');\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = `\\\n${getShaderName({id, source, type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl)}\n${getApplicationDefines(defines)}\n${type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : ''}\n`;\n\n  // Add source of dependent modules in resolved order\n  let inject = false;\n  for (const moduleName of modules) {\n    switch (moduleName) {\n    case 'inject':\n      inject = true;\n      break;\n    default:\n      checkDeprecation(moduleName, coreSource);\n      // Add the module source, and a #define that declares it presence\n      assembledSource += getModuleSource(moduleName, type);\n    }\n  }\n\n  // Add the version directive and actual source of this shader\n  assembledSource = versionLine + assembledSource + coreSource;\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (inject) {\n    assembledSource.replace('}\\s*$', MODULE_INJECTORS);\n  }\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const moduleName of modules) {\n      const shaderModule = getShaderModule(moduleName);\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = shaderModule.getUniforms ?\n        shaderModule.getUniforms(opts, uniforms) : {};\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\n/**\n * Apply set of modules\n */\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n"],"file":"assemble-shaders.js"}