function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var Util = require('../util');

var Interaction = require('./base');

var ZOOMING_TYPES = ['X', 'Y', 'XY'];
var DEFAULT_TYPE = 'X';

var Zoom =
/*#__PURE__*/
function (_Interaction) {
  _inheritsLoose(Zoom, _Interaction);

  var _proto = Zoom.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      processEvent: 'mousewheel',
      type: DEFAULT_TYPE,
      stepRatio: 0.05,
      stepByField: {},
      originScaleDefsByField: {}
    });
  };

  function Zoom(cfg, view) {
    var _this;

    _this = _Interaction.call(this, cfg, view) || this;

    var me = _assertThisInitialized(_assertThisInitialized(_this));

    me.chart = view;
    me.type = me.type.toUpperCase();
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    var scaleController = view.get('scaleController');
    scales.forEach(function (scale) {
      var field = scale.field;
      var def = scaleController.defs[field] || {};
      me.originScaleDefsByField[field] = Util.mix(def, {
        nice: !!def.nice
      });

      if (scale.isLinear) {
        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
      }
    });

    if (ZOOMING_TYPES.indexOf(me.type) === -1) {
      me.type = DEFAULT_TYPE;
    }

    return _this;
  } // onZoom() { }
  // onZoomin() { }
  // onZoomout() { }


  _proto._applyScale = function _applyScale(scale, delta, minOffset) {
    if (minOffset === void 0) {
      minOffset = 0;
    }

    var me = this;
    var chart = me.chart,
        stepByField = me.stepByField;

    if (scale.isLinear) {
      var min = scale.min,
          max = scale.max,
          field = scale.field;
      var maxOffset = 1 - minOffset;
      var step = stepByField[field] * delta;
      var newMin = min + step * minOffset;
      var newMax = max - step * maxOffset;

      if (newMax > newMin) {
        chart.scale(field, {
          nice: false,
          min: newMin,
          max: newMax
        });
      }
    }
  };

  _proto.process = function process(ev) {
    var me = this;
    var chart = me.chart,
        type = me.type;
    var coord = chart.get('coord');
    var deltaY = ev.deltaY;
    var offsetPoint = coord.invertPoint(ev);

    if (deltaY) {
      me.onZoom && me.onZoom(deltaY, offsetPoint, me);

      if (deltaY > 0) {
        me.onZoomin && me.onZoomin(deltaY, offsetPoint, me);
      } else {
        me.onZoomout && me.onZoomout(deltaY, offsetPoint, me);
      }

      var delta = deltaY / Math.abs(deltaY);

      if (type.indexOf('X') > -1) {
        me._applyScale(chart.getXScale(), delta, offsetPoint.x);
      }

      if (type.indexOf('Y') > -1) {
        var yScales = chart.getYScales();
        yScales.forEach(function (yScale) {
          me._applyScale(yScale, delta, offsetPoint.y);
        });
      }
    }

    chart.repaint();
  };

  _proto.reset = function reset() {
    var me = this;
    var view = me.view,
        originScaleDefsByField = me.originScaleDefsByField;
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    scales.forEach(function (scale) {
      if (scale.isLinear) {
        var field = scale.field;
        view.scale(field, originScaleDefsByField[field]);
      }
    });
    view.repaint();
  };

  return Zoom;
}(Interaction); // G2.registerInteraction('zoom', Zoom);
// G2.registerInteraction('Zoom', Zoom);


module.exports = Zoom;