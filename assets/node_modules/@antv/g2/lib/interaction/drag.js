function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var Util = require('../util');

var Interaction = require('./base'); // const G2 = require('../core.js');


var DRAGGING_TYPES = ['X', 'Y', 'XY'];
var DEFAULT_TYPE = 'X';

var Drag =
/*#__PURE__*/
function (_Interaction) {
  _inheritsLoose(Drag, _Interaction);

  var _proto = Drag.prototype;

  _proto.getDefaultCfg = function getDefaultCfg() {
    var cfg = _Interaction.prototype.getDefaultCfg.call(this);

    return Util.mix({}, cfg, {
      type: DEFAULT_TYPE,
      stepRatio: 0.05,
      stepByField: {},
      originScaleDefsByField: {},
      previousPoint: null,
      isDragging: false
    });
  };

  function Drag(cfg, view) {
    var _this;

    _this = _Interaction.call(this, cfg, view) || this;

    var me = _assertThisInitialized(_assertThisInitialized(_this));

    me.type = me.type.toUpperCase();
    me.chart = view;
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    var scaleController = view.get('scaleController');
    scales.forEach(function (scale) {
      var field = scale.field;
      var def = scaleController.defs[field];
      me.originScaleDefsByField[field] = Util.mix(def, {
        nice: !!def.nice
      });

      if (scale.isLinear) {
        me.stepByField[field] = (scale.max - scale.min) * me.stepRatio;
      }
    });

    if (DRAGGING_TYPES.indexOf(me.type) === -1) {
      me.type = DEFAULT_TYPE;
    }

    return _this;
  } // onDragstart() { }
  // onDrag() { }
  // onDragend() { }


  _proto._applyTranslate = function _applyTranslate(scale, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var me = this;
    var chart = me.chart;
    var min = scale.min,
        max = scale.max,
        field = scale.field;
    var range = max - min;
    chart.scale(field, {
      nice: false,
      min: min - offset * range,
      max: max - offset * range
    });
  };

  _proto.start = function start(ev) {
    var me = this;
    var chart = me.chart,
        canvas = me.canvas;
    var canvasDOM = canvas.get('canvasDOM');
    canvasDOM.style.cursor = 'pointer';
    var coord = chart.get('coord');
    me.isDragging = true;
    me.previousPoint = coord.invertPoint(ev);
  };

  _proto.process = function process(ev) {
    var me = this;

    if (me.isDragging) {
      var chart = me.chart,
          type = me.type,
          canvas = me.canvas;
      var canvasDOM = canvas.get('canvasDOM');
      canvasDOM.style.cursor = 'move';
      var coord = chart.get('coord');
      var previousPoint = me.previousPoint;
      var currentPoint = coord.invertPoint(ev);

      if (type.indexOf('X') > -1) {
        me._applyTranslate(chart.getXScale(), currentPoint.x - previousPoint.x);
      }

      if (type.indexOf('Y') > -1) {
        var yScales = chart.getYScales();
        yScales.forEach(function (yScale) {
          me._applyTranslate(yScale, currentPoint.y - previousPoint.y);
        });
      }

      me.previousPoint = currentPoint;
      chart.repaint();
    }
  };

  _proto.end = function end() {
    var me = this;
    me.isDragging = false;
    var canvas = me.canvas;
    var canvasDOM = canvas.get('canvasDOM');
    canvasDOM.style.cursor = 'default';
  };

  _proto.reset = function reset() {
    var me = this;
    var view = me.view,
        originScaleDefsByField = me.originScaleDefsByField;
    var scales = view.getYScales();
    var xScale = view.getXScale();
    scales.push(xScale);
    scales.forEach(function (scale) {
      if (scale.isLinear) {
        var field = scale.field;
        view.scale(field, originScaleDefsByField[field]);
      }
    });
    view.repaint();
  };

  return Drag;
}(Interaction);

module.exports = Drag;